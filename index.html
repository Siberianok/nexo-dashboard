<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Préstamos / Plataforma</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    body{
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--theme-surface-soft, linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%));
      transition:background .3s ease;
    }
    :root{
      --theme-surface-soft:linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%);
      --theme-card-border:#dfe6ff;
      --theme-card-shadow:0 12px 30px rgba(16,35,90,.08);
      --theme-kpi-border:#e6eaf5;
      --theme-kpi-bg:linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%);
      --theme-kpi-shadow:0 16px 30px rgba(8,20,66,0.35);
      --theme-kpi-hover-shadow:0 22px 36px rgba(12,28,84,0.42);
      --theme-kpi-active-shadow:0 10px 18px rgba(10,24,70,0.3);
      --theme-btn-bg:linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%);
      --theme-btn-text:#fff;
      --theme-btn-border:rgba(255,255,255,0.22);
      --theme-btn-shadow:0 14px 28px rgba(15,33,90,0.32);
      --theme-btn-hover-shadow:0 20px 34px rgba(12,30,88,0.4);
      --theme-btn-active-shadow:0 10px 20px rgba(10,26,70,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%);
      --theme-ghost-text:#1e2f67;
      --theme-ghost-border:rgba(30,64,175,0.16);
      --theme-ghost-shadow:0 10px 22px rgba(15,30,70,0.12);
      --theme-ghost-hover-shadow:0 16px 26px rgba(15,30,70,0.18);
    }
    .theme-nexo{
      --theme-surface-soft:linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%);
      --theme-card-border:#dfe6ff;
      --theme-card-shadow:0 12px 30px rgba(16,35,90,.08);
      --theme-kpi-border:#e6eaf5;
      --theme-kpi-bg:linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%);
      --theme-kpi-shadow:0 16px 30px rgba(8,20,66,0.35);
      --theme-kpi-hover-shadow:0 22px 36px rgba(12,28,84,0.42);
      --theme-kpi-active-shadow:0 10px 18px rgba(10,24,70,0.3);
      --theme-btn-bg:linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%);
      --theme-btn-text:#fff;
      --theme-btn-border:rgba(255,255,255,0.22);
      --theme-btn-shadow:0 14px 28px rgba(15,33,90,0.32);
      --theme-btn-hover-shadow:0 20px 34px rgba(12,30,88,0.4);
      --theme-btn-active-shadow:0 10px 20px rgba(10,26,70,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%);
      --theme-ghost-text:#1e2f67;
      --theme-ghost-border:rgba(30,64,175,0.16);
      --theme-ghost-shadow:0 10px 22px rgba(15,30,70,0.12);
      --theme-ghost-hover-shadow:0 16px 26px rgba(15,30,70,0.18);
    }
    .theme-binance{
      --theme-surface-soft:linear-gradient(180deg,#fff6e6 0%,#ffedcc 100%);
      --theme-card-border:rgba(251,191,36,0.35);
      --theme-card-shadow:0 12px 30px rgba(146,64,14,0.15);
      --theme-kpi-border:rgba(253,224,71,0.45);
      --theme-kpi-bg:linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%);
      --theme-kpi-shadow:0 16px 30px rgba(146,64,14,0.32);
      --theme-kpi-hover-shadow:0 22px 36px rgba(124,45,18,0.42);
      --theme-kpi-active-shadow:0 10px 18px rgba(124,45,18,0.3);
      --theme-btn-bg:linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%);
      --theme-btn-text:#fff7db;
      --theme-btn-border:rgba(255,255,255,0.24);
      --theme-btn-shadow:0 14px 28px rgba(146,64,14,0.28);
      --theme-btn-hover-shadow:0 20px 34px rgba(124,45,18,0.35);
      --theme-btn-active-shadow:0 10px 20px rgba(124,45,18,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#fff7e6 100%);
      --theme-ghost-text:#7c2d12;
      --theme-ghost-border:rgba(217,119,6,0.3);
      --theme-ghost-shadow:0 10px 22px rgba(146,64,14,0.16);
      --theme-ghost-hover-shadow:0 16px 26px rgba(124,45,18,0.22);
    }
    .theme-youhodler{
      --theme-surface-soft:linear-gradient(180deg,#e0f2ff 0%,#f5fbff 100%);
      --theme-card-border:rgba(59,130,246,0.25);
      --theme-card-shadow:0 12px 30px rgba(30,64,175,0.12);
      --theme-kpi-border:rgba(125,211,252,0.6);
      --theme-kpi-bg:linear-gradient(155deg,#0ea5e9 0%,#2563eb 45%,#3b82f6 100%);
      --theme-kpi-shadow:0 16px 30px rgba(14,165,233,0.28);
      --theme-kpi-hover-shadow:0 22px 36px rgba(14,116,233,0.34);
      --theme-kpi-active-shadow:0 10px 18px rgba(14,116,233,0.24);
      --theme-btn-bg:linear-gradient(155deg,#0284c7 0%,#2563eb 50%,#38bdf8 100%);
      --theme-btn-text:#f0f9ff;
      --theme-btn-border:rgba(255,255,255,0.3);
      --theme-btn-shadow:0 14px 28px rgba(14,116,233,0.28);
      --theme-btn-hover-shadow:0 20px 34px rgba(14,116,233,0.35);
      --theme-btn-active-shadow:0 10px 20px rgba(14,116,233,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#e0f2ff 100%);
      --theme-ghost-text:#0f172a;
      --theme-ghost-border:rgba(59,130,246,0.22);
      --theme-ghost-shadow:0 10px 22px rgba(37,99,235,0.12);
      --theme-ghost-hover-shadow:0 16px 26px rgba(37,99,235,0.18);
    }
    .theme-ledn{
      --theme-surface-soft:linear-gradient(180deg,#f3f4f6 0%,#ffffff 100%);
      --theme-card-border:rgba(15,118,110,0.22);
      --theme-card-shadow:0 12px 30px rgba(15,118,110,0.12);
      --theme-kpi-border:rgba(45,212,191,0.45);
      --theme-kpi-bg:linear-gradient(155deg,#0f766e 0%,#14b8a6 45%,#2dd4bf 100%);
      --theme-kpi-shadow:0 16px 30px rgba(15,118,110,0.26);
      --theme-kpi-hover-shadow:0 22px 36px rgba(13,148,136,0.32);
      --theme-kpi-active-shadow:0 10px 18px rgba(15,118,110,0.22);
      --theme-btn-bg:linear-gradient(155deg,#0f766e 0%,#14b8a6 50%,#2dd4bf 100%);
      --theme-btn-text:#ecfeff;
      --theme-btn-border:rgba(255,255,255,0.28);
      --theme-btn-shadow:0 14px 28px rgba(13,148,136,0.25);
      --theme-btn-hover-shadow:0 20px 34px rgba(13,148,136,0.32);
      --theme-btn-active-shadow:0 10px 20px rgba(13,148,136,0.24);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#ecfdf5 100%);
      --theme-ghost-text:#0f172a;
      --theme-ghost-border:rgba(45,212,191,0.22);
      --theme-ghost-shadow:0 10px 22px rgba(15,118,110,0.12);
      --theme-ghost-hover-shadow:0 16px 26px rgba(15,118,110,0.18);
    }
    /* Paleta y estilos base */
    .nx-gradient{background:linear-gradient(135deg,#0b1e4b 0%,#1b44a6 50%,#2052c1 100%)}
    .bn-gradient{background:linear-gradient(135deg,#1f2937 0%,#f59e0b 45%,#f97316 100%)}
    .yh-gradient{background:linear-gradient(135deg,#0ea5e9 0%,#2563eb 55%,#38bdf8 100%)}
    .ld-gradient{background:linear-gradient(135deg,#0f766e 0%,#14b8a6 55%,#2dd4bf 100%)}
    .nx-card{border:1px solid var(--theme-card-border); box-shadow:var(--theme-card-shadow); border-radius:1.5rem; transition:box-shadow .3s ease,border-color .3s ease;}
    .nx-kpi{border:1px solid var(--theme-kpi-border); transition:border-color .3s ease;}
    .nx-kpi-btn{
      position:relative;
      border-radius:1.25rem;
      background:var(--theme-kpi-bg);
      color:#fff;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-shadow);
      transition:transform .25s ease, box-shadow .25s ease, filter .25s ease;
    }
    .nx-kpi-btn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 -18px 30px rgba(0,0,0,0.18);
      pointer-events:none;
    }
    .nx-kpi-btn:hover{
      transform:translateY(-3px);
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-hover-shadow);
    }
    .nx-kpi-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-active-shadow);
    }
    .nx-btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:.4rem;
      background:var(--theme-btn-bg);
      color:var(--theme-btn-text);
      border-radius:1rem;
      padding:.55rem 1.35rem;
      font-weight:600;
      border:1px solid var(--theme-btn-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn:hover{
      transform:translateY(-2px);
      filter:brightness(1.03);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-hover-shadow);
    }
    .nx-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-active-shadow);
    }
    .nx-btn-ghost{
      background:var(--theme-ghost-bg);
      color:var(--theme-ghost-text);
      border:1px solid var(--theme-ghost-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn-ghost:hover{
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-hover-shadow);
    }
    .nx-btn-ghost:active{
      transform:translateY(1px);
    }
    .nx-btn-sm{padding:.35rem .95rem; font-size:.8rem; border-radius:.9rem;}
  </style>
</head>
<body class="theme-nexo">
  <div id="root"></div>

  <!-- React 18 UMD + ReactDOM + Babel (para compilar JSX en el navegador) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    // Simulador de Préstamos – HTML portable (sin build, con CDN)
    const DEFAULT_EXCHANGE_RATES = {
      USD: 1,
      ARS: 1000,
      EUR: 0.92,
      GBP: 0.79,
      CAD: 1.36,
      AUD: 1.53,
      CHF: 0.89,
      JPY: 157,
      BRL: 5.0,
      MXN: 17.2,
    };

    const SUPPORTED_CURRENCIES = [
      { code: "USD", label: "USD — Dólar estadounidense" },
      { code: "ARS", label: "ARS — Peso argentino" },
      { code: "EUR", label: "EUR — Euro" },
      { code: "GBP", label: "GBP — Libra esterlina" },
      { code: "CAD", label: "CAD — Dólar canadiense" },
      { code: "AUD", label: "AUD — Dólar australiano" },
      { code: "CHF", label: "CHF — Franco suizo" },
      { code: "JPY", label: "JPY — Yen japonés" },
      { code: "BRL", label: "BRL — Real brasileño" },
      { code: "MXN", label: "MXN — Peso mexicano" },
    ];
    const { useState, useEffect, useMemo, useRef } = React;

    const LIVE_REFRESH_SECONDS = 5;

    const PLATFORM_CONFIGS = {
      nexo: {
        id: "nexo",
        name: "Nexo",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        classes: {
          header: "nx-gradient",
          accent: "text-blue-100/90",
          body: "theme-nexo",
          focusRing: "focus:ring-blue-700",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          NEXO: "nexo",
          USDT: "tether",
          USDC: "usd-coin",
          ADA: "cardano",
          ALGO: "algorand",
          XRP: "ripple",
          BNB: "binancecoin",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.50,
          ETH: 0.50,
          NEXO: 0.15,
          XRP: 0.30,
          BNB: 0.30,
          USDC: 0.50,
          USDT: 0.50,
          ADA: 0.50,
          ALGO: 0.30,
          SOL: 0.30,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.07,
          USDC: 0.12,
          USDT: 0.12,
          NEXO: 0.04,
          XRP: 0.07,
          BNB: 0.07,
          SOL: 0.07,
          ADA: 0.02,
          ALGO: 0.02,
        },
        policies: {
          targetLtv: 0.20,
          marginCallLtv: 0.70,
          autoRepayLtv: 0.8333333333,
          minBalancePerks: 5000,
          defaultLtv: 0.25,
        },
        apr: {
          base: 0.189,
          standard: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.139,
            Platinum: 0.109,
          },
          discounted: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.059,
            Platinum: 0.029,
          },
          earlyRuleDays: 45,
          earlyAPR: 0.189,
          lowCostEligibleTiers: ["Gold", "Platinum"],
          baseTier: "Base",
        },
        loyalty: {
          tokenTicker: "NEXO",
          baseLabel: "Base",
          belowMinimumLabel: "Sin perks",
          tierThresholds: [
            { label: "Platinum", minRatio: 0.10 },
            { label: "Gold", minRatio: 0.05 },
            { label: "Silver", minRatio: 0.01 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (oficial)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Loyalty Tier",
          ratioLabel: "ratio NEXO",
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 7, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 15000,
          repayInDays: 120,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 8, price: 2100, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 25000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 6000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "USD Coin", ticker: "USDC", qty: 4000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 5000, price: 0.38, priceAuto: false, useAsCollateral: false },
            { id: 7, name: "Algorand", ticker: "ALGO", qty: 8000, price: 0.15, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "nexo_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Nexo.",
        },
      },
      binance: {
        id: "binance",
        name: "Binance",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        classes: {
          header: "bn-gradient",
          accent: "text-amber-100/90",
          body: "theme-binance",
          focusRing: "focus:ring-amber-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          BNB: "binancecoin",
          USDT: "tether",
          USDC: "usd-coin",
          BUSD: "binance-usd",
          ADA: "cardano",
          XRP: "ripple",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.65,
          ETH: 0.60,
          BNB: 0.65,
          USDT: 0.80,
          USDC: 0.80,
          BUSD: 0.85,
          ADA: 0.45,
          XRP: 0.50,
          SOL: 0.50,
        },
        earnAprTop: {
          BTC: 0.03,
          ETH: 0.03,
          BNB: 0.05,
          USDT: 0.06,
          USDC: 0.06,
          BUSD: 0.06,
          ADA: 0.02,
          XRP: 0.02,
          SOL: 0.03,
        },
        policies: {
          targetLtv: 0.75,
          marginCallLtv: 0.85,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.18,
          standard: {
            "Estándar": 0.18,
            "VIP 1": 0.16,
            "VIP 2": 0.14,
            "VIP 3": 0.12,
          },
          discounted: {
            "Estándar": 0.18,
            "VIP 1": 0.15,
            "VIP 2": 0.12,
            "VIP 3": 0.10,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.18,
          lowCostEligibleTiers: ["VIP 2", "VIP 3"],
          baseTier: "Estándar",
        },
        loyalty: {
          tokenTicker: "BNB",
          baseLabel: "Estándar",
          belowMinimumLabel: "Estándar",
          tierThresholds: [
            { label: "VIP 3", minRatio: 0.05 },
            { label: "VIP 2", minRatio: 0.03 },
            { label: "VIP 1", minRatio: 0.01 },
          ],
          models: [
            { id: "vsTotal", label: "vs total (BNB holdings)" },
          ],
          kpiLabel: "Nivel VIP",
          ratioLabel: "ratio BNB",
        },
        ltvHealth: {
          zones: [
            { label: "Saludable", max: 0.75, color: "#22c55e", legend: "0-75%", tone: "ok" },
            { label: "Riesgo medio", max: 0.85, color: "#f97316", legend: "75-85%", tone: "warn" },
            { label: "Alto riesgo", max: 1, color: "#ef4444", legend: "≥85%", tone: "danger" },
          ],
          markers: [
            { pct: 0.85, label: "Margin call" },
            { pct: 0.90, label: "Auto-liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "BNB", ticker: "BNB", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "BUSD", ticker: "BUSD", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 8, name: "XRP", ticker: "XRP", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsTotal",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
          binanceCollateralDelta: 0,
          binanceRepaySim: 0,
        },
        previewSnapshot: {
          loanAmount: 12000,
          repayInDays: 90,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            loyaltyModel: "vsTotal",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.8, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 6, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "BNB", ticker: "BNB", qty: 150, price: 230, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 2000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "BUSD", ticker: "BUSD", qty: 1000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 4000, price: 0.4, priceAuto: false, useAsCollateral: false },
            { id: 7, name: "XRP", ticker: "XRP", qty: 5000, price: 0.5, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "binance_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Binance.",
        },
      },
      youhodler: {
        id: "youhodler",
        name: "YouHodler",
        tagline: "Multi-colateral y planes de tasas basados en stablecoins.",
        classes: {
          header: "yh-gradient",
          accent: "text-sky-100/90",
          body: "theme-youhodler",
          focusRing: "focus:ring-sky-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          LTC: "litecoin",
          SOL: "solana",
          ADA: "cardano",
          USDT: "tether",
          USDC: "usd-coin",
        },
        ltvByTicker: {
          BTC: 0.90,
          ETH: 0.90,
          LTC: 0.85,
          SOL: 0.80,
          ADA: 0.75,
          USDT: 0.90,
          USDC: 0.90,
        },
        earnAprTop: {
          BTC: 0.05,
          ETH: 0.05,
          LTC: 0.04,
          SOL: 0.05,
          ADA: 0.03,
          USDT: 0.12,
          USDC: 0.12,
        },
        policies: {
          targetLtv: 0.70,
          marginCallLtv: 0.85,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.12,
          standard: {
            "Classic": 0.12,
            "Premium": 0.10,
            "VIP": 0.08,
          },
          discounted: {
            "Classic": 0.11,
            "Premium": 0.09,
            "VIP": 0.07,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.12,
          lowCostEligibleTiers: ["Premium", "VIP"],
          baseTier: "Classic",
        },
        loyalty: {
          tokenTicker: "USDT",
          baseLabel: "Classic",
          belowMinimumLabel: "Classic",
          tierThresholds: [
            { label: "VIP", minRatio: 0.50 },
            { label: "Premium", minRatio: 0.25 },
          ],
          models: [
            { id: "vsTotal", label: "vs total (stablecoins)" },
          ],
          kpiLabel: "Plan activo",
          ratioLabel: "ratio stablecoins",
        },
        ltvHealth: {
          zones: [
            { label: "Seguro", max: 0.7, color: "#38bdf8", legend: "≤70%", tone: "ok" },
            { label: "Vigilar", max: 0.85, color: "#f97316", legend: "70-85%", tone: "warn" },
            { label: "Crítico", max: 1, color: "#ef4444", legend: "≥85%", tone: "danger" },
          ],
          markers: [
            { pct: 0.70, label: "Nivel óptimo" },
            { pct: 0.85, label: "Margin call" },
            { pct: 0.9, label: "Auto-liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "Litecoin", ticker: "LTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Solana", ticker: "SOL", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsTotal",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 18000,
          repayInDays: 75,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, EUR: 0.94 },
            loyaltyModel: "vsTotal",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.9, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 10, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "Tether", ticker: "USDT", qty: 20000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 15000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "Litecoin", ticker: "LTC", qty: 300, price: 65, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Solana", ticker: "SOL", qty: 400, price: 55, priceAuto: false, useAsCollateral: true },
            { id: 7, name: "Cardano", ticker: "ADA", qty: 6000, price: 0.38, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "youhodler_dashboard",
        disclaimers: {
          finePrint: "* Tasas aproximadas según planes Classic/Premium/VIP publicados por YouHodler (referencial).",
        },
      },
      ledn: {
        id: "ledn",
        name: "Ledn",
        tagline: "Créditos sobre BTC/USDC con métricas conservadoras y B2B.",
        classes: {
          header: "ld-gradient",
          accent: "text-teal-100/90",
          body: "theme-ledn",
          focusRing: "focus:ring-teal-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          WBTC: "wrapped-bitcoin",
          USDC: "usd-coin",
          USDT: "tether",
          LTC: "litecoin",
        },
        ltvByTicker: {
          BTC: 0.70,
          ETH: 0.65,
          WBTC: 0.70,
          USDC: 0.90,
          USDT: 0.85,
          LTC: 0.60,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.06,
          USDC: 0.07,
          USDT: 0.07,
          WBTC: 0.06,
          LTC: 0.04,
        },
        policies: {
          targetLtv: 0.55,
          marginCallLtv: 0.75,
          autoRepayLtv: 0.85,
          minBalancePerks: 1000,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.119,
          standard: {
            "Standard": 0.119,
            "Silver": 0.109,
            "Gold": 0.089,
          },
          discounted: {
            "Standard": 0.109,
            "Silver": 0.099,
            "Gold": 0.079,
          },
          earlyRuleDays: 60,
          earlyAPR: 0.119,
          lowCostEligibleTiers: ["Gold"],
          baseTier: "Standard",
        },
        loyalty: {
          tokenTicker: "BTC",
          baseLabel: "Standard",
          belowMinimumLabel: "Standard",
          tierThresholds: [
            { label: "Gold", minRatio: 0.50 },
            { label: "Silver", minRatio: 0.30 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (BTC dominante)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Plan de tasa",
          ratioLabel: "ratio BTC",
        },
        ltvHealth: {
          zones: [
            { label: "Conservador", max: 0.55, color: "#2dd4bf", legend: "≤55%", tone: "ok" },
            { label: "Observación", max: 0.75, color: "#fbbf24", legend: "55-75%", tone: "warn" },
            { label: "Crítico", max: 1, color: "#ef4444", legend: "≥75%", tone: "danger" },
          ],
          markers: [
            { pct: 0.55, label: "Zona Ledn" },
            { pct: 0.75, label: "Margin call" },
            { pct: 0.85, label: "Liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "Wrapped BTC", ticker: "WBTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Litecoin", ticker: "LTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 9000,
          repayInDays: 150,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, CAD: 1.34 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 1.2, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Wrapped BTC", ticker: "WBTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "USD Coin", ticker: "USDC", qty: 15000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 5000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "Ethereum", ticker: "ETH", qty: 4, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Litecoin", ticker: "LTC", qty: 600, price: 65, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "ledn_dashboard",
        disclaimers: {
          finePrint: "* Tasas Ledn orientativas basadas en publicaciones públicas (pueden cambiar sin previo aviso).",
        },
      },
    };

    const PLATFORM_EXPANSION_CANDIDATES = [
      {
        id: "youhodler",
        name: "YouHodler",
        segment: "CeFi Europa",
        region: "UE / LatAm",
        focus: "Planes escalonados con stablecoins y Turbocharge.",
        highlights: [
          "LTV hasta 90% en USDT/USDC",
          "Bundles de Earn + préstamos para carry trade",
          "Integración con Turbocharge (loop automático)",
        ],
      },
      {
        id: "ledn",
        name: "Ledn",
        segment: "CeFi Canadá",
        region: "Norteamérica / LatAm",
        focus: "Enfoque regulado y productos institucionales.",
        highlights: [
          "Préstamos B2B con auditorías de reservas",
          "Programas de ahorro en BTC y USDC",
          "Requisitos KYC/AML estrictos (compliance)",
        ],
      },
      {
        id: "coinloan",
        name: "CoinLoan",
        segment: "CeFi Báltico",
        region: "UE",
        focus: "Préstamos flexibles con tasas personalizadas por token.",
        highlights: [
          "Interfaz modular para vaults y préstamos",
          "Earn escalonado en activos long tail",
          "Marketplace interno para ajustar APR de prestatarios",
        ],
      },
      {
        id: "matrixport",
        name: "Matrixport",
        segment: "Prime Services",
        region: "Asia / Europa",
        focus: "Servicios institucionales con estrategias estructuradas.",
        highlights: [
          "Préstamos con margen por bloques (term loans)",
          "Productos dual-currency y smart yield",
          "API institucional y riesgo compartimentado",
        ],
      },
      {
        id: "crypto_com",
        name: "Crypto.com Lending",
        segment: "Retail exchange",
        region: "Global",
        focus: "Integración con app móvil y tarjeta Visa.",
        highlights: [
          "APR ligado al stake de CRO",
          "Liberación parcial de colateral desde la app",
          "Earn flexible sincronizado con el exchange",
        ],
      },
    ];

    const FEATURE_IMPROVEMENT_TASKS = {
      common: [
        {
          id: "scenario-engine",
          title: "Motor de escenarios de estrés",
          description: "Permitir shocks de precio (%) o volatilidad intradía y graficar cómo evolucionan LTV, margen y liquidaciones.",
        },
        {
          id: "alerting",
          title: "Alertas multi-canal",
          description: "Configurar umbrales de LTV/ratio que disparen alertas por email, Telegram o webhook para reaccionar antes de margin call.",
        },
        {
          id: "benchmarking",
          title: "Benchmark CeFi vs DeFi",
          description: "Comparar automáticamente las tasas del simulador con protocolos DeFi (Aave, Spark) para detectar oportunidades de arbitraje.",
        },
        {
          id: "cashflow-planning",
          title: "Planificador de cashflow",
          description: "Agregar calendario de pagos parciales, rollovers y cálculo de costo efectivo mensual (CEM) por escenario.",
        },
      ],
      byPlatform: {
        nexo: [
          {
            id: "nexo-booster",
            title: "Simular Booster & convert",
            description: "Incluir loops de crédito + compra automática de cripto para ver impacto de Booster y conversión instantánea.",
          },
          {
            id: "nexo-insurance",
            title: "Visor de seguro Nexo",
            description: "Agregar panel que estime cobertura de seguro y auditorías (Armanino) frente a colateral disponible.",
          },
        ],
        binance: [
          {
            id: "binance-vip",
            title: "Modelo VIP dinámico",
            description: "Calcular automáticamente upgrade de nivel VIP considerando volumen spot/futuros y mostrar APR objetivo.",
          },
          {
            id: "binance-crossmargin",
            title: "Cruce con Cross-Margin",
            description: "Permitir importar posiciones de margin/futuros para medir riesgo agregado y requirements de colateral.",
          },
        ],
        youhodler: [
          {
            id: "yh-turbo",
            title: "Turbocharge loops",
            description: "Simular iteraciones Turbocharge (auto-loop) para ver cuántas rondas maximizan el capital sin liquidar.",
          },
          {
            id: "yh-stable-buckets",
            title: "Buckets de stablecoins",
            description: "Segregar stablecoins por plan (Classic/Premium/VIP) y optimizar qué cantidad conviene bloquear para subir de nivel.",
          },
        ],
        ledn: [
          {
            id: "ledn-b2b",
            title: "Modo institución",
            description: "Añadir campos de reporting (auditorías, segregación de cuentas) y métricas de reservas para clientes corporativos.",
          },
          {
            id: "ledn-proof",
            title: "Prueba de reservas",
            description: "Integrar feed de pruebas de reservas trimestrales y alertar si cambian los índices de cobertura BTC/USDC.",
          },
        ],
      },
    };

    const PLATFORM_THEME_CLASSES = Array.from(new Set([
      "theme-nexo",
      ...Object.values(PLATFORM_CONFIGS).map((cfg) => cfg?.classes?.body).filter(Boolean),
    ]));

    const PLATFORM_IDS = Object.keys(PLATFORM_CONFIGS);
    const GLOBAL_COINGECKO_IDS = Object.values(PLATFORM_CONFIGS).reduce((acc, cfg) => ({ ...acc, ...(cfg.coingeckoIds || {}) }), {});

    const fmt = (n, currency = "USD", show = true) =>
      show ? n.toLocaleString(undefined, { style: "currency", currency }) : n.toLocaleString();

    const todayISO = () => new Date().toISOString().slice(0, 10);

    function SimuladorPrestamos() {
      const initialPlatformId = PLATFORM_IDS[0];
      const [platformId, setPlatformId] = useState(() => {
        if (typeof window === 'undefined') return initialPlatformId;
        try {
          const stored = localStorage.getItem('spm_platform');
          return PLATFORM_IDS.includes(stored) ? stored : initialPlatformId;
        } catch {
          return initialPlatformId;
        }
      });

      const platform = PLATFORM_CONFIGS[platformId] ?? PLATFORM_CONFIGS[initialPlatformId];
      const {
        id,
        name: platformName,
        tagline,
        classes = {},
        coingeckoIds = {},
        ltvByTicker = {},
        earnAprTop = {},
        policies = {},
        apr: aprConfig = {},
        loyalty,
        ltvHealth,
        previewSnapshot,
        defaultAssets: platformDefaultAssets = [],
        defaultParams: platformDefaultParams = {},
        exportPrefix = "simulador_prestamos",
        disclaimers = {},
      } = platform;

      const themeClass = classes.body || "theme-nexo";
      const focusRingClass = classes.focusRing || "focus:ring-blue-700";
      const headerClass = classes.header || "nx-gradient";
      const accentClass = classes.accent || "text-blue-100/90";
      const platformTagline = tagline || "Datos en vivo y cálculos de Earn (flexible) y crédito.";
      const targetLtv = policies.targetLtv ?? 0.20;
      const marginCallLtv = policies.marginCallLtv ?? 0.70;
      const autoRepayLtv = policies.autoRepayLtv ?? 0.85;
      const minBalancePerks = policies.minBalancePerks ?? 0;
      const defaultLtv = policies.defaultLtv ?? 0.25;
      const candidatePlatforms = useMemo(
        () => PLATFORM_EXPANSION_CANDIDATES.map((candidate) => ({
          ...candidate,
          integrated: PLATFORM_IDS.includes(candidate.id),
          isCurrent: candidate.id === platformId,
        })),
        [platformId]
      );
      const improvementIdeas = useMemo(() => {
        const base = FEATURE_IMPROVEMENT_TASKS.common || [];
        const extras = (FEATURE_IMPROVEMENT_TASKS.byPlatform || {})[platformId] || [];
        return [...base, ...extras];
      }, [platformId]);
      const loyaltyModels = loyalty?.models ?? [];
      const loyaltyModelFallback = platformDefaultParams?.loyaltyModel ?? loyaltyModels[0]?.id ?? "vsRest";
      const isBinance = id === "binance";
      const clamp01 = (v) => Math.max(0, Math.min(1, Number(v) || 0));
      const toPct = (value, digits = 0) => Number.isFinite(value) ? `${(value * 100).toFixed(digits)}%` : "—";
      const ltvGaugeZones = React.useMemo(() => {
        if (ltvHealth?.zones?.length) {
          return ltvHealth.zones
            .map((zone, idx) => ({
              label: zone.label ?? `Zona ${idx + 1}`,
              max: clamp01(zone.max),
              color: zone.color ?? (idx === 0 ? "#22c55e" : idx === 1 ? "#facc15" : "#ef4444"),
              legend: zone.legend ?? `≤${Math.round(clamp01(zone.max) * 100)}%`,
              tone: zone.tone ?? (idx === 0 ? "ok" : idx === (ltvHealth.zones.length - 1) ? "danger" : "warn"),
            }))
            .filter((zone, idx, arr) => zone.max > 0 && idx === arr.findIndex((z) => z.max === zone.max))
            .sort((a, b) => a.max - b.max);
        }
        return [
          { label: "Óptimo", max: clamp01(targetLtv), color: "#22c55e", legend: `≤${Math.round(clamp01(targetLtv) * 100)}%`, tone: "ok" },
          { label: "Estable", max: clamp01(marginCallLtv), color: "#facc15", legend: `≤${Math.round(clamp01(marginCallLtv) * 100)}%`, tone: "warn" },
          { label: "A riesgo", max: clamp01(autoRepayLtv), color: "#fb923c", legend: `≤${Math.round(clamp01(autoRepayLtv) * 100)}%`, tone: "danger" },
          { label: "Crítico", max: 1, color: "#ef4444", legend: "> límite", tone: "danger" },
        ];
      }, [ltvHealth, targetLtv, marginCallLtv, autoRepayLtv]);
      const ltvHealthyThreshold = clamp01(ltvGaugeZones[0]?.max ?? targetLtv);
      const ltvWarnThreshold = clamp01((ltvGaugeZones[1]?.max ?? marginCallLtv) || ltvHealthyThreshold);
      const ltvGaugeMarkers = React.useMemo(() => {
        const markersSource = ltvHealth?.markers?.length ? ltvHealth.markers : [
          { pct: targetLtv, label: `Objetivo ${Math.round(clamp01(targetLtv) * 100)}%` },
          { pct: marginCallLtv, label: `Margin call ${Math.round(clamp01(marginCallLtv) * 100)}%` },
          { pct: autoRepayLtv, label: `Auto-repay ${Math.round(clamp01(autoRepayLtv) * 100)}%` },
        ];
        return markersSource
          .map((marker, idx) => ({ pct: clamp01(marker.pct), label: marker.label ?? `Nivel ${idx + 1}` }))
          .filter((marker, idx, arr) => marker.pct > 0 && idx === arr.findIndex((m) => m.pct === marker.pct));
      }, [ltvHealth, targetLtv, marginCallLtv, autoRepayLtv]);

      const sanitizeTicker = (t) => (t || "").toUpperCase();
      const toNumber = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : 0;
      };
      const sanitizeAssets = (list) => {
        return (Array.isArray(list) ? list : []).map((item, idx) => {
          const ticker = sanitizeTicker(item.ticker);
          return {
            id: item.id ?? idx + 1,
            name: item.name ?? `Activo ${idx + 1}`,
            ticker,
            qty: toNumber(item.qty),
            price: toNumber(item.price),
            priceAuto: item.priceAuto === false ? false : true,
            useAsCollateral: item.useAsCollateral === false ? false : true,
            ltv: ltvByTicker[ticker] ?? item.ltv ?? defaultLtv,
          };
        });
      };
      const sanitizeCashflowPlan = (rawPlan, fallbackRepay = null) => {
        const base = {
          payments: [],
          earns: [],
          manual: [],
          scenarioShocks: { base: 0, bear: -0.25, bull: 0.15 },
          activeScenario: 'base',
        };
        const safe = { ...base, ...(rawPlan || {}) };
        const ensureISO = (value, fallback) => {
          if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
          return fallback;
        };
        const toPos = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? Math.max(0, n) : 0;
        };
        const payments = Array.isArray(safe.payments)
          ? safe.payments.map((item, idx) => ({
              id: item.id ?? idx + 1,
              label: item.label || `Pago ${idx + 1}`,
              date: ensureISO(item.date, fallbackRepay || todayISO()),
              principal: toPos(item.principal),
              interest: toPos(item.interest),
            }))
          : [];
        const earns = Array.isArray(safe.earns)
          ? safe.earns.map((item, idx) => {
              const freq = ['daily', 'weekly', 'monthly'].includes(item.frequency) ? item.frequency : 'monthly';
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Flujo ${idx + 1}`,
                platform: item.platform || '',
                token: item.token || '',
                amount: toPos(item.amount),
                frequency: freq,
                startDate: ensureISO(item.startDate, todayISO()),
                endDate: ensureISO(item.endDate, fallbackRepay || ensureISO(item.startDate, todayISO())),
                defiLlamaId: typeof item.defiLlamaId === 'string' ? item.defiLlamaId : '',
              };
            })
          : [];
        const manual = Array.isArray(safe.manual)
          ? safe.manual.map((item, idx) => {
              const direction = item.direction === 'inflow' ? 'inflow' : 'outflow';
              const collateralImpact = ['increase', 'decrease', 'none'].includes(item.collateralImpact)
                ? item.collateralImpact
                : 'none';
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Evento ${idx + 1}`,
                date: ensureISO(item.date, todayISO()),
                amount: toPos(item.amount),
                direction,
                collateralImpact,
              };
            })
          : [];
        const scenarioKeys = Object.keys(base.scenarioShocks);
        const scenarioShocks = { ...base.scenarioShocks };
        Object.keys(safe.scenarioShocks || {}).forEach((key) => {
          const num = Number(safe.scenarioShocks[key]);
          if (Number.isFinite(num)) {
            scenarioShocks[key] = num;
            if (!scenarioKeys.includes(key)) scenarioKeys.push(key);
          }
        });
        const activeScenario = scenarioKeys.includes(safe.activeScenario) ? safe.activeScenario : 'base';
        return { payments, earns, manual, scenarioShocks, activeScenario };
      };
      const sanitizeBenchmarkConfig = (rawConfig) => {
        const base = {
          rateMatrix: [
            { id: 'loan-default', platform: 'Plataforma CeFi', product: 'Préstamo estándar', type: 'APR', value: 0.12 },
            { id: 'yield-default', platform: 'Rendimiento', product: 'Estrategia base', type: 'APY', value: 0.10 },
          ],
          strategies: [
            {
              id: 'strategy-1',
              label: 'Carry base',
              lenderRateId: 'loan-default',
              yieldRateId: 'yield-default',
              apr: 0.12,
              apy: 0.10,
              feesIn: 0,
              feesOut: 0,
              amountOverride: null,
              riskCeFiLender: true,
              riskDeFiYield: false,
              riskNewProtocol: false,
              defiLlamaId: '',
            },
          ],
        };
        const safe = { ...base, ...(rawConfig || {}) };
        const matrix = Array.isArray(safe.rateMatrix)
          ? safe.rateMatrix.map((item, idx) => ({
              id: item.id ?? `rate-${idx + 1}`,
              platform: item.platform || 'Plataforma',
              product: item.product || 'Producto',
              type: item.type === 'APY' ? 'APY' : 'APR',
              value: Number(item.value) || 0,
            }))
          : base.rateMatrix;
        const strategies = Array.isArray(safe.strategies)
          ? safe.strategies.map((item, idx) => ({
              id: item.id ?? `strategy-${idx + 1}`,
              label: item.label || `Estrategia ${idx + 1}`,
              lenderRateId: item.lenderRateId || matrix[0]?.id || 'loan-default',
              yieldRateId: item.yieldRateId || matrix[1]?.id || 'yield-default',
              apr: Number(item.apr) || 0,
              apy: Number(item.apy) || 0,
              feesIn: Number(item.feesIn) || 0,
              feesOut: Number(item.feesOut) || 0,
              amountOverride: item.amountOverride == null || item.amountOverride === '' ? null : Math.max(0, Number(item.amountOverride) || 0),
              riskCeFiLender: item.riskCeFiLender !== false,
              riskDeFiYield: item.riskDeFiYield === true,
              riskNewProtocol: item.riskNewProtocol === true,
              defiLlamaId: typeof item.defiLlamaId === 'string' ? item.defiLlamaId : '',
            }))
          : base.strategies;
        return { rateMatrix: matrix, strategies };
      };
      const storageKeys = useMemo(() => ({
        assets: `spm_${id}_assets_v1`,
        params: `spm_${id}_params_v2`,
        cashflow: `spm_${id}_cashflow_v1`,
        benchmark: `spm_${id}_benchmark_v1`,
      }), [id]);
      const baseAssets = useMemo(() => sanitizeAssets(platformDefaultAssets), [platformDefaultAssets, ltvByTicker, defaultLtv]);
      const baseExchangeRates = useMemo(() => {
        const merged = { ...DEFAULT_EXCHANGE_RATES, ...(platformDefaultParams?.exchangeRates || {}) };
        merged.USD = 1;
        return merged;
      }, [platformDefaultParams]);
      const sanitizeExchangeRates = (rawRates, legacyUsdToArs) => {
        const next = { ...baseExchangeRates };
        const source = rawRates && typeof rawRates === 'object' ? rawRates : {};
        const legacy = Number.isFinite(legacyUsdToArs) ? legacyUsdToArs : null;
        for (const { code } of SUPPORTED_CURRENCIES) {
          if (code === 'USD') { next.USD = 1; continue; }
          const candidate = source[code];
          const value = Number(candidate);
          if (Number.isFinite(value) && value > 0) {
            next[code] = value;
          } else if (code === 'ARS' && legacy != null && legacy > 0) {
            next[code] = legacy;
          } else if (!Number.isFinite(Number(next[code])) || next[code] <= 0) {
            next[code] = DEFAULT_EXCHANGE_RATES[code] ?? 1;
          }
        }
        next.USD = 1;
        return next;
      };
      const baseParams = useMemo(() => {
        const fallback = {
          exchangeRates: { ...baseExchangeRates },
          loyaltyModel: loyaltyModelFallback,
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
          binanceCollateralDelta: 0,
          binanceRepaySim: 0,
        };
        const merged = { ...fallback, ...platformDefaultParams };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.exchangeRates = sanitizeExchangeRates(merged.exchangeRates, merged.usdToArs);
        return merged;
      }, [platformDefaultParams, loyaltyModelFallback, loyaltyModels, baseExchangeRates]);
      const baseCashflowPlan = useMemo(
        () => sanitizeCashflowPlan(previewSnapshot?.cashflow, (previewSnapshot?.repayDate || previewSnapshot?.cashflow?.payments?.[0]?.date || todayISO())),
        [previewSnapshot]
      );
      const baseBenchmarkConfig = useMemo(
        () => sanitizeBenchmarkConfig(previewSnapshot?.benchmark),
        [previewSnapshot]
      );
      const sanitizeParams = (raw) => {
        const merged = { ...baseParams, ...(raw || {}) };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.binanceCollateralDelta = Number(merged.binanceCollateralDelta) || 0;
        merged.binanceRepaySim = Number(merged.binanceRepaySim) || 0;
        return merged;
      };

      const applyPreviewSnapshot = () => {
        if (!previewSnapshot) return;
        const {
          assets: previewAssets,
          params: previewParams,
          loanAmount: previewLoanAmount,
          repayDate: previewRepayDate,
          repayInDays,
          currency: previewCurrency,
        } = previewSnapshot;

        if (Array.isArray(previewAssets)) {
          setAssets(sanitizeAssets(previewAssets));
        }

        if (previewParams) {
          setParams(sanitizeParams(previewParams));
        }

        if (previewSnapshot?.cashflow) {
          setCashflowPlan(sanitizeCashflowPlan(previewSnapshot.cashflow, previewSnapshot.repayDate || previewSnapshot.cashflow?.payments?.[0]?.date || repayDate));
        }

        if (previewSnapshot?.benchmark) {
          setBenchmarkConfig(sanitizeBenchmarkConfig(previewSnapshot.benchmark));
        }

        if (Number.isFinite(previewLoanAmount)) {
          setLoanAmount(Number(previewLoanAmount) || 0);
        }

        if (typeof previewCurrency === 'string' && previewCurrency) {
          setSelectedCurrency(previewCurrency);
        } else if (typeof previewSnapshot?.showArs === 'boolean') {
          setSelectedCurrency(previewSnapshot.showArs ? 'ARS' : 'USD');
        }

        if (previewRepayDate) {
          setRepayDate(previewRepayDate);
        } else if (Number.isFinite(repayInDays)) {
          const d = new Date();
          d.setDate(d.getDate() + Math.max(0, Math.round(repayInDays)));
          setRepayDate(d.toISOString().slice(0, 10));
        }
      };

      const [assets, setAssets] = useState(() => {
        if (typeof window === 'undefined') return baseAssets;
        try {
          const saved = localStorage.getItem(storageKeys.assets);
          if (saved) {
            return sanitizeAssets(JSON.parse(saved));
          }
        } catch {}
        return baseAssets;
      });

      const [params, setParams] = useState(() => {
        if (typeof window === 'undefined') return baseParams;
        try {
          const saved = localStorage.getItem(storageKeys.params);
          if (saved) {
            return sanitizeParams(JSON.parse(saved));
          }
        } catch {}
        return baseParams;
      });

      const [cashflowPlan, setCashflowPlan] = useState(() => {
        if (typeof window === 'undefined') return baseCashflowPlan;
        try {
          const saved = localStorage.getItem(storageKeys.cashflow);
          if (saved) {
            return sanitizeCashflowPlan(JSON.parse(saved), previewSnapshot?.repayDate || todayISO());
          }
        } catch {}
        return baseCashflowPlan;
      });

      const [benchmarkConfig, setBenchmarkConfig] = useState(() => {
        if (typeof window === 'undefined') return baseBenchmarkConfig;
        try {
          const saved = localStorage.getItem(storageKeys.benchmark);
          if (saved) {
            return sanitizeBenchmarkConfig(JSON.parse(saved));
          }
        } catch {}
        return baseBenchmarkConfig;
      });

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem('spm_platform', platformId); } catch {}
      }, [platformId]);

      useEffect(() => {
        setAssets(() => {
          if (typeof window === 'undefined') return baseAssets;
          try {
            const saved = localStorage.getItem(storageKeys.assets);
            if (saved) {
              return sanitizeAssets(JSON.parse(saved));
            }
          } catch {}
          return baseAssets;
        });
      }, [storageKeys.assets, baseAssets]);

      useEffect(() => {
        setParams(() => {
          if (typeof window === 'undefined') return baseParams;
          try {
            const saved = localStorage.getItem(storageKeys.params);
            if (saved) {
              return sanitizeParams(JSON.parse(saved));
            }
          } catch {}
          return baseParams;
        });
      }, [storageKeys.params, baseParams]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem(storageKeys.assets, JSON.stringify(assets)); } catch {}
      }, [assets, storageKeys.assets]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem(storageKeys.params, JSON.stringify(params)); } catch {}
      }, [params, storageKeys.params]);

      const [loanAmount, setLoanAmount] = useState(0);
      const [repayDate, setRepayDate] = useState(() => {
        const d = new Date(); d.setDate(d.getDate() + 60); return d.toISOString().slice(0, 10);
      });
      const [selectedCurrency, setSelectedCurrency] = useState(() => {
        if (previewSnapshot?.currency) return previewSnapshot.currency;
        if (typeof previewSnapshot?.showArs === 'boolean') {
          return previewSnapshot.showArs ? 'ARS' : 'USD';
        }
        return 'USD';
      });
      const [lastPriceTs, setLastPriceTs] = useState(null);
      const [liveError, setLiveError] = useState(null);

      const updateCashflowPlan = (updater) => {
        setCashflowPlan((prev) => {
          const base = typeof updater === 'function' ? updater(prev) : { ...prev, ...(updater || {}) };
          return sanitizeCashflowPlan(base, repayDate);
        });
      };

      const updateBenchmarkConfig = (updater) => {
        setBenchmarkConfig((prev) => {
          const base = typeof updater === 'function' ? updater(prev) : { ...prev, ...(updater || {}) };
          return sanitizeBenchmarkConfig(base);
        });
      };

      useEffect(() => {
        setCashflowPlan(() => {
          if (typeof window === 'undefined') return baseCashflowPlan;
          try {
            const saved = localStorage.getItem(storageKeys.cashflow);
            if (saved) {
              return sanitizeCashflowPlan(JSON.parse(saved), repayDate);
            }
          } catch {}
          return baseCashflowPlan;
        });
      }, [storageKeys.cashflow, baseCashflowPlan, repayDate]);

      useEffect(() => {
        setBenchmarkConfig(() => {
          if (typeof window === 'undefined') return baseBenchmarkConfig;
          try {
            const saved = localStorage.getItem(storageKeys.benchmark);
            if (saved) {
              return sanitizeBenchmarkConfig(JSON.parse(saved));
            }
          } catch {}
          return baseBenchmarkConfig;
        });
      }, [storageKeys.benchmark, baseBenchmarkConfig]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem(storageKeys.cashflow, JSON.stringify(cashflowPlan)); } catch {}
      }, [cashflowPlan, storageKeys.cashflow]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem(storageKeys.benchmark, JSON.stringify(benchmarkConfig)); } catch {}
      }, [benchmarkConfig, storageKeys.benchmark]);

      const currency = selectedCurrency;
      const rate = params.exchangeRates?.[currency] ?? 1;
      const pct = (x) => (x == null ? "—" : (x * 100).toFixed(1) + "%");

      const tickerToId = (ticker) => {
        const key = sanitizeTicker(ticker);
        return coingeckoIds[key] ?? GLOBAL_COINGECKO_IDS[key];
      };

      const tickersKey = useMemo(() => assets.filter(a=>a.priceAuto!==false).map(a=>sanitizeTicker(a.ticker)).sort().join(','), [assets]);

      const inFlight = useRef(false);
      const importInputRef = useRef(null);
      async function fetchLivePricesNow() {
        try {
          if (inFlight.current) return; inFlight.current = true;
          setLiveError(null);
          if (!params.liveQuotes) { inFlight.current = false; return; }
          const ids = Array.from(new Set(assets.filter(a => a.priceAuto !== false).map(a => tickerToId(a.ticker)).filter(Boolean)));
          if (!ids.length) { setLastPriceTs(Date.now()); inFlight.current = false; return; }
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
        finally { inFlight.current = false; }
      }

      async function fetchPricesForTickers(tickers = []) {
        try {
          if (!params.liveQuotes) return;
          const ids = Array.from(new Set(tickers.map(tickerToId).filter(Boolean)));
          if (!ids.length) return;
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
      }

      useEffect(() => {
        if (!params.liveQuotes) return;
        fetchLivePricesNow();
        const sec = Math.max(LIVE_REFRESH_SECONDS, Number(params.refreshSec || LIVE_REFRESH_SECONDS));
        const t = setInterval(fetchLivePricesNow, sec * 1000);
        return () => clearInterval(t);
      }, [params.liveQuotes, params.refreshSec, tickersKey]);

      const loyaltyTicker = loyalty?.tokenTicker ? sanitizeTicker(loyalty.tokenTicker) : null;

      const totals = useMemo(() => {
        const withValue = assets.map((a, idx) => {
          const ticker = sanitizeTicker(a.ticker);
          const qty = toNumber(a.qty);
          const price = toNumber(a.price);
          const value = qty * price;
          const ltv = ltvByTicker[ticker] ?? a.ltv ?? defaultLtv;
          return { ...a, ticker, qty, price, value, ltv, useAsCollateral: a.useAsCollateral !== false };
        });
        const total = withValue.reduce((acc, a) => acc + a.value, 0);
        const totalLoyalty = loyaltyTicker ? withValue.filter(a => a.ticker === loyaltyTicker).reduce((acc, a) => acc + a.value, 0) : 0;
        const rest = total - totalLoyalty;
        const ratioVsRest = rest > 0 ? (totalLoyalty / rest) : (totalLoyalty > 0 ? Number.POSITIVE_INFINITY : 0);
        const ratioVsTotal = total > 0 ? (totalLoyalty / total) : 0;
        const collaterals = withValue.filter(a => a.useAsCollateral);
        const totalCollateralValue = collaterals.reduce((acc, a) => acc + a.value, 0);
        const maxBorrow = collaterals.reduce((acc, a) => acc + a.value * ((ltvByTicker[a.ticker] ?? a.ltv ?? defaultLtv) || 0), 0);
        return { withValue, total, totalLoyalty, rest, ratioVsRest, ratioVsTotal, totalCollateralValue, maxBorrow };
      }, [assets, loyaltyTicker, ltvByTicker, defaultLtv]);

      const loyaltyModelActive = params.loyaltyModel ?? loyaltyModelFallback;

      const loyaltyTier = useMemo(() => {
        if (!loyalty) return aprConfig.baseTier ?? loyalty?.baseLabel ?? "—";
        if (totals.total < minBalancePerks) return loyalty.belowMinimumLabel ?? loyalty.baseLabel ?? "Sin perks";
        const ratioUsed = loyaltyModelActive === "vsTotal" ? totals.ratioVsTotal : totals.ratioVsRest;
        for (const tier of loyalty.tierThresholds ?? []) {
          if (ratioUsed >= tier.minRatio) return tier.label;
        }
        return loyalty.baseLabel ?? (aprConfig.baseTier ?? "Base");
      }, [loyalty, totals.total, minBalancePerks, loyaltyModelActive, totals.ratioVsTotal, totals.ratioVsRest, aprConfig.baseTier]);

      const aprStandardTable = aprConfig.standard ?? {};
      const aprDiscountTable = aprConfig.discounted ?? aprStandardTable;
      const aprBaseTier = aprConfig.baseTier ?? (loyalty?.baseLabel ?? "Base");
      const aprBase = aprConfig.base ?? aprStandardTable[aprBaseTier] ?? aprStandardTable[loyalty?.baseLabel] ?? 0.20;
      const lowCostEligibleTiers = aprConfig.lowCostEligibleTiers ?? loyalty?.lowCostEligibleTiers ?? [];
      const earlyRuleDays = aprConfig.earlyRuleDays ?? 45;
      const earlyAPR = aprConfig.earlyAPR ?? aprBase;

      const recommendedLoanAtTarget = useMemo(() => targetLtv * totals.totalCollateralValue, [targetLtv, totals.totalCollateralValue]);
      const capLowCost = useMemo(() => Math.min(recommendedLoanAtTarget, totals.maxBorrow), [recommendedLoanAtTarget, totals.maxBorrow]);
      const lowCostHeadroom = useMemo(() => Math.max(0, capLowCost - loanAmount), [capLowCost, loanAmount]);

      const chosenAPR = useMemo(() => {
        const table = loanAmount <= recommendedLoanAtTarget ? aprDiscountTable : aprStandardTable;
        const aprFromTier = table?.[loyaltyTier];
        if (typeof aprFromTier === 'number') return aprFromTier;
        if (aprBaseTier && typeof table?.[aprBaseTier] === 'number') return table[aprBaseTier];
        if (loyalty?.baseLabel && typeof table?.[loyalty.baseLabel] === 'number') return table[loyalty.baseLabel];
        return aprBase;
      }, [loanAmount, recommendedLoanAtTarget, aprDiscountTable, aprStandardTable, loyaltyTier, aprBaseTier, aprBase, loyalty?.baseLabel]);

      const daysUntilRepay = useMemo(() => {
        const a = new Date(); const b = new Date(repayDate);
        const diffMs = Math.max(0, b.getTime() - a.getTime());
        return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      }, [repayDate]);

      const interestCalc = useMemo(() => {
        const P = loanAmount; const d = daysUntilRepay; const r = chosenAPR;
        const earlyDays = Math.max(0, earlyRuleDays - d);
        const main = P * (Math.pow(1 + r / 365, d) - 1);
        const early = d < earlyRuleDays ? P * (Math.pow(1 + earlyAPR / 365, earlyDays) - 1) : 0;
        const total = main + early; return { main, early, total, repayTotal: P + total };
      }, [loanAmount, daysUntilRepay, chosenAPR, earlyRuleDays, earlyAPR]);

      const monthlyLoanCost = useMemo(() => loanAmount * (Math.pow(1 + chosenAPR / 365, 30) - 1), [loanAmount, chosenAPR]);

      const earnEligible = totals.total >= minBalancePerks && params.earnOptIn;
      const earnMonthly = useMemo(() => {
        if (!earnEligible) return 0;
        const days = 30;
        return totals.withValue.reduce((acc, a) => {
          if (!params.earnOnCollateral && a.useAsCollateral) return acc;
          const apr = earnAprTop[sanitizeTicker(a.ticker)] ?? 0;
          return acc + a.value * (Math.pow(1 + apr/365, days) - 1);
        }, 0);
      }, [earnEligible, params.earnOnCollateral, totals.withValue, earnAprTop]);

      const netMonthly = useMemo(() => earnMonthly - monthlyLoanCost, [earnMonthly, monthlyLoanCost]);

      const timeline = useMemo(() => {
        const totalDays = Math.max(1, daysUntilRepay);
        const steps = Math.max(4, Math.min(12, Math.ceil(totalDays / 20)));
        const arr = [];
        for (let i = 0; i <= steps; i++) {
          const day = (totalDays / steps) * i;
          const interest = loanAmount * (Math.pow(1 + chosenAPR / 365, day) - 1);
          let earn = 0;
          if (earnEligible) {
            earn = totals.withValue.reduce((acc, asset) => {
              if (!params.earnOnCollateral && asset.useAsCollateral) return acc;
              const apr = earnAprTop[sanitizeTicker(asset.ticker)] ?? 0;
              return acc + asset.value * (Math.pow(1 + apr / 365, day) - 1);
            }, 0);
          }
          const balance = Math.max(0, loanAmount + interest - earn);
          arr.push({ day, cost: interest, earn, balance });
        }
        return arr;
      }, [chosenAPR, daysUntilRepay, earnEligible, loanAmount, params.earnOnCollateral, totals.withValue, earnAprTop]);
      const totalEarnDuringPeriod = timeline.length ? timeline[timeline.length - 1].earn : 0;
      const netInterestPeriod = interestCalc.total - totalEarnDuringPeriod;
      const netAnnualRate = loanAmount > 0 && daysUntilRepay > 0 ? (Math.pow(1 + netInterestPeriod / loanAmount, 365 / daysUntilRepay) - 1) : 0;

      const cashflowDerived = useMemo(() =>
        computeCashflowProjections(cashflowPlan, {
          loanAmount,
          apr: chosenAPR,
          repayDate,
          totalCollateralValue: totals.totalCollateralValue,
          targetLtv,
          marginCallLtv,
          autoRepayLtv,
          scenarioShocks: cashflowPlan?.scenarioShocks,
        }),
      [cashflowPlan, loanAmount, chosenAPR, repayDate, totals.totalCollateralValue, targetLtv, marginCallLtv, autoRepayLtv]);

      const overallLTVIfBorrow = useMemo(() => (totals.totalCollateralValue > 0 ? loanAmount / totals.totalCollateralValue : 0), [loanAmount, totals.totalCollateralValue]);
      const ltvGaugeValue = Number.isFinite(cashflowDerived?.ltvForGauge) ? cashflowDerived.ltvForGauge : overallLTVIfBorrow;
      const ltvScenarioLabel = cashflowDerived?.scenarioLabel;
      const cashflowAlerts = cashflowDerived?.alerts ?? [];
      const ltvTone = ltvGaugeValue <= ltvHealthyThreshold ? "ok" : (ltvGaugeValue <= ltvWarnThreshold ? "warn" : "danger");
      const binanceCollateralDelta = Number(params.binanceCollateralDelta) || 0;
      const binanceRepaySim = Math.max(0, Number(params.binanceRepaySim) || 0);
      const binanceCollateralAfterAdjust = Math.max(0, totals.totalCollateralValue + binanceCollateralDelta);
      const binanceLoanAfterRepay = Math.max(0, loanAmount - binanceRepaySim);
      const binanceLtvAfterAdjust = binanceCollateralAfterAdjust > 0 ? binanceLoanAfterRepay / binanceCollateralAfterAdjust : 0;
      const binanceLtvTone = binanceLtvAfterAdjust <= ltvHealthyThreshold ? "ok" : (binanceLtvAfterAdjust <= ltvWarnThreshold ? "warn" : "danger");
      const binanceExtraCollateralNeeded = ltvHealthyThreshold > 0 ? Math.max(0, loanAmount / ltvHealthyThreshold - totals.totalCollateralValue) : 0;
      const binanceRepayNeeded = Math.max(0, loanAmount - totals.totalCollateralValue * ltvHealthyThreshold);
      const binanceBufferToCaution = Math.max(0, totals.totalCollateralValue * ltvWarnThreshold - loanAmount);
      const binanceCautionLabel = ltvWarnThreshold > ltvHealthyThreshold ? `${toPct(ltvHealthyThreshold, 0)} – ${toPct(ltvWarnThreshold, 0)}` : `>${toPct(ltvHealthyThreshold, 0)}`;
      const binanceHourlyInterest = loanAmount * (chosenAPR / 365 / 24);
      const binanceLiquidationValue = marginCallLtv > 0 ? loanAmount / marginCallLtv : 0;
      const binanceLiquidationBuffer = totals.totalCollateralValue - binanceLiquidationValue;
      const binanceAdjustedLiquidationValue = marginCallLtv > 0 ? binanceLoanAfterRepay / marginCallLtv : 0;
      const binanceAdjustedLiquidationBuffer = binanceCollateralAfterAdjust - binanceAdjustedLiquidationValue;

      const collateralBreakdown = useMemo(() => {
        const totalCollateral = totals.totalCollateralValue || 0;
        if (!(totalCollateral > 0)) return [];
        return totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.value > 0)
          .map((asset) => {
            const ticker = sanitizeTicker(asset.ticker);
            const policyLTV = ltvByTicker[ticker] ?? asset.ltv ?? defaultLtv;
            const maxBorrowForAsset = asset.value * policyLTV;
            const share = asset.value / totalCollateral;
            const allocatedLoan = loanAmount * share;
            const usageVsCap = maxBorrowForAsset > 0 ? allocatedLoan / maxBorrowForAsset : 0;
            let tone = "ok";
            if (usageVsCap > 0.85 || overallLTVIfBorrow >= autoRepayLtv) {
              tone = "danger";
            } else if (usageVsCap > 0.6 || overallLTVIfBorrow >= marginCallLtv) {
              tone = "warn";
            }
            return {
              id: asset.id,
              name: asset.name || ticker || `Activo ${asset.id}`,
              ticker,
              value: asset.value,
              share,
              policyLTV,
              policyPct: policyLTV * 100,
              maxBorrowForAsset,
              allocatedLoan,
              usageVsCap: Math.max(0, usageVsCap),
              tone,
            };
          })
          .sort((a, b) => b.value - a.value);
      }, [autoRepayLtv, loanAmount, marginCallLtv, overallLTVIfBorrow, totals.totalCollateralValue, totals.withValue, ltvByTicker, defaultLtv]);

      const extraCollateralForTarget = useMemo(() => {
        if (targetLtv <= 0) return 0;
        const neededCollateral = loanAmount / targetLtv;
        return Math.max(0, neededCollateral - totals.totalCollateralValue);
      }, [loanAmount, targetLtv, totals.totalCollateralValue]);

      const loyaltyReqs = useMemo(() => {
        if (!loyalty) return null;
        const denom = loyaltyModelActive === "vsTotal" ? totals.total : totals.rest;
        const tiers = (loyalty.tierThresholds ?? []).map((tier) => {
          const required = denom * tier.minRatio;
          const missing = Math.max(0, required - totals.totalLoyalty);
          return { ...tier, required, missing };
        });
        return { denom, tiers };
      }, [loyalty, loyaltyModelActive, totals.total, totals.rest, totals.totalLoyalty]);

      const meetsLowCost = useMemo(() => {
        const withinTarget = loanAmount <= recommendedLoanAtTarget;
        if (lowCostEligibleTiers.length === 0) {
          return totals.total >= minBalancePerks && withinTarget;
        }
        const hasTier = lowCostEligibleTiers.includes(loyaltyTier);
        return totals.total >= minBalancePerks && withinTarget && hasTier;
      }, [loanAmount, recommendedLoanAtTarget, loyaltyTier, totals.total, lowCostEligibleTiers, minBalancePerks]);

      const handleAssetChange = (id, patch) => setAssets(prev => prev.map(a => (a.id === id ? { ...a, ...patch } : a)));

      const addRow = () => {
        const nextId = Math.max(0, ...assets.map(a => a.id)) + 1;
        setAssets(prev => ([...prev, { id: nextId, name: "Nuevo", ticker: "TKN", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: defaultLtv }]));
      };
      const removeRow = (id) => setAssets(prev => prev.filter(a => a.id !== id));

      const loyaltyCardTitle = loyalty ? `Requisitos ${loyalty.tokenTicker ? `${loyalty.tokenTicker.toUpperCase()} & ` : ''}Colateral` : "Colateral & métricas";

      const displayPlatformName = platformName || platformId;

      useEffect(() => {
        document.title = `Simulador de Préstamos / ${displayPlatformName}`;
      }, [displayPlatformName]);

      useEffect(() => {
        if (typeof document === 'undefined') return;
        document.body.classList.remove(...PLATFORM_THEME_CLASSES);
        document.body.classList.add(themeClass);
      }, [themeClass]);

      return (
        <div className="min-h-screen w-full text-neutral-900">
          <div className={`${headerClass} text-white`}>
            <div className="mx-auto max-w-7xl px-4 py-6">
              <header className="flex flex-wrap items-end justify-between gap-4">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">{`Simulador de Préstamos / ${displayPlatformName}`}</h1>
                  <p className={`${accentClass}`}>{platformTagline}</p>
                </div>
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-2">
                    <label className="text-sm font-medium">Plataforma</label>
                    <select value={platformId} onChange={(e) => setPlatformId(PLATFORM_IDS.includes(e.target.value) ? e.target.value : initialPlatformId)} className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80">
                      {PLATFORM_IDS.map((pid) => (
                        <option key={pid} value={pid} className="text-neutral-900">{PLATFORM_CONFIGS[pid]?.name ?? pid}</option>
                      ))}
                    </select>
                  </div>
                  <div className="flex items-center gap-2 text-sm font-medium">
                    <label htmlFor="currency-select">Mostrar en</label>
                    <select
                      id="currency-select"
                      value={currency}
                      onChange={(e) => setSelectedCurrency(e.target.value)}
                      className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80"
                    >
                      {SUPPORTED_CURRENCIES.map((option) => (
                        <option
                          key={option.code}
                          value={option.code}
                          className="text-neutral-900"
                          title={option.label}
                        >
                          {option.code}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>
              </header>
            </div>
          </div>

          <div className="mx-auto max-w-7xl px-4 py-6">
            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
              {(isBinance ? [
                { key: 'loan-current', title: 'Préstamo vigente', value: fmt(loanAmount * rate, currency) },
                { key: 'loan-sim', title: 'Préstamo tras repago simulado', value: fmt(binanceLoanAfterRepay * rate, currency), subtle: binanceRepaySim > 0 ? `Repago simulado ${fmt(Math.min(binanceRepaySim, loanAmount) * rate, currency)}` : 'Sin repago' },
                { key: 'collateral-current', title: 'Colateral actual', value: fmt(totals.totalCollateralValue * rate, currency) },
                { key: 'collateral-adjusted', title: 'Colateral tras ajuste', value: fmt(binanceCollateralAfterAdjust * rate, currency), subtle: binanceCollateralDelta !== 0 ? `${binanceCollateralDelta > 0 ? '+' : '−'}${fmt(Math.abs(binanceCollateralDelta) * rate, currency)}` : 'Sin cambios' },
                { key: 'ltv-current', title: 'LTV inicial', value: `${(overallLTVIfBorrow * 100).toFixed(2)}%`, tone: ltvTone, subtle: 'Con colateral actual' },
                { key: 'ltv-sim', title: 'LTV simulado', value: `${(binanceLtvAfterAdjust * 100).toFixed(2)}%`, tone: binanceLtvTone, subtle: (binanceCollateralDelta !== 0 || binanceRepaySim > 0) ? 'Tras ajustes' : 'Sin ajustes' },
                { key: 'apr', title: 'Tasa anual (APR)', value: `${(chosenAPR * 100).toFixed(2)}%` },
                { key: 'apr-net', title: 'Tasa anual neta', value: `${(netAnnualRate * 100).toFixed(2)}%`, subtle: totalEarnDuringPeriod > 0 ? `Earn proyectado ${fmt(totalEarnDuringPeriod * rate, currency)}` : undefined, tone: netAnnualRate <= chosenAPR ? 'ok' : undefined },
                { key: 'hourly-interest', title: 'Interés estimado por hora', value: fmt(binanceHourlyInterest * rate, currency), subtle: `${(chosenAPR / 365 / 24 * 100).toFixed(3)}%` },
                { key: 'liquidation', title: `Valor colateral (${toPct(marginCallLtv, 0)} margin call)`, value: fmt(binanceLiquidationValue * rate, currency), subtle: binanceLiquidationBuffer >= 0 ? `Buffer ${fmt(binanceLiquidationBuffer * rate, currency)}` : `Déficit ${fmt(Math.abs(binanceLiquidationBuffer) * rate, currency)}`, tone: binanceLiquidationBuffer >= 0 ? 'ok' : 'danger' },
                { key: 'repay-total', title: 'Total a devolver', value: fmt(interestCalc.repayTotal * rate, currency) },
              ] : [
                { key: 'balance', title: 'Balance total', value: fmt(totals.total * rate, currency) },
                { key: 'loyalty', title: loyalty ? (loyalty.kpiLabel || 'Loyalty Tier') : 'Programa', value: loyalty ? loyaltyTier : '—', subtle: loyalty && totals.total < minBalancePerks ? '(balance < mínimo)' : undefined },
                { key: 'apr', title: 'APR crédito', value: `${(chosenAPR * 100).toFixed(2)}%`, subtle: meetsLowCost ? 'Low-Cost activo' : undefined },
                { key: 'cap-lowcost', title: 'Cap. Low-Cost (≤20% LTV)', value: fmt(capLowCost * rate, currency), subtle: 'potencial' },
                { key: 'ltv-top', title: 'Tope por LTVs', value: fmt(totals.maxBorrow * rate, currency) },
                { key: 'loan-target', title: 'Préstamo recomendado (≤20%)', value: fmt(recommendedLoanAtTarget * rate, currency) },
                { key: 'interest-total', title: 'Interés hasta repago', value: fmt(interestCalc.total * rate, currency), subtle: `${daysUntilRepay} días` },
                { key: 'repay-total', title: 'Total a devolver', value: fmt(interestCalc.repayTotal * rate, currency) },
                { key: 'earn-monthly', title: 'Earn mensual (hasta)', value: fmt(earnMonthly * rate, currency), subtle: earnEligible ? (minBalancePerks > 0 ? `Savings ≥ $${minBalancePerks}` : undefined) : 'no elegible' },
                { key: 'net-monthly', title: 'Neto mensual (Earn − crédito)', value: fmt(netMonthly * rate, currency), tone: netMonthly >= 0 ? 'ok' : 'danger' },
              ]).map((item) => (
                <KPI key={item.key} title={item.title} value={item.value} subtle={item.subtle} tone={item.tone} variant={item.variant || 'button'} />
              ))}
            </section>

            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
              <Card title="Préstamo & Repago">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 justify-items-center">
                  <Field label={`Monto a pedir (${currency})`} align="center" className="w-full max-w-xs">
                    <input
                      type="number"
                      className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                      value={(loanAmount * rate).toString()}
                      onChange={(e)=> setLoanAmount(Number(e.target.value) / rate)}
                      min={0}
                    />
                  </Field>
                  <Field label="Fecha de repago" align="center" className="w-full max-w-xs">
                    <input
                      type="date"
                      className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                      value={repayDate}
                      min={todayISO()}
                      onChange={(e)=> setRepayDate(e.target.value)}
                    />
                  </Field>
                </div>
                <div className="mt-6 space-y-3">
                  {isBinance ? (
                    <>
                      <Pill label="LTV actual" value={`${(overallLTVIfBorrow*100).toFixed(2)}%`} tone={ltvTone} />
                      <Pill label="LTV simulado" value={`${(binanceLtvAfterAdjust*100).toFixed(2)}%`} tone={binanceLtvTone} />
                      <Pill label={`Colateral extra para ≤${toPct(ltvHealthyThreshold, 0)}`} value={fmt(binanceExtraCollateralNeeded * rate, currency)} tone={binanceExtraCollateralNeeded > 0 ? "warn" : "ok"} />
                      <Pill label={`Repago para ≤${toPct(ltvHealthyThreshold, 0)}`} value={fmt(binanceRepayNeeded * rate, currency)} tone={binanceRepayNeeded > 0 ? "warn" : "ok"} />
                      <Pill label={`Buffer hasta ${toPct(ltvWarnThreshold, 0)}`} value={fmt(binanceBufferToCaution * rate, currency)} tone={binanceBufferToCaution > 0 ? "ok" : "danger"} />
                    </>
                  ) : (
                    <>
                      <Pill label="LTV si pides esto" value={`${(overallLTVIfBorrow*100).toFixed(2)}%`} tone={ltvTone} />
                      <Pill label="≤20% LTV (fijo)" value={loanAmount <= recommendedLoanAtTarget ? "Sí" : "No"} tone={loanAmount <= recommendedLoanAtTarget ? "ok" : "warn"} />
                      <Pill label="¿Califica Low-Cost?" value={meetsLowCost ? "Sí" : "No"} tone={meetsLowCost ? "ok" : "warn"} />
                      <Pill label="Margen Low-Cost" value={fmt(lowCostHeadroom * rate, currency)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                    </>
                  )}
                </div>
              </Card>

              <Card title="Salud del préstamo">
                <LTVGauge value={ltvGaugeValue} zones={ltvGaugeZones} markers={ltvGaugeMarkers} />
                <div className="mt-2 text-center text-xs text-neutral-500">
                  {ltvScenarioLabel ? `Escenario activo: ${ltvScenarioLabel}` : 'Escenario base sin shocks.'}
                </div>
                {cashflowAlerts.length > 0 && (
                  <div className="mt-3 space-y-2 text-xs">
                    {cashflowAlerts.slice(0, 2).map((alert, idx) => (
                      <div key={`ltv-alert-${idx}`} className="rounded-xl border border-rose-200 bg-rose-50 px-3 py-2 text-rose-700">
                        {alert}
                      </div>
                    ))}
                  </div>
                )}
                <div className="mt-4 space-y-2">
                  {isBinance ? (
                    <>
                      <Line label="LTV proyectado (cashflow)" value={`${Number.isFinite(ltvGaugeValue) ? (ltvGaugeValue*100).toFixed(2) : '∞'}%`} tone={ltvTone} />
                      <Line label="LTV actual" value={`${(overallLTVIfBorrow*100).toFixed(2)}%`} muted />
                      <Line label="LTV simulado" value={`${(binanceLtvAfterAdjust*100).toFixed(2)}%`} tone={binanceLtvTone} />
                      <Line label="Rango saludable" value={`≤ ${toPct(ltvHealthyThreshold, 0)}`} muted />
                      <Line label="Riesgo medio" value={binanceCautionLabel} muted />
                      <Line label="Margin call" value={toPct(marginCallLtv, 0)} muted />
                      <Line label="Auto-liquidación" value={toPct(autoRepayLtv, 0)} muted />
                      <Line label="Colateral mínimo (margin call)" value={fmt(binanceLiquidationValue * rate, currency)} tone={binanceLiquidationBuffer >= 0 ? "ok" : "danger"} />
                      <Line label="Buffer actual" value={binanceLiquidationBuffer >= 0 ? fmt(binanceLiquidationBuffer * rate, currency) : `Déficit ${fmt(Math.abs(binanceLiquidationBuffer) * rate, currency)}`} tone={binanceLiquidationBuffer >= 0 ? "ok" : "danger"} />
                      <Line label="Buffer simulado" value={binanceAdjustedLiquidationBuffer >= 0 ? fmt(binanceAdjustedLiquidationBuffer * rate, currency) : `Déficit ${fmt(Math.abs(binanceAdjustedLiquidationBuffer) * rate, currency)}`} tone={binanceAdjustedLiquidationBuffer >= 0 ? "ok" : "danger"} />
                    </>
                  ) : (
                    <>
                      <Line label="LTV proyectado (cashflow)" value={`${Number.isFinite(ltvGaugeValue) ? (ltvGaugeValue*100).toFixed(1) : '∞'}%`} tone={ltvTone} />
                      <Line label="LTV actual" value={`${(overallLTVIfBorrow*100).toFixed(1)}%`} muted />
                      <Line label="Objetivo Low-Cost" value={`${(targetLtv*100).toFixed(0)}%`} muted />
                      <Line label="Margin call" value={`${(marginCallLtv*100).toFixed(0)}%`} muted />
                      <Line label="Auto-repay" value={`${(autoRepayLtv*100).toFixed(0)}%`} muted />
                      <Line label="Cap Low-Cost" value={fmt(capLowCost * rate, currency)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                    </>
                  )}
                </div>
              </Card>

              <Card title="Parámetros (solo entorno)">
                <div className="grid grid-cols-2 gap-3">
                  {SUPPORTED_CURRENCIES.filter((option) => option.code !== 'USD').map((option) => (
                    <NumberParam
                      key={option.code}
                      label={`USD→${option.code}`}
                      value={params.exchangeRates?.[option.code] ?? baseExchangeRates[option.code] ?? DEFAULT_EXCHANGE_RATES[option.code] ?? 1}
                      onChange={(v) => setParams({
                        ...params,
                        exchangeRates: { ...params.exchangeRates, [option.code]: v },
                      })}
                    />
                  ))}

                  <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 flex flex-wrap items-center gap-3">
                    <div className="flex items-center gap-2 text-sm font-medium">
                      <span className="inline-flex items-center rounded-full bg-emerald-100 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-emerald-700">Activo</span>
                      <span>Precios en tiempo real (CoinGecko)</span>
                    </div>
                    <span className="text-xs text-neutral-500">Actualización en tiempo real cada {LIVE_REFRESH_SECONDS} segundos.</span>
                    <button onClick={fetchLivePricesNow} className="nx-btn text-sm">Actualizar ahora</button>
                    <span className="text-xs text-neutral-500">{lastPriceTs ? `Últ. actualización: ${new Date(lastPriceTs).toLocaleTimeString()}` : '— sin actualizar —'}</span>
                    {liveError && <span className="text-xs text-rose-600">Error: {liveError}</span>}
                  </div>

                  <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 flex flex-wrap items-center gap-3">
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.earnOptIn} onChange={(e)=> setParams({ ...params, earnOptIn: e.target.checked })} />
                      Considerar intereses (Savings) y compounding
                    </label>
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.earnOnCollateral} onChange={(e)=> setParams({ ...params, earnOnCollateral: e.target.checked })} />
                      Incluir colateral en Earn
                    </label>
                    {minBalancePerks > 0 && <span className="text-xs text-neutral-500">* Elegible si balance ≥ ${minBalancePerks}.</span>}
                  </div>

                  {isBinance && (
                    <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
                      <NumberParam label="Ajuste colateral simulado (USD)" value={params.binanceCollateralDelta} onChange={(v)=> setParams({ ...params, binanceCollateralDelta: v })} />
                      <NumberParam label="Repago simulado (USD)" value={params.binanceRepaySim} onChange={(v)=> setParams({ ...params, binanceRepaySim: Math.max(0, v) })} />
                      <p className="sm:col-span-2 text-xs text-neutral-500">Usá estos campos para estimar cómo impactan los ajustes de colateral o repagos anticipados en el LTV y el precio de liquidación.</p>
                    </div>
                  )}

                  <div className="col-span-2 text-xs text-neutral-500">
                    {isBinance ? 'LTV, rangos de salud y precios de liquidación se basan en las reglas flexibles de Binance. Ajusta valores para simular escenarios.' : '* LTV, APR por nivel y descuentos Low-Cost provienen de la plataforma elegida. Aquí solo ajustás parámetros de entorno (cambio, frecuencia, toggles).'}
                  </div>
                </div>
              </Card>

              <Card title={loyaltyCardTitle}>
                <div className="grid grid-cols-1 gap-3">
                  {loyalty && loyaltyReqs?.tiers?.length ? (
                    loyaltyReqs.tiers.map((tier) => (
                      <React.Fragment key={tier.label}>
                        <Line label={`Requerido ${tier.label} (${(tier.minRatio * 100).toFixed(1)}% ${loyaltyModelActive === 'vsTotal' ? 'vs total' : 'vs resto'})`} value={fmt(tier.required * rate, currency)} />
                        <Line label={`Faltante ${tier.label}`} value={fmt(tier.missing * rate, currency)} muted={tier.missing <= 0} />
                      </React.Fragment>
                    ))
                  ) : (
                    <p className="text-sm text-neutral-500">Esta plataforma no tiene un programa de niveles ligado a un token específico.</p>
                  )}
                  <div className="h-px bg-neutral-200 my-1" />
                  <Line label={`Colateral extra para ≤${(targetLtv * 100).toFixed(0)}%`} value={fmt(extraCollateralForTarget * rate, currency)} tone={extraCollateralForTarget <= 0 ? "ok" : "warn"} />
                </div>
              </Card>
            </section>

            <section className="mb-8">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-xl font-semibold">Activos y colateral</h2>
                <div className="flex items-center gap-2">
                  <button onClick={addRow} className="nx-btn text-sm">Añadir activo</button>
                  <button onClick={() => { localStorage.removeItem(storageKeys.assets); setAssets(sanitizeAssets(platformDefaultAssets)); }} className="nx-btn nx-btn-ghost text-sm">Reset</button>
                </div>
              </div>

              <div className="overflow-x-auto rounded-2xl nx-card bg-white">
                <table className="min-w-full text-sm">
                  <thead className="bg-neutral-900 text-white sticky top-0 z-10">
                    <tr>
                      <Th>Activo</Th>
                      <Th>Ticker</Th>
                      <Th>Cantidad</Th>
                      <Th>Precio (USD)</Th>
                      <Th>Auto</Th>
                      <Th>Valor</Th>
                      <Th>Colateral</Th>
                      <Th>LTV (fijo)</Th>
                      <Th>APR Earn (flex máx)</Th>
                      <Th></Th>
                    </tr>
                  </thead>
                  <tbody>
                    {totals.withValue.map((a) => (
                      <tr key={a.id} className="border-t border-neutral-100 even:bg-neutral-50 hover:bg-neutral-100/50 transition-colors">
                        <Td align="center">
                          <input value={a.name} onChange={(e) => handleAssetChange(a.id, { name: e.target.value })} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input value={a.ticker} onChange={(e) => { const newT = sanitizeTicker(e.target.value); const newL = ltvByTicker[newT] ?? defaultLtv; handleAssetChange(a.id, { ticker: newT, ltv: newL }); if (a.priceAuto !== false) { fetchPricesForTickers([newT]); } }} className="w-24 rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input type="number" min={0} step="any" value={a.qty} onChange={(e) => { const v = e.target.valueAsNumber; handleAssetChange(a.id, { qty: Number.isFinite(v) ? v : 0 }); }} placeholder="0.00" className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input type="number" min={0} step="any" value={a.price} onChange={(e) => { const v = e.target.valueAsNumber; handleAssetChange(a.id, { price: Number.isFinite(v) ? v : 0 }); }} placeholder="0.00" disabled={a.priceAuto !== false} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center disabled:bg-neutral-50 disabled:text-neutral-400" />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" checked={a.priceAuto !== false} onChange={(e) => { handleAssetChange(a.id, { priceAuto: e.target.checked }); if (e.target.checked) { fetchPricesForTickers([a.ticker]); } }} className="h-5 w-5" />
                        </Td>
                        <Td align="center" className="font-medium">{fmt(a.value * rate, currency)}</Td>
                        <Td align="center">
                          <input type="checkbox" title="Si está activo, este activo cuenta como colateral para LTV y Tope por LTVs" checked={a.useAsCollateral} onChange={(e) => handleAssetChange(a.id, { useAsCollateral: e.target.checked })} className="h-5 w-5" />
                        </Td>
                        <Td align="center" title="Política de LTV fija por plataforma">
                          <span className="inline-block rounded-xl bg-neutral-100 px-3 py-1 font-semibold">{pct(ltvByTicker[sanitizeTicker(a.ticker)] ?? a.ltv ?? 0)}</span>
                        </Td>
                        <Td align="center" title="Flexible Savings – tasa tope mostrada públicamente">
                          <span className="inline-block rounded-xl bg-blue-50 text-blue-700 px-3 py-1 font-semibold">{pct(earnAprTop[sanitizeTicker(a.ticker)] ?? 0)}</span>
                        </Td>
                        <Td align="center">
                          <button onClick={() => removeRow(a.id)} className="nx-btn nx-btn-ghost nx-btn-sm">Borrar</button>
                        </Td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="mb-10 grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
              <Card title="Proyección del préstamo">
                <TrendChart data={timeline} currency={currency} rate={rate} />
              </Card>

              <Card title="Breakdown de colateral & LTV">
                <CollateralBreakdownCard
                  breakdown={collateralBreakdown}
                  currency={currency}
                  rate={rate}
                  totalCollateral={totals.totalCollateralValue}
                  totalMaxBorrow={totals.maxBorrow}
                  overallLTV={overallLTVIfBorrow}
                  target={targetLtv}
                  marginCall={marginCallLtv}
                  autoRepay={autoRepayLtv}
                  capLowCost={capLowCost}
                  lowCostHeadroom={lowCostHeadroom}
                />
              </Card>

              <Card title="Diagnóstico & Sugerencias">
                <ul className="list-disc pl-5 space-y-2 text-sm">
                  {loyalty ? (
                    <li>
                      Tu {loyalty.ratioLabel ?? `ratio ${loyalty.tokenTicker?.toUpperCase() || ''}`} es <b>{(totals.ratioVsRest * 100).toFixed(2)}% vs resto</b> / <b>{(totals.ratioVsTotal * 100).toFixed(2)}% vs total</b>. Modelo activo: <b>{loyaltyModelActive === "vsTotal" ? "vs total" : "vs resto"}</b>. Nivel actual: <b>{loyaltyTier}</b>.
                      {totals.total < minBalancePerks && (<span className="text-neutral-600"> (El balance total no supera el mínimo de perks).</span>)}
                    </li>
                  ) : (
                    <li>Esta plataforma no requiere ratio de token para acceder a mejores tasas: el enfoque es puramente por colateral.</li>
                  )}
                  {loyalty && loyaltyReqs?.tiers?.length ? (
                    <li>
                      {loyaltyReqs.tiers.map((tier, idx) => (
                        <span key={tier.label}>{idx > 0 ? ' · ' : ''}Para <b>{tier.label}</b> faltan {fmt(tier.missing * rate, currency)}</span>
                      ))}
                    </li>
                  ) : null}
                  <li>
                    Con tu colateral actual, el tope por LTVs es {fmt(totals.maxBorrow * rate, currency)}. El cap Low-Cost (≤{(targetLtv * 100).toFixed(0)}%) permite pedir hasta {fmt(capLowCost * rate, currency)} y deja {fmt(lowCostHeadroom * rate, currency)} de margen.
                  </li>
                  <li>
                    Para solicitar {fmt(loanAmount * rate, currency)} y mantener ≤{(targetLtv * 100).toFixed(0)}% LTV se requieren {fmt(extraCollateralForTarget * rate, currency)} adicionales en colateral.
                  </li>
                  <li>
                    APR estimado: <b>{(chosenAPR * 100).toFixed(2)}%</b>. Interés hasta repago ({daysUntilRepay} días): {fmt(interestCalc.total * rate, currency)}.{interestCalc.early > 0 && <span> Incluye interés por "early rule".</span>}
                  </li>
                  <li>
                    Earn (flex) mensual estimado {earnEligible ? (minBalancePerks > 0 ? "(tope)" : "") : (minBalancePerks > 0 ? "(requiere balance mínimo)" : "(no elegible)")}: <b>{fmt(earnMonthly * rate, currency)}</b>. Neto mensual: <b className={netMonthly>=0?"text-emerald-700":"text-rose-700"}>{fmt(netMonthly * rate, currency)}</b>.
                  </li>
                </ul>
              </Card>

              <Card title="Exportar / Plantilla">
                <p className="text-sm text-neutral-700 mb-3">Guardamos tus datos en <code>localStorage</code>. Podés exportar un JSON con todo o resetear la demo.</p>
                <div className="flex flex-wrap gap-3">
                  <input
                    ref={importInputRef}
                    type="file"
                    accept="application/json"
                    className="hidden"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (!file) return;
                      file.text().then((text) => {
                        try {
                          const parsed = JSON.parse(text);
                          if (parsed.assets) setAssets(sanitizeAssets(parsed.assets));
                          if (parsed.params) setParams(sanitizeParams(parsed.params));
                          if (parsed.cashflowPlan) setCashflowPlan(sanitizeCashflowPlan(parsed.cashflowPlan, repayDate));
                          if (parsed.benchmarkConfig) setBenchmarkConfig(sanitizeBenchmarkConfig(parsed.benchmarkConfig));
                        } catch (err) {
                          alert(`No se pudo importar el archivo: ${err?.message || err}`);
                        }
                      }).finally(() => {
                        if (importInputRef.current) importInputRef.current.value = '';
                      });
                    }}
                  />
                  <button className="nx-btn text-sm" onClick={() => {
                    const blob = new Blob([ JSON.stringify({ assets, params, cashflowPlan, benchmarkConfig }, null, 2) ], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url; a.download = `${exportPrefix}_${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
                  }}>Exportar JSON</button>

                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => importInputRef.current?.click()}>Importar JSON</button>

                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Restablecer parámetros por defecto?")) { localStorage.removeItem(storageKeys.params); setParams({ ...baseParams }); } }}>Reset parámetros</button>
                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Restablecer activos por defecto?")) { localStorage.removeItem(storageKeys.assets); setAssets(sanitizeAssets(platformDefaultAssets)); } }}>Reset activos</button>
                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Limpiar plan de cashflow y benchmark?")) { localStorage.removeItem(storageKeys.cashflow); localStorage.removeItem(storageKeys.benchmark); setCashflowPlan(baseCashflowPlan); setBenchmarkConfig(baseBenchmarkConfig); } }}>Reset planners</button>
                </div>
                <div className="mt-4 text-xs text-neutral-500"><p>{disclaimers.finePrint || '* Este simulador es orientativo. Verifica términos/tasas vigentes en la plataforma oficial.'}</p></div>
              </Card>
            </section>

            <section className="mb-10 grid grid-cols-1 xl:grid-cols-2 gap-6">
              <CashflowPlanner
                plan={cashflowPlan}
                derived={cashflowDerived}
                onPlanChange={updateCashflowPlan}
                currency={currency}
                rate={rate}
                fmt={fmt}
                loanAmount={loanAmount}
                chosenAPR={chosenAPR}
                interestCalc={interestCalc}
                daysUntilRepay={daysUntilRepay}
                repayDate={repayDate}
                totals={totals}
                targetLtv={targetLtv}
                marginCallLtv={marginCallLtv}
                autoRepayLtv={autoRepayLtv}
                scenarioDefaults={cashflowPlan?.scenarioShocks}
                focusRingClass={focusRingClass}
                netMonthly={netMonthly}
                earnMonthly={earnMonthly}
                earnEligible={earnEligible}
                minBalancePerks={minBalancePerks}
              />

              <BenchmarkCeFiDeFi
                config={benchmarkConfig}
                onChange={updateBenchmarkConfig}
                fmt={fmt}
                currency={currency}
                rate={rate}
                loanAmount={loanAmount}
                chosenAPR={chosenAPR}
                daysUntilRepay={daysUntilRepay}
                scenarioName={ltvScenarioLabel}
                cashflowNet={cashflowDerived?.netBalanceFinal}
                defaultMatrix={baseBenchmarkConfig?.rateMatrix}
              />
            </section>

            <section className="mb-10 grid grid-cols-1 lg:grid-cols-2 gap-6">
              <Card title="Plataformas en radar">
                <p className="text-sm text-neutral-600 mb-3">Listado vivo de proveedores CeFi/prime que podemos sumar al simulador. Indicamos si ya están integrados y qué aportan.</p>
                <div className="space-y-3">
                  {candidatePlatforms.map((candidate) => (
                    <div key={candidate.id} className="rounded-2xl border border-neutral-200 p-4">
                      <div className="flex flex-wrap items-center justify-between gap-2">
                        <div>
                          <div className="text-sm font-semibold text-neutral-900">{candidate.name}</div>
                          <div className="text-xs text-neutral-500">{candidate.segment} · {candidate.region}</div>
                        </div>
                        <span className={`inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold ${candidate.integrated ? 'bg-emerald-100 text-emerald-700' : 'bg-amber-100 text-amber-700'}`}>
                          {candidate.integrated ? (candidate.isCurrent ? 'Integrada (activa)' : 'Integrada') : 'Pendiente'}
                        </span>
                      </div>
                      <p className="mt-2 text-sm text-neutral-600">{candidate.focus}</p>
                      <ul className="mt-2 list-disc space-y-1 pl-5 text-xs text-neutral-500">
                        {candidate.highlights.map((point, idx) => (
                          <li key={`${candidate.id}-highlight-${idx}`}>{point}</li>
                        ))}
                      </ul>
                    </div>
                  ))}
                </div>
              </Card>

              <Card title="Ideas para un simulador único">
                <p className="text-sm text-neutral-600">Backlog sugerido para diferenciar la herramienta y hacerla monetizable.</p>
                <ol className="mt-3 list-decimal space-y-3 pl-5 text-sm text-neutral-700">
                  {improvementIdeas.map((idea) => (
                    <li key={idea.id}>
                      <div className="font-semibold text-neutral-900">{idea.title}</div>
                      <p className="text-xs text-neutral-500 mt-1">{idea.description}</p>
                    </li>
                  ))}
                </ol>
              </Card>
            </section>

      <footer className="text-xs text-neutral-500">© {new Date().getFullYear()} – Demo técnica. Estilos y métricas se adaptan según la plataforma elegida.</footer>
      </div>
    </div>
  );
}

    function CashflowPlanner({
      plan,
      derived,
      onPlanChange,
      currency,
      rate,
      fmt,
      loanAmount,
      chosenAPR,
      interestCalc,
      daysUntilRepay,
      repayDate,
      totals,
      targetLtv,
      marginCallLtv,
      autoRepayLtv,
      scenarioDefaults,
      focusRingClass,
      netMonthly,
      earnMonthly,
      earnEligible,
      minBalancePerks,
    }) {
      const safePlan = plan || {};
      const baseScenarios = { base: 0, bear: -0.25, bull: 0.15, ...(scenarioDefaults || {}) };
      const combinedShocks = { ...baseScenarios, ...(safePlan.scenarioShocks || {}), ...(derived?.scenarioShocks || {}) };
      const scenarioKeys = Object.keys(combinedShocks);
      const activeScenario = scenarioKeys.includes(safePlan.activeScenario)
        ? safePlan.activeScenario
        : (derived?.activeScenario && scenarioKeys.includes(derived.activeScenario) ? derived.activeScenario : scenarioKeys[0]);
      const timeline = derived?.timeline || [];
      const chartData = derived?.chartData || [];
      const fundingGaps = derived?.fundingGaps || [];
      const alerts = derived?.alerts || [];
      const netFinal = derived?.netBalanceFinal ?? loanAmount;
      const minNet = derived?.minNetBalance ?? netFinal;
      const outstanding = derived?.lastOutstanding ?? 0;

      const scenarioLabels = { base: 'Base', bear: 'Bajista', bull: 'Alcista' };

      const setScenarioShock = (key, valuePct) => {
        const pct = Number(valuePct);
        if (!Number.isFinite(pct)) return;
        onPlanChange((prev) => ({
          ...prev,
          scenarioShocks: { ...(prev?.scenarioShocks || {}), [key]: pct / 100 },
        }));
      };

      const setActiveScenario = (value) => {
        if (!scenarioKeys.includes(value)) return;
        onPlanChange({ activeScenario: value });
      };

      const updateListItem = (listName, id, patch) => {
        onPlanChange((prev) => ({
          ...prev,
          [listName]: (prev?.[listName] || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
        }));
      };

      const removeListItem = (listName, id) => {
        onPlanChange((prev) => ({
          ...prev,
          [listName]: (prev?.[listName] || []).filter((item) => item.id !== id),
        }));
      };

      const addPayment = () => {
        const nextId = Math.max(0, ...((safePlan.payments || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          payments: [...(prev?.payments || []), {
            id: nextId,
            date: repayDate,
            principal: loanAmount,
            interest: interestCalc?.total || 0,
            label: `Pago ${nextId}`,
          }],
        }));
      };

      const addEarn = () => {
        const nextId = Math.max(0, ...((safePlan.earns || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          earns: [...(prev?.earns || []), {
            id: nextId,
            startDate: todayISO(),
            endDate: repayDate,
            frequency: 'monthly',
            amount: Math.max(0, earnMonthly || netMonthly || 0),
            platform: '',
            token: '',
            label: `Earn ${nextId}`,
          }],
        }));
      };

      const addManual = () => {
        const nextId = Math.max(0, ...((safePlan.manual || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          manual: [...(prev?.manual || []), {
            id: nextId,
            date: todayISO(),
            amount: 1000,
            direction: 'outflow',
            collateralImpact: 'increase',
            label: `Evento ${nextId}`,
          }],
        }));
      };

      const formatMoney = (value) => fmt(value * rate, currency);

      const summaryTiles = [
        { label: 'Balance final proyectado', value: formatMoney(netFinal), tone: netFinal >= 0 ? 'text-emerald-600' : 'text-rose-600' },
        { label: 'Mínimo del período', value: formatMoney(minNet), tone: minNet >= 0 ? 'text-neutral-700' : 'text-rose-600' },
        { label: 'Capital pendiente', value: formatMoney(outstanding), tone: 'text-neutral-700' },
        { label: 'Earn mensual', value: formatMoney(earnMonthly), tone: 'text-neutral-700', hint: earnEligible ? 'Earn activo' : 'Earn inactivo' },
      ];

      return (
        <Card title="Planificador de cashflow">
          <div className="space-y-6 text-sm">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              {summaryTiles.map((tile) => (
                <div key={tile.label} className="rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                  <div className="text-xs text-neutral-500 uppercase">{tile.label}</div>
                  <div className={`text-lg font-semibold ${tile.tone}`}>{tile.value}</div>
                  {tile.hint && <div className="text-[11px] text-neutral-500">{tile.hint}</div>}
                </div>
              ))}
            </div>

            <div>
              <h4 className="mb-2 text-sm font-semibold text-neutral-700">Curva de saldo neto</h4>
              <TrendChart data={chartData} currency={currency} rate={rate} />
            </div>

            <div className="rounded-2xl border border-neutral-200 bg-white p-4 space-y-4">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div>
                  <div className="text-sm font-semibold text-neutral-700">Escenarios de estrés</div>
                  <p className="text-xs text-neutral-500">Define shocks de precio (%) y selecciona cuál alimenta el velocímetro de LTV.</p>
                </div>
                <select value={activeScenario} onChange={(e) => setActiveScenario(e.target.value)} className={`rounded-full border border-neutral-300 px-3 py-1.5 text-sm font-semibold focus:outline-none focus:ring-2 ${focusRingClass}`}>
                  {scenarioKeys.map((key) => (
                    <option key={key} value={key}>{scenarioLabels[key] || key}</option>
                  ))}
                </select>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                {scenarioKeys.map((key) => (
                  <div key={`scenario-${key}`} className={`rounded-2xl border ${activeScenario === key ? 'border-blue-400 bg-blue-50/40' : 'border-neutral-200 bg-neutral-50/60'} p-3 space-y-2`}>
                    <div className="flex items-center justify-between">
                      <span className="font-semibold text-neutral-700">{scenarioLabels[key] || key}</span>
                      <input type="number" step="0.5" value={((combinedShocks[key] ?? 0) * 100).toFixed(1)} onChange={(e) => setScenarioShock(key, e.target.value)} className={`w-20 rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div className="text-[11px] text-neutral-500">Shock sobre colateral</div>
                    <div className="text-[11px] text-neutral-600">LTV final: {derived?.scenarioSummaries?.[key]?.last != null && Number.isFinite(derived.scenarioSummaries[key].last) ? `${(derived.scenarioSummaries[key].last * 100).toFixed(1)}%` : '—'}</div>
                    <div className="text-[11px] text-neutral-600">Saldo: {derived?.scenarioSummaries?.[key]?.net != null ? formatMoney(derived.scenarioSummaries[key].net) : formatMoney(netFinal)}</div>
                  </div>
                ))}
              </div>
              {alerts.length > 0 && (
                <div className="rounded-2xl border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-700 space-y-1">
                  {alerts.map((msg, idx) => <div key={`cf-alert-${idx}`}>{msg}</div>)}
                </div>
              )}
            </div>

            {fundingGaps.length > 0 && (
              <div className="rounded-2xl border border-rose-200 bg-rose-50 px-4 py-3 text-xs text-rose-700">
                <div className="font-semibold mb-1">Gaps de liquidez detectados</div>
                <ul className="list-disc pl-5 space-y-1">
                  {fundingGaps.map((gap, idx) => (
                    <li key={`gap-${idx}`}>Día {gap.day} ({gap.date}) · saldo neto {formatMoney(gap.net)}</li>
                  ))}
                </ul>
              </div>
            )}

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Pagos programados</h4>
                <button className="nx-btn nx-btn-sm" onClick={addPayment}>Agregar pago</button>
              </div>
              <div className="space-y-3">
                {(safePlan.payments || []).length === 0 && (
                  <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">No hay pagos definidos. Añade uno para proyectar obligaciones.</div>
                )}
                {(safePlan.payments || []).map((item) => (
                  <div key={item.id} className="grid grid-cols-1 md:grid-cols-5 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3 text-xs">
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Fecha</div>
                      <input type="date" value={item.date || ''} onChange={(e) => updateListItem('payments', item.id, { date: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Capital</div>
                      <input type="number" min="0" value={item.principal ?? 0} onChange={(e) => updateListItem('payments', item.id, { principal: Number(e.target.value) })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Interés</div>
                      <input type="number" min="0" value={item.interest ?? 0} onChange={(e) => updateListItem('payments', item.id, { interest: Number(e.target.value) })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div className="md:col-span-1">
                      <div className="text-[11px] uppercase text-neutral-400">Nota</div>
                      <input type="text" value={item.label || ''} onChange={(e) => updateListItem('payments', item.id, { label: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div className="flex items-end justify-end">
                      <button className="text-rose-600 hover:underline" onClick={() => removeListItem('payments', item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Flujos de Earn / staking</h4>
                <button className="nx-btn nx-btn-sm" onClick={addEarn}>Agregar flujo</button>
              </div>
              <div className="space-y-3">
                {(safePlan.earns || []).length === 0 && (
                  <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">Suma tus estrategias de rendimiento para cubrir el costo del préstamo.</div>
                )}
                {(safePlan.earns || []).map((item) => (
                  <div key={item.id} className="grid grid-cols-1 md:grid-cols-6 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3 text-xs">
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Inicio</div>
                      <input type="date" value={item.startDate || ''} onChange={(e) => updateListItem('earns', item.id, { startDate: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Fin</div>
                      <input type="date" value={item.endDate || ''} onChange={(e) => updateListItem('earns', item.id, { endDate: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Frecuencia</div>
                      <select value={item.frequency || 'monthly'} onChange={(e) => updateListItem('earns', item.id, { frequency: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                        <option value="daily">Diario</option>
                        <option value="weekly">Semanal</option>
                        <option value="monthly">Mensual</option>
                      </select>
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Monto</div>
                      <input type="number" min="0" value={item.amount ?? 0} onChange={(e) => updateListItem('earns', item.id, { amount: Number(e.target.value) })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Origen</div>
                      <input type="text" value={item.platform || ''} onChange={(e) => updateListItem('earns', item.id, { platform: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div className="flex items-end justify-between gap-2">
                      <input type="text" value={item.token || ''} placeholder="Token" onChange={(e) => updateListItem('earns', item.id, { token: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      <button className="text-rose-600 hover:underline" onClick={() => removeListItem('earns', item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Eventos manuales</h4>
                <button className="nx-btn nx-btn-sm" onClick={addManual}>Agregar evento</button>
              </div>
              <div className="space-y-3">
                {(safePlan.manual || []).length === 0 && (
                  <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">Registra recargas de colateral o retiros planificados.</div>
                )}
                {(safePlan.manual || []).map((item) => (
                  <div key={item.id} className="grid grid-cols-1 md:grid-cols-5 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3 text-xs">
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Fecha</div>
                      <input type="date" value={item.date || ''} onChange={(e) => updateListItem('manual', item.id, { date: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Monto</div>
                      <input type="number" min="0" value={item.amount ?? 0} onChange={(e) => updateListItem('manual', item.id, { amount: Number(e.target.value) })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Dirección</div>
                      <select value={item.direction || 'outflow'} onChange={(e) => updateListItem('manual', item.id, { direction: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                        <option value="outflow">Salida</option>
                        <option value="inflow">Entrada</option>
                      </select>
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Colateral</div>
                      <select value={item.collateralImpact || 'increase'} onChange={(e) => updateListItem('manual', item.id, { collateralImpact: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                        <option value="increase">Aumenta</option>
                        <option value="decrease">Disminuye</option>
                        <option value="none">Sin cambio</option>
                      </select>
                    </div>
                    <div className="flex items-end justify-between gap-2">
                      <input type="text" value={item.label || ''} placeholder="Descripción" onChange={(e) => updateListItem('manual', item.id, { label: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      <button className="text-rose-600 hover:underline" onClick={() => removeListItem('manual', item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="rounded-2xl border border-neutral-200 bg-neutral-50/70 px-4 py-3 text-[11px] text-neutral-600 space-y-1">
              <div>APR: {(chosenAPR * 100).toFixed(2)}% · Interés total estimado: {formatMoney(interestCalc?.total || 0)} · Plazo restante: {daysUntilRepay} días</div>
              <div>Colateral: {formatMoney(totals.totalCollateralValue || 0)} · Objetivo LTV: {(targetLtv * 100).toFixed(0)}% · Margin call: {(marginCallLtv * 100).toFixed(0)}% · Auto-repay: {(autoRepayLtv * 100).toFixed(0)}%</div>
            </div>
          </div>
        </Card>
      );
    }

    function computeCashflowProjections(plan, context = {}) {
      const {
        loanAmount = 0,
        apr = 0,
        repayDate,
        totalCollateralValue = 0,
        targetLtv = 0.2,
        marginCallLtv = 0.7,
        autoRepayLtv = 0.85,
        scenarioShocks = {},
      } = context;
      const safePlan = plan || {};
      const baseScenarios = { base: 0, bear: -0.25, bull: 0.15, ...(safePlan.scenarioShocks || {}), ...(scenarioShocks || {}) };
      const scenarioKeys = Object.keys(baseScenarios);
      const activeScenario = scenarioKeys.includes(safePlan.activeScenario) ? safePlan.activeScenario : scenarioKeys[0];
      const msInDay = 24 * 60 * 60 * 1000;
      const today = new Date(); today.setHours(0, 0, 0, 0);
      const parseDate = (value, fallback) => {
        if (value instanceof Date && !Number.isNaN(value.getTime())) {
          const d = new Date(value.getTime()); d.setHours(0, 0, 0, 0); return d;
        }
        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
          const d = new Date(value); if (!Number.isNaN(d.getTime())) { d.setHours(0,0,0,0); return d; }
        }
        return fallback ? new Date(fallback.getTime()) : new Date(today.getTime());
      };
      const endDate = parseDate(repayDate, today);
      const events = [];
      const pushEvent = (event) => {
        const date = parseDate(event.date, today);
        events.push({ ...event, date });
      };
      pushEvent({ id: 'loan', type: 'loan', date: today, amount: loanAmount, label: 'Desembolso' });

      (safePlan.payments || []).forEach((item, idx) => {
        const principal = Number(item.principal) || 0;
        const interest = Number(item.interest) || 0;
        const total = principal + interest;
        if (total === 0) return;
        pushEvent({
          id: `payment-${item.id ?? idx}`,
          type: 'payment',
          date: item.date || endDate,
          label: item.label || `Pago ${idx + 1}`,
          amount: -total,
          principalImpact: principal,
          interestPortion: interest,
        });
      });

      const freqToDays = { daily: 1, weekly: 7, monthly: 30 };
      (safePlan.earns || []).forEach((item, idx) => {
        const step = freqToDays[item.frequency] || 30;
        const amount = Number(item.amount) || 0;
        if (!(amount > 0) || step <= 0) return;
        let current = parseDate(item.startDate, today);
        const limit = parseDate(item.endDate, endDate);
        let count = 0;
        while (current.getTime() <= limit.getTime() && count < 120) {
          pushEvent({ id: `earn-${item.id ?? idx}-${count}`, type: 'earn', date: current, label: item.label || `Earn ${idx + 1}`, amount });
          current = new Date(current.getTime() + step * msInDay);
          count += 1;
        }
      });

      (safePlan.manual || []).forEach((item, idx) => {
        const amount = Number(item.amount) || 0;
        if (!(amount > 0)) return;
        const direction = item.direction === 'inflow' ? 1 : -1;
        const impact = item.collateralImpact;
        const collateralDelta = impact === 'increase' ? amount : impact === 'decrease' ? -amount : 0;
        pushEvent({
          id: `manual-${item.id ?? idx}`,
          type: 'manual',
          date: item.date || today,
          label: item.label || `Evento ${idx + 1}`,
          amount: amount * direction,
          collateralDelta,
        });
      });

      events.sort((a, b) => a.date.getTime() - b.date.getTime());

      let outstanding = loanAmount;
      let collateral = Math.max(0, totalCollateralValue);
      let cumulativeCash = 0;
      let accruedInterest = 0;
      let totalEarn = 0;
      let totalCost = 0;
      let minNet = Number.POSITIVE_INFINITY;
      const timeline = [];
      const alerts = [];
      const fundingGaps = [];
      const scenarioSummaries = {};
      scenarioKeys.forEach((key) => { scenarioSummaries[key] = { last: 0, net: loanAmount, max: 0 }; });

      let lastDate = today;
      const addSnapshot = (event) => {
        const day = Math.max(0, Math.round((event.date.getTime() - today.getTime()) / msInDay));
        const scenarioStats = {};
        scenarioKeys.forEach((key) => {
          const shock = Number(baseScenarios[key]) || 0;
          const adjustedCollateral = collateral * (1 + shock);
          const ltv = adjustedCollateral > 0 ? outstanding / adjustedCollateral : (outstanding > 0 ? Number.POSITIVE_INFINITY : 0);
          scenarioStats[key] = ltv;
          scenarioSummaries[key].last = ltv;
          scenarioSummaries[key].net = cumulativeCash - accruedInterest;
          scenarioSummaries[key].max = Math.max(scenarioSummaries[key].max || 0, Number.isFinite(ltv) ? ltv : 0);
          if (ltv >= autoRepayLtv) {
            alerts.push(`Escenario ${key} supera auto-liquidación (${(autoRepayLtv * 100).toFixed(0)}%) en día ${day}.`);
          } else if (ltv >= marginCallLtv) {
            alerts.push(`Escenario ${key} supera margin call (${(marginCallLtv * 100).toFixed(0)}%) en día ${day}.`);
          }
        });
        const netBalance = cumulativeCash - accruedInterest;
        minNet = Math.min(minNet, netBalance);
        if (netBalance < 0) {
          const existingGap = fundingGaps.find((gap) => gap.day === day);
          if (!existingGap) fundingGaps.push({ day, date: event.date.toISOString().slice(0, 10), net: netBalance });
        }
        timeline.push({
          id: event.id,
          type: event.type,
          label: event.label,
          date: event.date.toISOString().slice(0, 10),
          day,
          amount: event.amount,
          interestAccrued: accruedInterest,
          cashCumulative: cumulativeCash,
          netBalance,
          outstanding,
          scenarioStats,
          totalCost,
          totalEarn,
        });
        lastDate = event.date;
      };

      events.forEach((event) => {
        const deltaDays = Math.max(0, Math.round((event.date.getTime() - lastDate.getTime()) / msInDay));
        if (deltaDays > 0 && outstanding > 0) {
          const interest = outstanding * (Math.pow(1 + apr / 365, deltaDays) - 1);
          accruedInterest += interest;
          totalCost += interest;
        }
        cumulativeCash += event.amount || 0;
        if ((event.amount || 0) >= 0) totalEarn += event.amount || 0; else totalCost += Math.abs(event.amount || 0);
        if (event.principalImpact) {
          outstanding = Math.max(0, outstanding - Number(event.principalImpact));
        }
        if (event.interestPortion) {
          const payInterest = Math.min(accruedInterest, Number(event.interestPortion) || 0);
          accruedInterest = Math.max(0, accruedInterest - payInterest);
        }
        if (event.collateralDelta) {
          collateral = Math.max(0, collateral + Number(event.collateralDelta));
        }
        addSnapshot(event);
      });

      if (endDate.getTime() > lastDate.getTime() && outstanding > 0) {
        const deltaDays = Math.max(0, Math.round((endDate.getTime() - lastDate.getTime()) / msInDay));
        if (deltaDays > 0) {
          const interest = outstanding * (Math.pow(1 + apr / 365, deltaDays) - 1);
          accruedInterest += interest;
          totalCost += interest;
        }
        addSnapshot({ id: 'carry', type: 'carry', label: 'Interés acumulado', date: endDate, amount: 0 });
      }

      if (outstanding > 0 || accruedInterest > 0) {
        const payoff = -(outstanding + accruedInterest);
        cumulativeCash += payoff;
        totalCost += Math.abs(payoff);
        outstanding = 0;
        accruedInterest = 0;
        addSnapshot({ id: 'closure', type: 'closure', label: 'Pago final proyectado', date: endDate, amount: payoff });
      }

      const chartData = timeline.map((item) => ({ day: item.day, cost: item.totalCost, earn: item.totalEarn, balance: item.netBalance }));
      const uniqueAlerts = [...new Set(alerts)];
      const scenarioLabel = { base: 'Escenario base', bear: 'Escenario bajista', bull: 'Escenario alcista' }[activeScenario] || activeScenario;

      return {
        timeline,
        chartData,
        alerts: uniqueAlerts,
        fundingGaps,
        netBalanceFinal: timeline.length ? timeline[timeline.length - 1].netBalance : loanAmount,
        minNetBalance: Number.isFinite(minNet) ? minNet : loanAmount,
        lastOutstanding: outstanding,
        scenarioSummaries,
        scenarioShocks: baseScenarios,
        activeScenario,
        ltvForGauge: timeline.length ? timeline[timeline.length - 1].scenarioStats[activeScenario] : (totalCollateralValue > 0 ? loanAmount / totalCollateralValue : 0),
        scenarioLabel,
      };
    }

    function BenchmarkCeFiDeFi({
      config,
      onChange,
      fmt,
      currency,
      rate,
      loanAmount,
      chosenAPR,
      daysUntilRepay,
      scenarioName,
      cashflowNet,
      defaultMatrix,
    }) {
      const safeConfig = config || {};
      const matrix = safeConfig.rateMatrix || [];
      const strategies = safeConfig.strategies || [];
      const termDays = Math.max(1, daysUntilRepay || 0);
      const baseAmount = loanAmount || 0;

      const updateRate = (id, patch) => onChange((prev) => ({
        ...prev,
        rateMatrix: (prev?.rateMatrix || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
      }));

      const removeRate = (id) => onChange((prev) => ({
        ...prev,
        rateMatrix: (prev?.rateMatrix || []).filter((item) => item.id !== id),
      }));

      const addRate = () => {
        const nextId = `rate-${Math.max(0, ...matrix.map((item) => Number(String(item.id).replace(/\D/g, '')) || 0)) + 1}`;
        onChange((prev) => ({
          ...prev,
          rateMatrix: [...(prev?.rateMatrix || []), { id: nextId, platform: 'Plataforma', product: 'Producto', type: 'APR', value: chosenAPR || 0 }],
        }));
      };

      const updateStrategy = (id, patch) => onChange((prev) => ({
        ...prev,
        strategies: (prev?.strategies || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
      }));

      const removeStrategy = (id) => onChange((prev) => ({
        ...prev,
        strategies: (prev?.strategies || []).filter((item) => item.id !== id),
      }));

      const addStrategy = () => {
        const nextId = `strategy-${Math.max(0, ...strategies.map((item) => Number(String(item.id).replace(/\D/g, '')) || 0)) + 1}`;
        const loanRate = matrix[0]?.id || defaultMatrix?.[0]?.id || 'loan-default';
        const yieldRate = matrix[1]?.id || defaultMatrix?.[1]?.id || 'yield-default';
        onChange((prev) => ({
          ...prev,
          strategies: [...(prev?.strategies || []), {
            id: nextId,
            label: `Estrategia ${nextId}`,
            lenderRateId: loanRate,
            yieldRateId: yieldRate,
            apr: matrix.find((r) => r.id === loanRate)?.value ?? chosenAPR ?? 0,
            apy: matrix.find((r) => r.id === yieldRate)?.value ?? 0,
            feesIn: 0,
            feesOut: 0,
            riskCeFiLender: true,
            riskDeFiYield: false,
            riskNewProtocol: false,
          }],
        }));
      };

      const findRate = (id) => matrix.find((item) => item.id === id);

      const computeResult = (strategy) => {
        const amount = strategy.amountOverride != null ? Number(strategy.amountOverride) || 0 : baseAmount;
        const apr = Number.isFinite(strategy.apr) ? strategy.apr : (findRate(strategy.lenderRateId)?.value || 0);
        const apy = Number.isFinite(strategy.apy) ? strategy.apy : (findRate(strategy.yieldRateId)?.value || 0);
        const fees = (Number(strategy.feesIn) || 0) + (Number(strategy.feesOut) || 0);
        const interestPaid = amount > 0 ? amount * (Math.pow(1 + apr / 365, termDays) - 1) : 0;
        const interestEarned = amount > 0 ? amount * (Math.pow(1 + apy / 365, termDays) - 1) : 0;
        const spread = interestEarned - interestPaid - fees;
        const netPct = amount > 0 ? Math.max(-0.99, spread / amount) : 0;
        const annualized = termDays > 0 ? (Math.pow(1 + netPct, 365 / termDays) - 1) : 0;
        const riskPenalty = (strategy.riskDeFiYield ? 0.02 : 0) + (strategy.riskNewProtocol ? 0.03 : 0) + (strategy.riskCeFiLender ? 0 : 0.01);
        return {
          spread,
          annualized,
          adjustedAnnual: annualized - riskPenalty,
          amount,
          apr,
          apy,
          fees,
          interestPaid,
          interestEarned,
        };
      };

      const results = strategies.map((strategy) => ({ strategy, metrics: computeResult(strategy) }));
      const ranked = [...results].sort((a, b) => (b.metrics.adjustedAnnual || 0) - (a.metrics.adjustedAnnual || 0));

      const formatMoney = (value) => fmt(value * rate, currency);

      return (
        <Card title="Benchmark CeFi vs. CeFi/DeFi">
          <div className="space-y-6 text-xs">
            <div className="rounded-2xl border border-neutral-200 bg-neutral-50/70 px-4 py-3 space-y-1 text-neutral-600">
              <div>Monto base: {formatMoney(baseAmount)} · APR préstamo: {(chosenAPR * 100).toFixed(2)}% · Plazo: {termDays} días</div>
              <div>Escenario cashflow: {scenarioName || 'Base'} · Saldo neto proyectado: {cashflowNet != null ? formatMoney(cashflowNet) : '—'}</div>
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Matriz de tasas</h4>
                <button className="nx-btn nx-btn-sm" onClick={addRate}>Agregar tasa</button>
              </div>
              <div className="space-y-2">
                {matrix.length === 0 && <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-neutral-500">Define al menos una tasa APR/APY para combinar estrategias.</div>}
                {matrix.map((item) => (
                  <div key={item.id} className="grid grid-cols-1 md:grid-cols-5 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                    <input type="text" value={item.platform || ''} onChange={(e) => updateRate(item.id, { platform: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1" placeholder="Plataforma" />
                    <input type="text" value={item.product || ''} onChange={(e) => updateRate(item.id, { product: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1" placeholder="Producto" />
                    <select value={item.type || 'APR'} onChange={(e) => updateRate(item.id, { type: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1">
                      <option value="APR">APR</option>
                      <option value="APY">APY</option>
                    </select>
                    <input type="number" step="0.01" value={item.value ?? 0} onChange={(e) => updateRate(item.id, { value: Number(e.target.value) })} className="rounded-full border border-neutral-300 px-2 py-1 text-right" />
                    <div className="flex items-end justify-end">
                      <button className="text-rose-600 hover:underline" onClick={() => removeRate(item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Estrategias</h4>
                <button className="nx-btn nx-btn-sm" onClick={addStrategy}>Agregar estrategia</button>
              </div>
              <div className="space-y-3">
                {strategies.length === 0 && <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-neutral-500">Crea combinaciones préstamo → rendimiento para medir el spread neto.</div>}
                {strategies.map((strategy) => {
                  const metrics = computeResult(strategy);
                  const position = ranked.findIndex((item) => item.strategy.id === strategy.id) + 1;
                  return (
                    <div key={strategy.id} className="grid grid-cols-1 md:grid-cols-6 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                      <div className="md:col-span-2 space-y-1">
                        <input type="text" value={strategy.label || ''} onChange={(e) => updateStrategy(strategy.id, { label: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1" placeholder="Nombre de la estrategia" />
                        <select value={strategy.lenderRateId || ''} onChange={(e) => updateStrategy(strategy.id, { lenderRateId: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1">
                          <option value="">Sin tasa</option>
                          {matrix.map((item) => <option key={`lend-${item.id}`} value={item.id}>{item.platform} · {item.product}</option>)}
                        </select>
                        <input type="number" step="0.01" value={strategy.apr ?? metrics.apr} onChange={(e) => updateStrategy(strategy.id, { apr: Number(e.target.value) })} className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right" />
                      </div>
                      <div className="space-y-1">
                        <select value={strategy.yieldRateId || ''} onChange={(e) => updateStrategy(strategy.id, { yieldRateId: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1">
                          <option value="">Sin tasa</option>
                          {matrix.map((item) => <option key={`yield-${item.id}`} value={item.id}>{item.platform} · {item.product}</option>)}
                        </select>
                        <input type="number" step="0.01" value={strategy.apy ?? metrics.apy} onChange={(e) => updateStrategy(strategy.id, { apy: Number(e.target.value) })} className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right" />
                        <input type="number" step="100" placeholder="Monto personalizado" value={strategy.amountOverride ?? ''} onChange={(e) => updateStrategy(strategy.id, { amountOverride: e.target.value === '' ? null : Number(e.target.value) })} className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right" />
                      </div>
                      <div className="space-y-1">
                        <input type="number" step="0.01" value={strategy.feesIn ?? 0} onChange={(e) => updateStrategy(strategy.id, { feesIn: Number(e.target.value) })} className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right" placeholder="Fee entrada" />
                        <input type="number" step="0.01" value={strategy.feesOut ?? 0} onChange={(e) => updateStrategy(strategy.id, { feesOut: Number(e.target.value) })} className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right" placeholder="Fee salida" />
                        <div className="text-[11px] text-neutral-500">Spread: {formatMoney(metrics.spread)}</div>
                      </div>
                      <div className="space-y-1 text-[11px] text-neutral-600">
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskCeFiLender !== false} onChange={(e) => updateStrategy(strategy.id, { riskCeFiLender: e.target.checked })} /> Custodia CeFi</label>
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskDeFiYield === true} onChange={(e) => updateStrategy(strategy.id, { riskDeFiYield: e.target.checked })} /> Yield DeFi</label>
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskNewProtocol === true} onChange={(e) => updateStrategy(strategy.id, { riskNewProtocol: e.target.checked })} /> Smart contract nuevo</label>
                      </div>
                      <div className="space-y-1">
                        <div className={`text-sm font-semibold ${metrics.spread >= 0 ? 'text-emerald-600' : 'text-rose-600'}`}>{formatMoney(metrics.spread)}</div>
                        <div className="text-[11px] text-neutral-500">Anualizado: {(metrics.annualized * 100).toFixed(2)}%</div>
                        <div className="text-[11px] text-neutral-500">Ajustado riesgo: {(metrics.adjustedAnnual * 100).toFixed(2)}%</div>
                      </div>
                      <div className="flex items-end justify-between gap-2">
                        <div className="text-sm font-semibold text-neutral-700">#{position || '–'}</div>
                        <button className="text-rose-600 hover:underline" onClick={() => removeStrategy(strategy.id)}>Eliminar</button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            {ranked.length > 0 && (
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                {ranked.slice(0, 3).map((item, idx) => (
                  <div key={`rank-${item.strategy.id}`} className="rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                    <div className="text-[11px] uppercase text-neutral-400">Top {idx + 1}</div>
                    <div className="text-sm font-semibold text-neutral-700">{item.strategy.label || item.strategy.id}</div>
                    <div className="text-[11px] text-neutral-500">Spread ajustado {(item.metrics.adjustedAnnual * 100).toFixed(2)}%</div>
                    <div className="text-[11px] text-neutral-500">Spread neto {formatMoney(item.metrics.spread)}</div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </Card>
      );
    }

    // UI helpers (pocas funciones y tono visual)
    function KPI({ title, value, subtle, tone, variant }) {
      const toneCls = tone === 'ok' ? 'text-emerald-200' : tone === 'danger' ? 'text-rose-200' : '';
      const baseCls = variant === 'button' ? 'nx-kpi-btn' : 'bg-white nx-kpi';
      return (
        <div className={`relative overflow-hidden rounded-2xl p-4 shadow-sm transition-transform duration-200 ${baseCls} cursor-pointer`} role="button" aria-label={title}>
          <div className={`text-xs uppercase tracking-wide text-center ${variant==='button' ? 'text-white/80' : 'text-neutral-500'}`}>{title}</div>
          <div className={`mt-1 text-xl font-bold text-center ${toneCls}`}>{value}</div>
          {subtle && <div className={`text-xs mt-1 text-center ${variant==='button' ? 'text-white/70' : 'text-neutral-500'}`}>{subtle}</div>}
        </div>
      );
    }
    function Card({ title, children }) {
      return (
        <div className="rounded-2xl bg-white p-5 shadow-sm nx-card">
          <div className="mb-3 flex items-center justify-between"><h3 className="text-lg font-semibold">{title}</h3></div>
          {children}
        </div>
      );
    }
    function Field({ label, children, align = "left", className = "" }) {
      const centered = align === "center";
      return (
        <label className={`${centered ? "flex flex-col items-center text-center gap-2 text-sm" : "block text-sm"} ${className}`}>
          <div className={`text-neutral-700 font-medium ${centered ? "text-base" : "mb-1"}`}>{label}</div>
          {children}
        </label>
      );
    }
    function NumberParam({ label, value, onChange, step = 1, ringClass = "focus:ring-blue-700" }) {
      return (
        <Field label={label}>
          <input type="number" value={value} step={step} onChange={(e) => onChange(Number(e.target.value))} className={`w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 ${ringClass} text-right`} />
        </Field>
      );
    }
    function Th({ children }) { return (<th className="px-3 py-2 text-center align-middle text-xs font-semibold">{children}</th>); }
    function Td({ children, align = "left", ...rest }) {
      const alignClass = align === "right" ? "text-right" : align === "center" ? "text-center" : "text-left";
      return (<td {...rest} className={`px-3 py-2 align-middle ${alignClass}`}>{children}</td>);
    }
    function Pill({ label, value, tone = "neutral" }) {
      const tones = {
        ok: "bg-emerald-50 text-emerald-700 border-emerald-200",
        warn: "bg-amber-50 text-amber-700 border-amber-200",
        danger: "bg-rose-50 text-rose-700 border-rose-200",
        neutral: "bg-neutral-50 text-neutral-700 border-neutral-200",
      };
      return (
        <div className={`rounded-2xl border px-4 py-3 flex items-center justify-between gap-4 ${tones[tone]}`}>
          <span className="text-sm font-medium text-neutral-600">{label}</span>
          <span className="text-base font-semibold">{value}</span>
        </div>
      );
    }
    function Line({ label, value, muted = false, tone }) {
      const color = tone === "ok" ? "text-emerald-700" : tone === "warn" ? "text-amber-700" : tone === "danger" ? "text-rose-700" : "";
      return (
        <div className="flex items-center justify-between gap-4">
          <span className={`text-sm ${muted ? "text-neutral-400" : "text-neutral-700"}`}>{label}</span>
          <span className={`text-sm font-medium ${color}`}>{value}</span>
        </div>
      );
    }

    function LTVGauge({ value, zones = [], markers = [] }) {
      const clamp = (v) => Math.max(0, Math.min(1, Number.isFinite(v) ? v : 0));
      const size = 300;
      const center = size / 2;
      const radius = center - 18;
      const ring = 34;
      const startAngle = (Math.PI * 5) / 4; // 225°
      const sweepAngle = (Math.PI * 3) / 2; // 270°
      const angleFor = (pct) => startAngle - clamp(pct) * sweepAngle;
      const polarPoint = (pct, r = radius) => {
        const angle = angleFor(pct);
        return {
          angle,
          x: center + r * Math.cos(angle),
          y: center + r * Math.sin(angle),
        };
      };
      const describeArc = (from, to, r = radius) => {
        const start = polarPoint(from, r);
        const end = polarPoint(to, r);
        const delta = (to - from) * sweepAngle;
        const largeArc = Math.abs(delta) > Math.PI ? 1 : 0;
        const sweepFlag = delta <= 0 ? 1 : 0;
        return `M ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${end.x} ${end.y}`;
      };
      const palette = ['#22c55e', '#facc15', '#fb923c', '#ef4444'];
      const normalizedZones = (zones.length ? zones : [
        { label: 'Óptimo', max: 0.2, color: palette[0], legend: '≤20%', tone: 'ok' },
        { label: 'Estable', max: 0.7, color: palette[1], legend: '≤70%', tone: 'warn' },
        { label: 'A riesgo', max: 0.85, color: palette[2], legend: '≤85%', tone: 'danger' },
        { label: 'Crítico', max: 1, color: palette[3], legend: '> límite', tone: 'danger' },
      ]).map((zone, idx, arr) => ({
        label: zone.label ?? `Zona ${idx + 1}`,
        color: zone.color ?? palette[Math.min(idx, palette.length - 1)],
        legend: zone.legend ?? `≤${Math.round(clamp(zone.max) * 100)}%`,
        rawTo: clamp(zone.max),
        tone: zone.tone ?? (idx === 0 ? 'ok' : idx === arr.length - 1 ? 'danger' : 'warn'),
      }))
        .filter((zone, idx, arr) => zone.rawTo > 0 && idx === arr.findIndex((z) => z.rawTo === zone.rawTo))
        .sort((a, b) => a.rawTo - b.rawTo);
      const gap = 0.005;
      const segments = normalizedZones.reduce((acc, zone) => {
        const prev = acc[acc.length - 1];
        const from = prev ? prev.rawTo : 0;
        const capped = Math.min(Math.max(zone.rawTo, from), 1);
        if (capped <= from) return acc;
        const to = Math.max(Math.min(1, capped), from + 0.002);
        acc.push({ from, to, rawTo: capped, color: zone.color, label: zone.label, legend: zone.legend, tone: zone.tone });
        return acc;
      }, []);
      const valuePct = clamp(value);
      const pointerAngle = angleFor(valuePct);
      const pointerTip = polarPoint(valuePct, radius - ring * 0.25);
      const pointerBaseRadius = 22;
      const baseLeft = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle + Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle + Math.PI / 2),
      };
      const baseRight = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle - Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle - Math.PI / 2),
      };
      const pointerPath = `M ${baseLeft.x} ${baseLeft.y} L ${pointerTip.x} ${pointerTip.y} L ${baseRight.x} ${baseRight.y} Z`;
      const statusZone = segments.find((seg) => valuePct <= seg.rawTo + 1e-6) ?? segments[segments.length - 1];
      const status = statusZone?.label ?? '—';
      const toneKey = statusZone?.tone ?? 'warn';
      const toneStyles = {
        ok: { text: 'text-emerald-500', bg: 'bg-emerald-100/70', dot: '#22c55e' },
        warn: { text: 'text-amber-500', bg: 'bg-amber-100/70', dot: '#facc15' },
        danger: { text: 'text-rose-500', bg: 'bg-rose-100/70', dot: '#ef4444' },
      };
      const statusTone = toneStyles[toneKey] ?? toneStyles.warn;
      const thresholds = (markers.length ? markers : [])
        .map((marker, idx) => ({ pct: clamp(marker.pct), label: marker.label ?? `${Math.round(clamp(marker.pct) * 100)}%`, key: `marker-${idx}` }))
        .filter((marker, idx, arr) => marker.pct > 0 && marker.pct <= 1 && idx === arr.findIndex((m) => m.pct === marker.pct));
      const tickOuter = radius + 6;
      const tickInner = radius - ring + 4;
      return (
        <div className="flex flex-col items-center">
          <svg viewBox={`0 0 ${size} ${size}`} className="w-full max-w-[340px]">
            <defs>
              <radialGradient id="gaugeDepth" cx="50%" cy="50%" r="60%">
                <stop offset="0%" stopColor="#ffffff" stopOpacity="0.98" />
                <stop offset="100%" stopColor="#e2e8f0" stopOpacity="0.55" />
              </radialGradient>
              <linearGradient id="gaugeRing" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.12)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <filter id="pointerShadow" x="-40%" y="-40%" width="180%" height="180%">
                <feDropShadow dx="0" dy="3" stdDeviation="3" floodColor="rgba(15,23,42,0.35)" />
              </filter>
              <filter id="ringShadow" x="-30%" y="-30%" width="160%" height="160%">
                <feDropShadow dx="0" dy="8" stdDeviation="12" floodColor="rgba(15,23,42,0.18)" floodOpacity="0.5" />
              </filter>
            </defs>
            <g filter="url(#ringShadow)">
              <circle cx={center} cy={center} r={radius + 10} fill="#f8fafc" />
              <circle cx={center} cy={center} r={radius + 6} fill="url(#gaugeRing)" opacity="0.65" />
              <circle cx={center} cy={center} r={radius - ring * 0.15} fill="url(#gaugeDepth)" />
            </g>
            {segments.map((seg, idx) => {
              const isFirst = idx === 0;
              const isLast = idx === segments.length - 1;
              const from = seg.from + (isFirst ? 0 : gap);
              const to = Math.max(from + 0.001, seg.to - (isLast ? 0 : gap));
              return (
                <path
                  key={`${seg.label}-${idx}`}
                  d={describeArc(from, to, radius)}
                  stroke={seg.color}
                  strokeWidth={ring}
                  strokeLinecap="round"
                  fill="none"
                  opacity="0.95"
                />
              );
            })}
            {thresholds.map((t) => {
              const outer = polarPoint(t.pct, tickOuter);
              const inner = polarPoint(t.pct, tickInner);
              const labelAnchor = t.pct < 0.33 ? 'start' : t.pct > 0.67 ? 'end' : 'middle';
              const labelOffset = t.pct > 0.67 ? -10 : t.pct < 0.33 ? 10 : 0;
              const labelY = t.pct < 0.2 ? inner.y + 16 : t.pct > 0.8 ? inner.y + 16 : inner.y - 10;
              return (
                <g key={t.key ?? t.label}>
                  <line x1={outer.x} y1={outer.y} x2={inner.x} y2={inner.y} stroke="#0f172a" strokeOpacity="0.18" strokeWidth="2" strokeLinecap="round" />
                  <text
                    x={inner.x + labelOffset}
                    y={labelY}
                    textAnchor={labelAnchor}
                    className="fill-slate-500"
                    style={{ fontSize: '10px', fontWeight: 600 }}
                  >
                    {t.label}
                  </text>
                </g>
              );
            })}
            <g filter="url(#pointerShadow)">
              <path d={pointerPath} fill="#0f172a" opacity="0.92" />
            </g>
            <circle cx={center} cy={center} r={18} fill="#1e3a8a" stroke="#f8fafc" strokeWidth="5" />
            <circle cx={center} cy={center} r={6} fill="#f1f5f9" />
            <text
              x={center}
              y={center + 6}
              textAnchor="middle"
              className="fill-slate-700"
              style={{ fontWeight: 700, fontSize: '24px' }}
            >
              {`${(valuePct * 100).toFixed(1)}%`}
            </text>
            <text
              x={center}
              y={center + 34}
              textAnchor="middle"
              className="fill-slate-400"
              style={{ fontWeight: 600, fontSize: '11px', letterSpacing: '0.16em' }}
            >
              Salud
            </text>
          </svg>
          <div className={`mt-4 flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold ${statusTone.bg} ${statusTone.text}`}>
            <span className="inline-flex h-2.5 w-2.5 rounded-full" style={{ backgroundColor: statusTone.dot }} />
            {status}
          </div>
          <div className="mt-5 grid grid-cols-2 gap-3 text-[11px] font-semibold text-neutral-600">
            {segments.map((seg, idx) => (
              <div key={`${seg.label}-${idx}-legend`} className="flex items-center gap-2">
                <span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: seg.color }} />
                <span>{seg.legend ?? seg.label}</span>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function TrendChart({ data, currency, rate }) {
      if (!data || data.length < 2) {
        return <div className="text-sm text-neutral-500">Configura un monto y una fecha de repago para visualizar la trayectoria.</div>;
      }
      const maxVal = Math.max(...data.flatMap(d => [d.cost, d.earn, d.balance]));
      if (!(maxVal > 0)) {
        return <div className="text-sm text-neutral-500">Agrega colateral o préstamo para generar la proyección.</div>;
      }
      const width = 420;
      const height = 220;
      const paddingX = 36;
      const paddingY = 28;
      const step = data.length > 1 ? (width - paddingX * 2) / (data.length - 1) : 0;
      const baseY = height - paddingY;
      const scaleY = (value) => {
        if (!maxVal) return baseY;
        const ratio = value / maxVal;
        const usableHeight = height - paddingY * 1.6;
        return baseY - ratio * usableHeight;
      };
      const pathFor = (key) => data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point[key]);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPath = data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point.balance);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPathClosed = `${areaPath} L ${paddingX + step * (data.length - 1)} ${baseY} L ${paddingX} ${baseY} Z`;
      const tickIndexes = Array.from(new Set([0, Math.floor(data.length / 2), data.length - 1])).filter(i => i >= 0 && i < data.length);
      const ticks = tickIndexes.map((i) => ({ x: paddingX + i * step, label: `Día ${Math.round(data[i].day)}` }));
      const colors = { balance: '#8b5cf6', cost: '#60a5fa', earn: '#34d399' };
      const lastPoint = data[data.length - 1];
      return (
        <div>
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full">
            <defs>
              <linearGradient id="chartBg" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.08)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <linearGradient id="balanceArea" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#a855f7" stopOpacity="0.35" />
                <stop offset="100%" stopColor="#a855f7" stopOpacity="0.05" />
              </linearGradient>
            </defs>
            <rect x="0" y="0" width={width} height={height} fill="url(#chartBg)" opacity="1" rx="18" />
            <path d={`M ${paddingX} ${baseY} L ${paddingX + step * (data.length - 1)} ${baseY}`} stroke="rgba(148,163,184,0.35)" strokeWidth="1.5" strokeLinecap="round" />
            <path d={areaPathClosed} fill="url(#balanceArea)" opacity="0.6" />
            <path d={pathFor('balance')} stroke={colors.balance} strokeWidth="3" fill="none" strokeLinecap="round" />
            <path d={pathFor('cost')} stroke={colors.cost} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="4 4" />
            <path d={pathFor('earn')} stroke={colors.earn} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="6 4" />
            {ticks.map((tick) => (
              <g key={tick.label} transform={`translate(${tick.x}, ${baseY + 14})`}>
                <circle cx="0" cy="0" r="2" fill="rgba(148,163,184,0.5)" />
                <text textAnchor="middle" dy="12" className="fill-slate-400" style={{ fontSize: '10px', letterSpacing: '0.04em' }}>{tick.label}</text>
              </g>
            ))}
            {data.map((point, index) => {
              const x = paddingX + index * step;
              return (
                <circle key={`dot-${index}`} cx={x} cy={scaleY(point.balance)} r="3.5" fill="#8b5cf6" stroke="#fff" strokeWidth="1.5" />
              );
            })}
          </svg>
          <div className="mt-3 flex flex-wrap gap-4 text-xs font-semibold text-neutral-500">
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.balance }} />Balance neto</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.cost }} />Costo (interés)</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.earn }} />Earn estimado</span>
          </div>
          <div className="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3 text-sm">
            <div className="rounded-xl bg-blue-50/70 px-3 py-2">
              <div className="text-xs uppercase text-blue-600">Interés total</div>
              <div className="font-semibold text-blue-700">{fmt(lastPoint.cost * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-emerald-50/70 px-3 py-2">
              <div className="text-xs uppercase text-emerald-600">Earn acumulado</div>
              <div className="font-semibold text-emerald-700">{fmt(lastPoint.earn * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-violet-50/70 px-3 py-2">
              <div className="text-xs uppercase text-violet-600">Balance estimado</div>
              <div className="font-semibold text-violet-700">{fmt(lastPoint.balance * rate, currency)}</div>
            </div>
          </div>
        </div>
      );
    }

    function CollateralBreakdownCard({ breakdown, currency, rate, totalCollateral, totalMaxBorrow, overallLTV, target, marginCall, autoRepay, capLowCost, lowCostHeadroom }) {
      if (!breakdown || breakdown.length === 0) {
        return <div className="text-sm text-neutral-500">Activa al menos un activo como colateral y asigna un préstamo para visualizar la distribución.</div>;
      }
      const toneColors = { ok: '#34d399', warn: '#facc15', danger: '#fb7185' };
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      let accShare = 0;
      const segments = breakdown.map((item) => {
        const start = accShare;
        accShare += item.share;
        const end = Math.min(1, accShare);
        return { ...item, start, end };
      });
      const gradientStops = segments.map((seg) => `${toneColors[seg.tone]} ${(seg.start * 100).toFixed(2)}% ${(seg.end * 100).toFixed(2)}%`).join(', ');
      const covered = Math.min(1, accShare);
      const gradient = `conic-gradient(${gradientStops}${covered < 1 ? `, rgba(148,163,184,0.2) ${(covered * 100).toFixed(2)}% 100%` : ''})`;
      const overallTone = overallLTV <= target ? 'ok' : overallLTV <= marginCall ? 'warn' : 'danger';
      const overallLabel = overallTone === 'ok' ? 'Sano' : overallTone === 'warn' ? 'Observar' : 'En riesgo';
      const overallToneClass = overallTone === 'ok' ? 'text-emerald-600' : overallTone === 'warn' ? 'text-amber-600' : 'text-rose-600';
      return (
        <div className="flex flex-col gap-5">
          <div className="flex flex-wrap items-center justify-center gap-6">
            <div className="relative h-40 w-40 rounded-full shadow-inner" style={{ background: gradient }}>
              <div className="absolute inset-8 rounded-full bg-white shadow flex flex-col items-center justify-center text-center">
                <span className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">LTV actual</span>
                <span className="text-xl font-bold text-neutral-900">{(overallLTV * 100).toFixed(1)}%</span>
                <span className={`mt-1 text-xs font-semibold ${overallToneClass}`}>{overallLabel}</span>
              </div>
            </div>
            <div className="space-y-2 text-sm text-neutral-600">
              <div><span className="font-semibold text-neutral-800">Colateral</span>: {fmt(totalCollateral * rate, currency)}</div>
              <div><span className="font-semibold text-neutral-800">Tope por LTVs</span>: {fmt(totalMaxBorrow * rate, currency)}</div>
              <div><span className="font-semibold text-neutral-800">Cap Low-Cost</span>: {fmt(capLowCost * rate, currency)} ({lowCostHeadroom > 0 ? `${fmt(lowCostHeadroom * rate, currency)} libres` : 'sin margen'})</div>
              <div className="flex flex-wrap gap-3 text-xs text-neutral-500 pt-1">
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.ok }} />Sano ≤ {Math.round(target * 100)}%</span>
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.warn }} />Observar ≤ {Math.round(marginCall * 100)}%</span>
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.danger }} />Riesgo ≥ {Math.round(autoRepay * 100)}%</span>
              </div>
            </div>
          </div>
          <div className="space-y-3">
            {breakdown.map((item) => {
              const usagePct = Math.max(0, Math.min(100, item.usageVsCap * 100));
              const badgeLabel = item.tone === 'ok' ? 'Sano' : item.tone === 'warn' ? 'Vigilar' : 'Crítico';
              return (
                <div key={item.id} className="rounded-2xl border border-neutral-200 p-3">
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className="text-sm font-semibold text-neutral-800">{item.name}</div>
                      <div className="text-xs text-neutral-500">{item.ticker || '—'} · Colateral {fmt(item.value * rate, currency)} ({(item.share * 100).toFixed(1)}%)</div>
                      <div className="text-xs text-neutral-500">LTV tope {item.policyPct.toFixed(0)}% · Cap {fmt(item.maxBorrowForAsset * rate, currency)}</div>
                    </div>
                    <span className={`rounded-full px-2 py-1 text-xs font-semibold ${toneBadge[item.tone]}`}>{badgeLabel}</span>
                  </div>
                  <div className="mt-3 h-2.5 w-full overflow-hidden rounded-full bg-neutral-200">
                    <div className="h-full" style={{ width: `${usagePct.toFixed(1)}%`, backgroundColor: toneColors[item.tone], transition: 'width .3s ease' }} />
                  </div>
                  <div className="mt-1 flex justify-between text-[11px] text-neutral-500">
                    <span>Uso: {fmt(item.allocatedLoan * rate, currency)}</span>
                    <span>Tope: {fmt(item.maxBorrowForAsset * rate, currency)}</span>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Tests mínimos (no tocar a menos que estén mal) + 2 nuevos
    function approxEq(a, b, eps = 1e-6) { return Math.abs(a - b) <= eps; }
    function runDevTests() {
      try {
        const nexo = PLATFORM_CONFIGS.nexo;
        const binance = PLATFORM_CONFIGS.binance;
        const youhodler = PLATFORM_CONFIGS.youhodler;
        const ledn = PLATFORM_CONFIGS.ledn;
        console.assert(approxEq((nexo.policies?.targetLtv ?? 0), 0.20), 'Test1: Target LTV Nexo 20%');
        console.assert(approxEq((nexo.ltvByTicker?.BTC ?? 0), 0.50), 'Test2: LTV BTC Nexo 50%');
        console.assert((binance.earnAprTop?.BNB ?? 0) >= 0.05, 'Test3: Earn BNB Binance ≥5%');
        console.assert(GLOBAL_COINGECKO_IDS.BTC === 'bitcoin', 'Test4: CoinGecko BTC');
        console.assert(PLATFORM_IDS.includes('nexo') && PLATFORM_IDS.includes('binance'), 'Test5: plataformas registradas');
        const lowCostNexo = nexo.apr?.lowCostEligibleTiers || [];
        console.assert(lowCostNexo.includes('Gold') && lowCostNexo.includes('Platinum'), 'Test6: Low-Cost tiers Nexo');
        const defaultTicker = (nexo.defaultAssets?.[0]?.ticker || '').toUpperCase();
        console.assert(defaultTicker === 'BTC', 'Test7: default asset BTC');
        console.assert((youhodler?.policies?.targetLtv ?? 0) >= 0.7, 'Test8: Target LTV YouHodler ≥70%');
        console.assert((ledn?.ltvByTicker?.BTC ?? 0) <= 0.7, 'Test9: LTV BTC Ledn ≤70%');
        console.assert(PLATFORM_IDS.includes('youhodler') && PLATFORM_IDS.includes('ledn'), 'Test10: nuevas plataformas registradas');
        console.log('%cSanity tests OK', 'color:green');
      } catch (e) { console.error('Sanity tests failed', e); }
    }
    if (typeof window !== 'undefined') { try { runDevTests(); } catch (_) {} }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SimuladorPrestamos />);
  </script>
</body>
</html>
