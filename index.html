<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Préstamos / Plataforma</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    body{
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--theme-surface-soft, linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%));
      transition:background .3s ease;
    }
    /* Paleta y estilos base */
    .nx-gradient{background:linear-gradient(135deg,#0b1e4b 0%,#1b44a6 50%,#2052c1 100%)}
    .bn-gradient{background:linear-gradient(135deg,#1f2937 0%,#f59e0b 45%,#f97316 100%)}
    .yh-gradient{background:linear-gradient(135deg,#0ea5e9 0%,#2563eb 55%,#38bdf8 100%)}
    .ld-gradient{background:linear-gradient(135deg,#0f766e 0%,#14b8a6 55%,#2dd4bf 100%)}
    .nx-card{border:1px solid var(--theme-card-border); box-shadow:var(--theme-card-shadow); border-radius:1.5rem; transition:box-shadow .3s ease,border-color .3s ease;}
    .nx-kpi{border:1px solid var(--theme-kpi-border); transition:border-color .3s ease;}
    .nx-kpi-btn{
      position:relative;
      border-radius:1.25rem;
      background:var(--theme-kpi-bg);
      color:#fff;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-shadow);
      transition:transform .25s ease, box-shadow .25s ease, filter .25s ease;
    }
    .nx-kpi-btn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 -18px 30px rgba(0,0,0,0.18);
      pointer-events:none;
    }
    .nx-kpi-btn:hover{
      transform:translateY(-3px);
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-hover-shadow);
    }
    .nx-kpi-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-active-shadow);
    }
    .nx-btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:.4rem;
      background:var(--theme-btn-bg);
      color:var(--theme-btn-text);
      border-radius:1rem;
      padding:.55rem 1.35rem;
      font-weight:600;
      border:1px solid var(--theme-btn-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn:hover{
      transform:translateY(-2px);
      filter:brightness(1.03);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-hover-shadow);
    }
    .nx-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-active-shadow);
    }
    .nx-btn-ghost{
      background:var(--theme-ghost-bg);
      color:var(--theme-ghost-text);
      border:1px solid var(--theme-ghost-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn-ghost:hover{
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-hover-shadow);
    }
    .nx-btn-ghost:active{
      transform:translateY(1px);
    }
    .nx-btn-sm{padding:.35rem .95rem; font-size:.8rem; border-radius:.9rem;}
  </style>
</head>
<body data-theme="nexo">
  <div id="root"></div>

  <!-- React 18 UMD fijas -->
  <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

  <!-- (si usás JSX en el navegador) Babel Standalone fijo -->
  <script src="https://unpkg.com/@babel/standalone@7.23.9/babel.min.js"></script>

  <script type="text/babel" data-presets="env,react">
    // Simulador de Préstamos – HTML portable (sin build, con CDN)
    const DEFAULT_EXCHANGE_RATES = {
      USD: 1,
      USDT: 1,
      ARS: 1000,
      EUR: 0.92,
      GBP: 0.79,
      CAD: 1.36,
      AUD: 1.53,
      CHF: 0.89,
      JPY: 157,
      BRL: 5.0,
      MXN: 17.2,
    };

    const THEME_TOKENS = Object.freeze({
      nexo: {
        '--theme-surface-soft': 'linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%)',
        '--theme-card-border': '#dfe6ff',
        '--theme-card-shadow': '0 12px 30px rgba(16,35,90,.08)',
        '--theme-kpi-border': '#e6eaf5',
        '--theme-kpi-bg': 'linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(8,20,66,0.35)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(12,28,84,0.42)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(10,24,70,0.3)',
        '--theme-btn-bg': 'linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%)',
        '--theme-btn-text': '#fff',
        '--theme-btn-border': 'rgba(255,255,255,0.22)',
        '--theme-btn-shadow': '0 14px 28px rgba(15,33,90,0.32)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(12,30,88,0.4)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(10,26,70,0.25)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%)',
        '--theme-ghost-text': '#1e2f67',
        '--theme-ghost-border': 'rgba(30,64,175,0.16)',
        '--theme-ghost-shadow': '0 10px 22px rgba(15,30,70,0.12)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(15,30,70,0.18)',
      },
      binance: {
        '--theme-surface-soft': 'linear-gradient(180deg,#fff6e6 0%,#ffedcc 100%)',
        '--theme-card-border': 'rgba(251,191,36,0.35)',
        '--theme-card-shadow': '0 12px 30px rgba(146,64,14,0.15)',
        '--theme-kpi-border': 'rgba(253,224,71,0.45)',
        '--theme-kpi-bg': 'linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(146,64,14,0.32)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(124,45,18,0.42)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(124,45,18,0.3)',
        '--theme-btn-bg': 'linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%)',
        '--theme-btn-text': '#fff7db',
        '--theme-btn-border': 'rgba(255,255,255,0.24)',
        '--theme-btn-shadow': '0 14px 28px rgba(146,64,14,0.28)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(124,45,18,0.35)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(124,45,18,0.25)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#fff7e6 100%)',
        '--theme-ghost-text': '#7c2d12',
        '--theme-ghost-border': 'rgba(217,119,6,0.3)',
        '--theme-ghost-shadow': '0 10px 22px rgba(146,64,14,0.16)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(124,45,18,0.22)',
      },
      youhodler: {
        '--theme-surface-soft': 'linear-gradient(180deg,#e0f2ff 0%,#f5fbff 100%)',
        '--theme-card-border': 'rgba(59,130,246,0.25)',
        '--theme-card-shadow': '0 12px 30px rgba(30,64,175,0.12)',
        '--theme-kpi-border': 'rgba(125,211,252,0.6)',
        '--theme-kpi-bg': 'linear-gradient(155deg,#0ea5e9 0%,#2563eb 45%,#3b82f6 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(14,165,233,0.28)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(14,116,233,0.34)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(14,116,233,0.24)',
        '--theme-btn-bg': 'linear-gradient(155deg,#0284c7 0%,#2563eb 50%,#38bdf8 100%)',
        '--theme-btn-text': '#f0f9ff',
        '--theme-btn-border': 'rgba(255,255,255,0.3)',
        '--theme-btn-shadow': '0 14px 28px rgba(14,116,233,0.28)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(14,116,233,0.35)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(14,116,233,0.25)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#e0f2ff 100%)',
        '--theme-ghost-text': '#0f172a',
        '--theme-ghost-border': 'rgba(59,130,246,0.22)',
        '--theme-ghost-shadow': '0 10px 22px rgba(37,99,235,0.12)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(37,99,235,0.18)',
      },
      ledn: {
        '--theme-surface-soft': 'linear-gradient(180deg,#f3f4f6 0%,#ffffff 100%)',
        '--theme-card-border': 'rgba(15,118,110,0.22)',
        '--theme-card-shadow': '0 12px 30px rgba(15,118,110,0.12)',
        '--theme-kpi-border': 'rgba(45,212,191,0.45)',
        '--theme-kpi-bg': 'linear-gradient(155deg,#0f766e 0%,#14b8a6 45%,#2dd4bf 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(15,118,110,0.26)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(13,148,136,0.32)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(15,118,110,0.22)',
        '--theme-btn-bg': 'linear-gradient(155deg,#0f766e 0%,#14b8a6 50%,#2dd4bf 100%)',
        '--theme-btn-text': '#ecfeff',
        '--theme-btn-border': 'rgba(255,255,255,0.28)',
        '--theme-btn-shadow': '0 14px 28px rgba(13,148,136,0.25)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(13,148,136,0.32)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(13,148,136,0.24)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#ecfdf5 100%)',
        '--theme-ghost-text': '#0f172a',
        '--theme-ghost-border': 'rgba(45,212,191,0.22)',
        '--theme-ghost-shadow': '0 10px 22px rgba(15,118,110,0.12)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(15,118,110,0.18)',
      },
    });

    const DEFAULT_THEME = 'nexo';

    const ensureThemeStyles = () => {
      if (typeof document === 'undefined') return;
      if (document.getElementById('simulator-theme-styles')) return;

      const makeRule = (selector, tokens) => {
        const body = Object.entries(tokens)
          .map(([name, value]) => `  ${name}: ${value};`)
          .join('\n');
        return `${selector} {\n${body}\n}`;
      };

      const styleTag = document.createElement('style');
      styleTag.id = 'simulator-theme-styles';

      const defaultTokens = THEME_TOKENS[DEFAULT_THEME] || {};
      const themeRules = Object.entries(THEME_TOKENS)
        .map(([themeKey, tokens]) => makeRule(`html[data-theme="${themeKey}"], body[data-theme="${themeKey}"]`, tokens))
        .join('\n\n');

      styleTag.textContent = [makeRule(':root', defaultTokens), themeRules]
        .filter(Boolean)
        .join('\n\n');
      document.head.appendChild(styleTag);
    };

    const applyTheme = (themeName = DEFAULT_THEME) => {
      if (typeof document === 'undefined') return DEFAULT_THEME;
      ensureThemeStyles();
      const resolved = THEME_TOKENS[themeName] ? themeName : DEFAULT_THEME;
      document.body.setAttribute('data-theme', resolved);
      document.documentElement.setAttribute('data-theme', resolved);
      return resolved;
    };

    ensureThemeStyles();
    applyTheme(DEFAULT_THEME);

    const SUPPORTED_CURRENCIES = [
      { code: "USD", label: "USD — Dólar estadounidense" },
      { code: "USDT", label: "USDT — Tether" },
      { code: "ARS", label: "ARS — Peso argentino" },
      { code: "EUR", label: "EUR — Euro" },
      { code: "GBP", label: "GBP — Libra esterlina" },
      { code: "CAD", label: "CAD — Dólar canadiense" },
      { code: "AUD", label: "AUD — Dólar australiano" },
      { code: "CHF", label: "CHF — Franco suizo" },
      { code: "JPY", label: "JPY — Yen japonés" },
      { code: "BRL", label: "BRL — Real brasileño" },
      { code: "MXN", label: "MXN — Peso mexicano" },
    ];
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    const ALERT_TONE_STYLES = Object.freeze({
      info: { border: 'border-sky-200', bg: 'bg-sky-50', text: 'text-sky-700' },
      warn: { border: 'border-amber-200', bg: 'bg-amber-50', text: 'text-amber-700' },
      danger: { border: 'border-rose-200', bg: 'bg-rose-50', text: 'text-rose-700' },
    });

    const normalizeAlertItems = (alerts) => {
      if (!Array.isArray(alerts)) return [];
      return alerts
        .map((item, idx) => {
          if (!item) return null;
          if (typeof item === 'string') {
            return { id: `alert-${idx}`, tone: 'info', message: item };
          }
          if (typeof item === 'object') {
            const rawMessage = item.message;
            const message = typeof rawMessage === 'string'
              ? rawMessage
              : rawMessage != null
                ? String(rawMessage)
                : '';
            if (!message) return null;
            return {
              id: item.id || `alert-${idx}`,
              tone: item.tone || 'info',
              message,
            };
          }
          return null;
        })
        .filter(Boolean);
    };

    const LIVE_REFRESH_SECONDS = 5;
    const FX_REFRESH_MINUTES = 30;
    const BINANCE_INTEREST_REFRESH_MS = 60 * 1000;

    const DEFAULT_LOCALE = 'es-AR';

    const MS_IN_HOUR = 60 * 60 * 1000;
    const HOURS_IN_YEAR = 365 * 24;
    const annualToHourly = (apr) => {
      const normalized = Number(apr);
      if (!Number.isFinite(normalized) || normalized <= 0) return 0;
      return Math.pow(1 + normalized, 1 / HOURS_IN_YEAR) - 1;
    };

    const coerceDateValue = (value) => {
      if (!value) return null;
      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value;
      }
      if (typeof value === 'number') {
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return null;
        const date = new Date(trimmed);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      return null;
    };
    
    function computeCashflowProjections(plan = {}, ctx = {}) {
      const payments = Array.isArray(plan?.payments) ? plan.payments : [];
      const earns = Array.isArray(plan?.earns) ? plan.earns : [];
      const manual = Array.isArray(plan?.manual) ? plan.manual : [];

      const normalizeTicker = (value) => (typeof value === 'string' ? value.trim().toUpperCase() : '');
      const loanAmount = Math.max(0, Number(ctx?.loanAmount) || 0);
      const baseCollateral = Math.max(0, Number(ctx?.totalCollateralValue) || 0);

      const loanByTickerRaw = ctx?.loanByTicker || {};
      const loanByTicker = Object.entries(loanByTickerRaw).reduce((acc, [ticker, amount]) => {
        const key = normalizeTicker(ticker);
        const value = Math.max(0, Number(amount) || 0);
        if (!key || !(value > 0)) return acc;
        acc[key] = (acc[key] || 0) + value;
        return acc;
      }, {});
      const hasLoanByTicker = Object.keys(loanByTicker).length > 0;
      const outstandingByTicker = hasLoanByTicker
        ? Object.keys(loanByTicker).reduce((acc, key) => {
            acc[key] = loanByTicker[key];
            return acc;
          }, {})
        : {};

      const sumMap = (map) => Object.values(map).reduce((acc, value) => {
        const num = Number(value);
        return acc + (Number.isFinite(num) && num > 0 ? num : 0);
      }, 0);

      const applyProportionalReduction = (map, amount) => {
        if (!(amount > 0)) return 0;
        const keys = Object.keys(map);
        if (!keys.length) return 0;
        const totalBefore = sumMap(map);
        if (!(totalBefore > 0)) return 0;
        let applied = 0;
        keys.forEach((key) => {
          const current = Math.max(0, Number(map[key]) || 0);
          if (!(current > 0)) return;
          const share = current / totalBefore;
          const delta = Math.min(current, amount * share);
          if (delta > 0) {
            map[key] = current - delta;
            applied += delta;
          }
        });
        return applied;
      };

      const getPaymentAmount = (payment) => {
        const raw = payment?.amount ?? payment?.principal;
        const value = Number(raw);
        return Number.isFinite(value) && value > 0 ? value : 0;
      };

      const sumPositive = (items, prop) => items.reduce((acc, item) => {
        const raw = Number(item?.[prop]);
        return acc + (Number.isFinite(raw) && raw > 0 ? raw : 0);
      }, 0);

      const scheduledPayments = payments.reduce((acc, payment) => acc + getPaymentAmount(payment), 0);
      const scheduledPrincipal = scheduledPayments;
      const scheduledInterest = 0;
      const plannedEarns = sumPositive(earns, 'amount');
      let earnApplied = 0;

      const scheduledPrincipalByTicker = {};
      let generalPrincipal = 0;
      payments.forEach((payment) => {
        const principal = getPaymentAmount(payment);
        if (!(principal > 0)) return;
        const key = normalizeTicker(payment?.ticker);
        if (key && hasLoanByTicker) {
          scheduledPrincipalByTicker[key] = (scheduledPrincipalByTicker[key] || 0) + principal;
        } else {
          generalPrincipal += principal;
        }
      });

      if (hasLoanByTicker) {
        Object.entries(scheduledPrincipalByTicker).forEach(([key, amount]) => {
          const current = Math.max(0, Number(outstandingByTicker[key]) || 0);
          const applied = Math.min(current, amount);
          outstandingByTicker[key] = current - applied;
          if (amount > applied) {
            generalPrincipal += amount - applied;
          }
        });
        if (generalPrincipal > 0) {
          applyProportionalReduction(outstandingByTicker, generalPrincipal);
        }
        if (plannedEarns > 0) {
          earnApplied = applyProportionalReduction(outstandingByTicker, plannedEarns);
        }
      }

      let outstandingAfterPlan;
      if (hasLoanByTicker) {
        outstandingAfterPlan = Math.max(0, sumMap(outstandingByTicker));
      } else {
        const outstandingBeforeEarn = Math.max(0, loanAmount - scheduledPayments);
        if (plannedEarns > 0 && outstandingBeforeEarn > 0) {
          earnApplied = Math.min(outstandingBeforeEarn, plannedEarns);
        }
        outstandingAfterPlan = Math.max(0, outstandingBeforeEarn - earnApplied);
      }
      const netOutstandingAfterPlan = Math.max(0, outstandingAfterPlan + scheduledInterest);
      const projectedFinalPayoff = netOutstandingAfterPlan;
      const totalCost = Math.max(0, scheduledPayments + projectedFinalPayoff);

      const collateralDeltaPlanned = manual.reduce((acc, item) => {
        const amount = Number(item?.amount);
        if (!Number.isFinite(amount) || amount <= 0) return acc;
        if (item?.collateralImpact === 'increase') return acc + amount;
        if (item?.collateralImpact === 'decrease') return acc - amount;
        return acc;
      }, 0);
      const collateralAfterPlan = Math.max(0, baseCollateral + collateralDeltaPlanned);

      const denominator = collateralAfterPlan > 0 ? collateralAfterPlan : baseCollateral;
      const ltvForGauge = denominator > 0
        ? netOutstandingAfterPlan / denominator
        : (netOutstandingAfterPlan > 0 ? 1 : 0);

      const scenarioLabel = typeof plan?.activeScenario === 'string' ? plan.activeScenario : 'base';

      const alerts = [];
      const thresholds = {
        target: Number(ctx?.targetLtv),
        margin: Number(ctx?.marginCallLtv),
        auto: Number(ctx?.autoRepayLtv),
      };
      if (Number.isFinite(thresholds.auto) && thresholds.auto > 0 && ltvForGauge >= thresholds.auto) {
        alerts.push({
          id: 'auto-liquidation',
          tone: 'danger',
          message: 'El plan proyectado supera el LTV de auto-liquidación.',
        });
      } else if (Number.isFinite(thresholds.margin) && thresholds.margin > 0 && ltvForGauge >= thresholds.margin) {
        alerts.push({
          id: 'margin-call',
          tone: 'warn',
          message: 'El plan proyectado alcanza el LTV de margin call.',
        });
      } else if (Number.isFinite(thresholds.target) && thresholds.target > 0 && ltvForGauge > thresholds.target) {
        alerts.push({
          id: 'target',
          tone: 'info',
          message: 'El plan queda por encima del LTV objetivo.',
        });
      }

      return {
        scheduledPrincipal,
        scheduledInterest,
        projectedFinalPayoff,
        totalCost,
        outstandingAfterPlan: netOutstandingAfterPlan,
        outstandingByTicker: hasLoanByTicker ? outstandingByTicker : undefined,
        collateralDeltaPlanned,
        collateralAfterPlan,
        ltvForGauge: Number.isFinite(ltvForGauge) ? Math.max(0, ltvForGauge) : 0,
        scenarioLabel,
        alerts,
        netBalanceFinal: Math.max(0, netOutstandingAfterPlan - Math.max(0, plannedEarns - earnApplied)),
        loanByTicker: hasLoanByTicker ? loanByTicker : undefined,
        scheduledPrincipalByTicker: Object.keys(scheduledPrincipalByTicker).length > 0 ? scheduledPrincipalByTicker : undefined,
      };
    }

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null };
        this.handleRetry = this.handleRetry.bind(this);
      }

      static getDerivedStateFromError(error) {
        return { error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('Error al renderizar la app', error, errorInfo);
      }

      handleRetry() {
        this.setState({ error: null });
      }

      render() {
        if (this.state.error) {
          return (
            <div className="min-h-screen w-full bg-neutral-100 flex items-center justify-center px-6 py-12">
              <div className="max-w-lg w-full rounded-3xl bg-white shadow-xl border border-red-100 p-8 text-center space-y-4">
                <div className="text-2xl font-semibold text-red-600">Algo salió mal</div>
                <p className="text-sm text-neutral-600">
                  No pudimos renderizar el simulador. Revisa la consola para más detalles o intenta recargar la página.
                </p>
                <pre className="text-xs text-left whitespace-pre-wrap bg-red-50 text-red-700 rounded-2xl p-4 overflow-auto max-h-48">
                  {String(this.state.error?.message || this.state.error)}
                </pre>
                <button onClick={this.handleRetry} className="nx-btn">Reintentar</button>
              </div>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const formatDecimal = (value, {
      minimumFractionDigits = 2,
      maximumFractionDigits = 2,
    } = {}) => {
      if (!Number.isFinite(value)) return '—';
      return new Intl.NumberFormat(DEFAULT_LOCALE, {
        minimumFractionDigits,
        maximumFractionDigits,
      }).format(value);
    };

    const formatCurrency = (value, currency = 'USD') => {
      if (!Number.isFinite(value)) return '—';
      try {
        return new Intl.NumberFormat(DEFAULT_LOCALE, {
          style: 'currency',
          currency,
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(value);
      } catch (error) {
        const formatted = new Intl.NumberFormat(DEFAULT_LOCALE, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(value);
        return `${currency} ${formatted}`;
      }
    };

    const formatPercent = (value, {
      minimumFractionDigits = 2,
      maximumFractionDigits = 2,
    } = {}) => {
      if (!Number.isFinite(value)) return '—';
      const formatted = new Intl.NumberFormat(DEFAULT_LOCALE, {
        style: 'percent',
        minimumFractionDigits,
        maximumFractionDigits,
      }).format(value);
      return formatted.replace(/\s*%/, '%');
    };

    const parseLocaleNumber = (value) => {
      if (value == null) return NaN;
      if (typeof value === 'number') return value;
      let str = `${value}`.trim();
      if (!str) return NaN;
      let sign = 1;
      if (str.startsWith('+') || str.startsWith('-')) {
        sign = str.startsWith('-') ? -1 : 1;
        str = str.slice(1);
      }
      const cleaned = str.replace(/[^0-9.,]/g, '');
      if (!cleaned) return NaN;
      const lastSep = Math.max(cleaned.lastIndexOf(','), cleaned.lastIndexOf('.'));
      let integerPart = cleaned;
      let fractionPart = '';
      if (lastSep >= 0) {
        integerPart = cleaned.slice(0, lastSep);
        fractionPart = cleaned.slice(lastSep + 1);
      }
      const intDigits = integerPart.replace(/[^0-9]/g, '');
      const fracDigits = fractionPart.replace(/[^0-9]/g, '');
      const normalized = intDigits + (fracDigits ? `.${fracDigits}` : '');
      if (!normalized) return NaN;
      const num = Number(normalized);
      return Number.isFinite(num) ? num * sign : NaN;
    };

    const inferFractionDigits = (step, fallback = 2) => {
      if (step === 'any' || step == null) return Math.max(2, fallback);
      const numeric = typeof step === 'number' ? step : Number(step);
      if (!Number.isFinite(numeric) || numeric <= 0) return Math.max(2, fallback);
      const str = numeric.toString();
      if (str.includes('e-')) {
        const match = str.match(/e-(\d+)/i);
        if (match) return Math.max(Number.parseInt(match[1], 10) || fallback, 2);
      }
      const decimals = str.includes('.') ? str.split('.')[1].length : 0;
      return Math.max(decimals, 2, fallback);
    };

    const formatNumberForInput = (value, decimals = 2) => {
      if (!Number.isFinite(value)) return '';
      const safeDecimals = Math.max(decimals, 2);
      return formatDecimal(value, {
        minimumFractionDigits: Math.min(2, safeDecimals),
        maximumFractionDigits: safeDecimals,
      });
    };
    const FX_SYMBOLS = SUPPORTED_CURRENCIES.filter((c) => !['USD', 'USDT'].includes(c.code)).map((c) => c.code);

    const PLATFORM_CONFIGS = {
      nexo: {
        id: "nexo",
        name: "Nexo",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        theme: "nexo",
        classes: {
          header: "nx-gradient",
          accent: "text-blue-100/90",
          focusRing: "focus:ring-blue-700",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          NEXO: "nexo",
          USDT: "tether",
          USDC: "usd-coin",
          ADA: "cardano",
          ALGO: "algorand",
          XRP: "ripple",
          BNB: "binancecoin",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.50,
          ETH: 0.50,
          NEXO: 0.15,
          XRP: 0.30,
          BNB: 0.30,
          USDC: 0.50,
          USDT: 0.50,
          ADA: 0.50,
          ALGO: 0.30,
          SOL: 0.30,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.07,
          USDC: 0.12,
          USDT: 0.12,
          NEXO: 0.04,
          XRP: 0.07,
          BNB: 0.07,
          SOL: 0.07,
          ADA: 0.02,
          ALGO: 0.02,
        },
        policies: {
          targetLtv: 0.20,
          marginCallLtv: 0.70,
          autoRepayLtv: 0.8333333333,
          minBalancePerks: 5000,
          defaultLtv: 0.25,
        },
        apr: {
          base: 0.189,
          standard: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.139,
            Platinum: 0.109,
          },
          discounted: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.059,
            Platinum: 0.029,
          },
          earlyRuleDays: 45,
          earlyAPR: 0.189,
          lowCostEligibleTiers: ["Gold", "Platinum"],
          baseTier: "Base",
        },
        loyalty: {
          tokenTicker: "NEXO",
          baseLabel: "Base",
          belowMinimumLabel: "Sin perks",
          tierThresholds: [
            { label: "Platinum", minRatio: 0.10 },
            { label: "Gold", minRatio: 0.05 },
            { label: "Silver", minRatio: 0.01 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (oficial)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Loyalty Tier",
          ratioLabel: "ratio NEXO",
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 7, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 15000,
          repayInDays: 120,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 8, price: 2100, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 25000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 6000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "USD Coin", ticker: "USDC", qty: 4000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 5000, price: 0.38, priceAuto: false, useAsCollateral: false },
            { id: 7, name: "Algorand", ticker: "ALGO", qty: 8000, price: 0.15, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "nexo_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Nexo.",
        },
      },
      binance: {
        id: "binance",
        name: "Binance",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        theme: "binance",
        classes: {
          header: "bn-gradient",
          accent: "text-amber-100/90",
          focusRing: "focus:ring-amber-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          BNB: "binancecoin",
          USDT: "tether",
          USDC: "usd-coin",
          BUSD: "binance-usd",
          ADA: "cardano",
          ALGO: "algorand",
          XRP: "ripple",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.65,
          ETH: 0.60,
          BNB: 0.65,
          USDT: 0.80,
          USDC: 0.80,
          BUSD: 0.85,
          ADA: 0.46,
          ALGO: 0.45,
          XRP: 0.50,
          SOL: 0.50,
        },
        earnAprTop: {
          BTC: 0.03,
          ETH: 0.03,
          BNB: 0.05,
          USDT: 0.06,
          USDC: 0.06,
          BUSD: 0.06,
          ADA: 0.02,
          ALGO: 0.02,
          XRP: 0.02,
          SOL: 0.03,
        },
        borrowRates: {
          ADA: {
            label: "Cardano (ADA)",
            annual: 0.0507,
            hourly: annualToHourly(0.0507),
            netAnnual: 0.0476,
            adjustmentAnnual: 0.0031,
            loanAsset: "ADA",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          ALGO: {
            label: "Algorand (ALGO)",
            annual: 0.0507,
            hourly: annualToHourly(0.0507),
            netAnnual: 0.0415,
            adjustmentAnnual: 0.0092,
            loanAsset: "ALGO",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          BNB: {
            label: "BNB (BNB)",
            annual: 0.0612,
            hourly: annualToHourly(0.0612),
            loanAsset: "BNB",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          BTC: {
            label: "Bitcoin (BTC)",
            annual: 0.0725,
            hourly: annualToHourly(0.0725),
            loanAsset: "BTC",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          ETH: {
            label: "Ethereum (ETH)",
            annual: 0.0684,
            hourly: annualToHourly(0.0684),
            loanAsset: "ETH",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          USDT: {
            label: "Tether (USDT)",
            annual: 0.0595,
            hourly: annualToHourly(0.0595),
            loanAsset: "USDT",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          USDC: {
            label: "USD Coin (USDC)",
            annual: 0.0589,
            hourly: annualToHourly(0.0589),
            loanAsset: "USDC",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          BUSD: {
            label: "Binance USD (BUSD)",
            annual: 0.055,
            hourly: annualToHourly(0.055),
            loanAsset: "BUSD",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          XRP: {
            label: "XRP (XRP)",
            annual: 0.063,
            hourly: annualToHourly(0.063),
            loanAsset: "XRP",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          SOL: {
            label: "Solana (SOL)",
            annual: 0.071,
            hourly: annualToHourly(0.071),
            loanAsset: "SOL",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
        },
        diagnosticSources: {
          bip: [
            {
              code: "BIP-0007",
              title: "Ajustes dinámicos de tasa según oferta y demanda",
              url: "https://www.binance.com/es/support/faq/2c6d3b9ebf964d8d9d9f1f5f0cbe0f91",
            },
            {
              code: "BIP-0014",
              title: "Descuentos por nivel VIP y uso de BNB como colateral",
              url: "https://www.binance.com/es/support/faq/765dc83a4a65426aa4c0f0bd274b614e",
            },
            {
              code: "BIP-0021",
              title: "Política de liquidación y rangos de LTV para Binance Loans",
              url: "https://www.binance.com/es/support/faq/b46c1bb43d1e4b08a9a1811f667ac90a",
            },
          ],
        },
        policies: {
          targetLtv: 0.75,
          marginCallLtv: 0.85,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.0507,
          standard: {
            "Estándar": 0.0507,
            "VIP 1": 0.045,
            "VIP 2": 0.04,
            "VIP 3": 0.035,
          },
          discounted: {
            "Estándar": 0.0507,
            "VIP 1": 0.042,
            "VIP 2": 0.037,
            "VIP 3": 0.032,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.0507,
          lowCostEligibleTiers: ["VIP 2", "VIP 3"],
          baseTier: "Estándar",
        },
        ltvHealth: {
          zones: [
            { label: "Saludable", max: 0.75, color: "#22c55e", legend: "0-75%", tone: "ok" },
            { label: "Riesgo medio", max: 0.85, color: "#f97316", legend: "75-85%", tone: "warn" },
            { label: "Alto riesgo", max: 1, color: "#ef4444", legend: "≥85%", tone: "danger" },
          ],
          markers: [
            { pct: 0.85, label: "Margin call" },
            { pct: 0.90, label: "Auto-liquidación" },
          ],
        },
        loanLedger: {
          ADA: {
            originalPrincipal: 10300,
            outstanding: 10471.01,
            interestAccrued: 171.01,
            annualRate: 0.0503283,
            netAnnualRate: 0.0484,
            initialLtv: 0.46,
          },
          ALGO: {
            originalPrincipal: 7026,
            outstanding: 1201.78,
            interestAccrued: 69.58,
            annualRate: 0.0503283,
            netAnnualRate: 0.045,
            initialLtv: 0.45,
            payments: [
              { id: "algo-payment-1", amount: 5890.97, date: "2024-03-12", note: "Pago capital" },
              { id: "algo-payment-2", amount: 2.77, date: "2024-03-12", note: "Pago interés" },
            ],
          },
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "BNB", ticker: "BNB", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "BUSD", ticker: "BUSD", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 8, name: "XRP", ticker: "XRP", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 9, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
          binanceBorrowTicker: "ADA",
          loanRequests: [
            { id: "loan-bin-ada", ticker: "ADA", amount: 10471.01 },
            { id: "loan-bin-algo", ticker: "ALGO", amount: 1201.78 },
          ],
        },
        previewSnapshot: {
          loanAmount: 11672.79,
          repayInDays: 90,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
            binanceBorrowTicker: "ADA",
            loanRequests: [
              { id: "loan-preview-ada", ticker: "ADA", amount: 10471.01 },
              { id: "loan-preview-algo", ticker: "ALGO", amount: 1201.78 },
            ],
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.5, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 4, price: 2050, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "BNB", ticker: "BNB", qty: 120, price: 230, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 1500, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "BUSD", ticker: "BUSD", qty: 800, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 70000, price: 0.61, priceAuto: false, useAsCollateral: true },
            { id: 7, name: "XRP", ticker: "XRP", qty: 3000, price: 0.52, priceAuto: false, useAsCollateral: false },
            { id: 8, name: "Algorand", ticker: "ALGO", qty: 65800, price: 0.182, priceAuto: false, useAsCollateral: true },
          ],
        },
        exportPrefix: "binance_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Binance (Loans Flexible).",
        },
      },
      youhodler: {
        id: "youhodler",
        name: "YouHodler",
        tagline: "Multi-colateral y planes de tasas basados en stablecoins.",
        theme: "youhodler",
        classes: {
          header: "yh-gradient",
          accent: "text-sky-100/90",
          focusRing: "focus:ring-sky-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          LTC: "litecoin",
          SOL: "solana",
          ADA: "cardano",
          USDT: "tether",
          USDC: "usd-coin",
        },
        ltvByTicker: {
          BTC: 0.90,
          ETH: 0.90,
          LTC: 0.85,
          SOL: 0.80,
          ADA: 0.75,
          USDT: 0.90,
          USDC: 0.90,
        },
        earnAprTop: {
          BTC: 0.05,
          ETH: 0.05,
          LTC: 0.04,
          SOL: 0.05,
          ADA: 0.03,
          USDT: 0.12,
          USDC: 0.12,
        },
        policies: {
          targetLtv: 0.70,
          marginCallLtv: 0.85,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.12,
          standard: {
            "Classic": 0.12,
            "Premium": 0.10,
            "VIP": 0.08,
          },
          discounted: {
            "Classic": 0.11,
            "Premium": 0.09,
            "VIP": 0.07,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.12,
          lowCostEligibleTiers: ["Premium", "VIP"],
          baseTier: "Classic",
        },
        loyalty: {
          tokenTicker: "USDT",
          baseLabel: "Classic",
          belowMinimumLabel: "Classic",
          tierThresholds: [
            { label: "VIP", minRatio: 0.50 },
            { label: "Premium", minRatio: 0.25 },
          ],
          models: [
            { id: "vsTotal", label: "vs total (stablecoins)" },
          ],
          kpiLabel: "Plan activo",
          ratioLabel: "ratio stablecoins",
        },
        ltvHealth: {
          zones: [
            { label: "Seguro", max: 0.7, color: "#38bdf8", legend: "≤70%", tone: "ok" },
            { label: "Vigilar", max: 0.85, color: "#f97316", legend: "70-85%", tone: "warn" },
            { label: "Crítico", max: 1, color: "#ef4444", legend: "≥85%", tone: "danger" },
          ],
          markers: [
            { pct: 0.70, label: "Nivel óptimo" },
            { pct: 0.85, label: "Margin call" },
            { pct: 0.9, label: "Auto-liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "Litecoin", ticker: "LTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Solana", ticker: "SOL", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsTotal",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 18000,
          repayInDays: 75,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, EUR: 0.94 },
            loyaltyModel: "vsTotal",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.9, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 10, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "Tether", ticker: "USDT", qty: 20000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 15000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "Litecoin", ticker: "LTC", qty: 300, price: 65, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Solana", ticker: "SOL", qty: 400, price: 55, priceAuto: false, useAsCollateral: true },
            { id: 7, name: "Cardano", ticker: "ADA", qty: 6000, price: 0.38, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "youhodler_dashboard",
        disclaimers: {
          finePrint: "* Tasas aproximadas según planes Classic/Premium/VIP publicados por YouHodler (referencial).",
        },
      },
      ledn: {
        id: "ledn",
        name: "Ledn",
        tagline: "Créditos sobre BTC/USDC con métricas conservadoras y B2B.",
        theme: "ledn",
        classes: {
          header: "ld-gradient",
          accent: "text-teal-100/90",
          focusRing: "focus:ring-teal-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          WBTC: "wrapped-bitcoin",
          USDC: "usd-coin",
          USDT: "tether",
          LTC: "litecoin",
        },
        ltvByTicker: {
          BTC: 0.70,
          ETH: 0.65,
          WBTC: 0.70,
          USDC: 0.90,
          USDT: 0.85,
          LTC: 0.60,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.06,
          USDC: 0.07,
          USDT: 0.07,
          WBTC: 0.06,
          LTC: 0.04,
        },
        policies: {
          targetLtv: 0.55,
          marginCallLtv: 0.75,
          autoRepayLtv: 0.85,
          minBalancePerks: 1000,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.119,
          standard: {
            "Standard": 0.119,
            "Silver": 0.109,
            "Gold": 0.089,
          },
          discounted: {
            "Standard": 0.109,
            "Silver": 0.099,
            "Gold": 0.079,
          },
          earlyRuleDays: 60,
          earlyAPR: 0.119,
          lowCostEligibleTiers: ["Gold"],
          baseTier: "Standard",
        },
        loyalty: {
          tokenTicker: "BTC",
          baseLabel: "Standard",
          belowMinimumLabel: "Standard",
          tierThresholds: [
            { label: "Gold", minRatio: 0.50 },
            { label: "Silver", minRatio: 0.30 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (BTC dominante)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Plan de tasa",
          ratioLabel: "ratio BTC",
        },
        ltvHealth: {
          zones: [
            { label: "Conservador", max: 0.55, color: "#2dd4bf", legend: "≤55%", tone: "ok" },
            { label: "Observación", max: 0.75, color: "#fbbf24", legend: "55-75%", tone: "warn" },
            { label: "Crítico", max: 1, color: "#ef4444", legend: "≥75%", tone: "danger" },
          ],
          markers: [
            { pct: 0.55, label: "Zona Ledn" },
            { pct: 0.75, label: "Margin call" },
            { pct: 0.85, label: "Liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "Wrapped BTC", ticker: "WBTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Litecoin", ticker: "LTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 9000,
          repayInDays: 150,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, CAD: 1.34 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 1.2, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Wrapped BTC", ticker: "WBTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "USD Coin", ticker: "USDC", qty: 15000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 5000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "Ethereum", ticker: "ETH", qty: 4, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Litecoin", ticker: "LTC", qty: 600, price: 65, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "ledn_dashboard",
        disclaimers: {
          finePrint: "* Tasas Ledn orientativas basadas en publicaciones públicas (pueden cambiar sin previo aviso).",
        },
      },
    };

    const FEATURE_IMPROVEMENT_TASKS = {
      common: [
        {
          id: "scenario-engine",
          title: "Motor de escenarios de estrés",
          description: "Permitir shocks de precio (%) o volatilidad intradía y graficar cómo evolucionan LTV, margen y liquidaciones.",
        },
        {
          id: "alerting",
          title: "Alertas multi-canal",
          description: "Configurar umbrales de LTV/ratio que disparen alertas por email, Telegram o webhook para reaccionar antes de margin call.",
        },
        {
          id: "benchmarking",
          title: "Benchmark CeFi vs DeFi",
          description: "Comparar automáticamente las tasas del simulador con protocolos DeFi (Aave, Spark) para detectar oportunidades de arbitraje.",
        },
        {
          id: "cashflow-planning",
          title: "Planificador de cashflow",
          description: "Agregar calendario de pagos parciales, rollovers y cálculo de costo efectivo mensual (CEM) por escenario.",
        },
      ],
      byPlatform: {
        nexo: [
          {
            id: "nexo-booster",
            title: "Simular Booster & convert",
            description: "Incluir loops de crédito + compra automática de cripto para ver impacto de Booster y conversión instantánea.",
          },
          {
            id: "nexo-insurance",
            title: "Visor de seguro Nexo",
            description: "Agregar panel que estime cobertura de seguro y auditorías (Armanino) frente a colateral disponible.",
          },
        ],
        binance: [
          {
            id: "binance-vip",
            title: "Modelo VIP dinámico",
            description: "Calcular automáticamente upgrade de nivel VIP considerando volumen spot/futuros y mostrar APR objetivo.",
          },
          {
            id: "binance-crossmargin",
            title: "Cruce con Cross-Margin",
            description: "Permitir importar posiciones de margin/futuros para medir riesgo agregado y requirements de colateral.",
          },
        ],
        youhodler: [
          {
            id: "yh-turbo",
            title: "Turbocharge loops",
            description: "Simular iteraciones Turbocharge (auto-loop) para ver cuántas rondas maximizan el capital sin liquidar.",
          },
          {
            id: "yh-stable-buckets",
            title: "Buckets de stablecoins",
            description: "Segregar stablecoins por plan (Classic/Premium/VIP) y optimizar qué cantidad conviene bloquear para subir de nivel.",
          },
        ],
        ledn: [
          {
            id: "ledn-b2b",
            title: "Modo institución",
            description: "Añadir campos de reporting (auditorías, segregación de cuentas) y métricas de reservas para clientes corporativos.",
          },
          {
            id: "ledn-proof",
            title: "Prueba de reservas",
            description: "Integrar feed de pruebas de reservas trimestrales y alertar si cambian los índices de cobertura BTC/USDC.",
          },
        ],
      },
    };

    const PLATFORM_IDS = Object.keys(PLATFORM_CONFIGS);
    const GLOBAL_COINGECKO_IDS = Object.values(PLATFORM_CONFIGS).reduce((acc, cfg) => ({ ...acc, ...(cfg.coingeckoIds || {}) }), {});

    const fmt = (value, currency = "USD", showCurrency = true) => {
      if (!Number.isFinite(value)) return showCurrency ? '—' : '0';
      return showCurrency ? formatCurrency(value, currency) : formatDecimal(value);
    };

    const todayISO = () => new Date().toISOString().slice(0, 10);

    function SimuladorPrestamos() {
      const initialPlatformId = PLATFORM_IDS[0];
      const [platformId, setPlatformId] = useState(() => {
        if (typeof window === 'undefined') return initialPlatformId;
        try {
          const stored = localStorage.getItem('spm_platform');
          return PLATFORM_IDS.includes(stored) ? stored : initialPlatformId;
        } catch {
          return initialPlatformId;
        }
      });

      const platform = PLATFORM_CONFIGS[platformId] ?? PLATFORM_CONFIGS[initialPlatformId];
      const {
        id,
        name: platformName,
        tagline,
        theme: platformTheme,
        classes = {},
        coingeckoIds = {},
        ltvByTicker = {},
        earnAprTop = {},
        policies = {},
        apr: aprConfig = {},
        borrowRates = {},
        loanLedger: platformLoanLedger = {},
        loyalty,
        ltvHealth,
        previewSnapshot,
        defaultAssets: platformDefaultAssets = [],
        defaultParams: platformDefaultParams = {},
        exportPrefix = "simulador_prestamos",
        disclaimers = {},
        diagnosticSources = {},
      } = platform;

      const themeName = THEME_TOKENS[platformTheme] ? platformTheme : DEFAULT_THEME;
      const focusRingClass = classes.focusRing || "focus:ring-blue-700";
      const headerClass = classes.header || "nx-gradient";
      const accentClass = classes.accent || "text-blue-100/90";
      const platformTagline = tagline || "Datos en vivo y cálculos de Earn (flexible) y crédito.";
      const targetLtv = policies.targetLtv ?? 0.20;
      const marginCallLtv = policies.marginCallLtv ?? 0.70;
      const autoRepayLtv = policies.autoRepayLtv ?? 0.85;
      const minBalancePerks = policies.minBalancePerks ?? 0;
      const defaultLtv = policies.defaultLtv ?? 0.25;
      const improvementIdeas = useMemo(() => {
        const base = FEATURE_IMPROVEMENT_TASKS.common || [];
        const extras = (FEATURE_IMPROVEMENT_TASKS.byPlatform || {})[platformId] || [];
        const implementedIds = new Set(["benchmarking", "cashflow-planning"]);
        return [...base, ...extras].filter((idea) => !implementedIds.has(idea.id));
      }, [platformId]);
      const loyaltyModels = loyalty?.models ?? [];
      const loyaltyModelFallback = platformDefaultParams?.loyaltyModel ?? loyaltyModels[0]?.id ?? "vsRest";
      const isBinance = id === "binance";
      const [nowTs, setNowTs] = useState(() => Date.now());
      const clamp01 = (v) => Math.max(0, Math.min(1, Number(v) || 0));
      const toPct = (value, digits = 0) => formatPercent(Number(value), {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits,
      });
      const ltvGaugeZones = React.useMemo(() => {
        if (ltvHealth?.zones?.length) {
          return ltvHealth.zones
            .map((zone, idx) => ({
              label: zone.label ?? `Zona ${idx + 1}`,
              max: clamp01(zone.max),
              color: zone.color ?? (idx === 0 ? "#22c55e" : idx === 1 ? "#facc15" : "#ef4444"),
              legend: zone.legend ?? `≤${Math.round(clamp01(zone.max) * 100)}%`,
              tone: zone.tone ?? (idx === 0 ? "ok" : idx === (ltvHealth.zones.length - 1) ? "danger" : "warn"),
            }))
            .filter((zone, idx, arr) => zone.max > 0 && idx === arr.findIndex((z) => z.max === zone.max))
            .sort((a, b) => a.max - b.max);
        }
        return [
          { label: "Muy saludable", max: clamp01(0.20), color: "#064e3b", legend: "0-20%", tone: "ok" },
          { label: "Saludable", max: clamp01(0.50), color: "#22c55e", legend: "20-50%", tone: "ok" },
          { label: "Vigilancia", max: clamp01(0.70), color: "#facc15", legend: "50-70%", tone: "warn" },
          { label: "Tensión", max: clamp01(0.83), color: "#fb923c", legend: "70-83%", tone: "warn" },
          { label: "Crítico", max: 1, color: "#ef4444", legend: ">83%", tone: "danger" },
        ];
      }, [ltvHealth, targetLtv, marginCallLtv, autoRepayLtv]);
      const ltvHealthyThreshold = clamp01(ltvGaugeZones[0]?.max ?? targetLtv);
      const ltvWarnThreshold = clamp01((ltvGaugeZones[1]?.max ?? marginCallLtv) || ltvHealthyThreshold);
      const ltvGaugeMarkers = React.useMemo(() => {
        const markersSource = ltvHealth?.markers?.length ? ltvHealth.markers : [
          { pct: targetLtv, label: `Objetivo ${Math.round(clamp01(targetLtv) * 100)}%` },
          { pct: marginCallLtv, label: `Margin call ${Math.round(clamp01(marginCallLtv) * 100)}%` },
          { pct: autoRepayLtv, label: `Auto-repay ${Math.round(clamp01(autoRepayLtv) * 100)}%` },
        ];
        return markersSource
          .map((marker, idx) => ({ pct: clamp01(marker.pct), label: marker.label ?? `Nivel ${idx + 1}` }))
          .filter((marker, idx, arr) => marker.pct > 0 && idx === arr.findIndex((m) => m.pct === marker.pct));
      }, [ltvHealth, targetLtv, marginCallLtv, autoRepayLtv]);

      const sanitizeTicker = (t) => (t || "").toUpperCase();

      useEffect(() => {
        if (!isBinance) return undefined;
        const tick = () => setNowTs(Date.now());
        tick();
        const interval = setInterval(tick, BINANCE_INTEREST_REFRESH_MS);
        return () => clearInterval(interval);
      }, [isBinance]);
      const borrowRatesByTicker = useMemo(() => {
        if (!borrowRates || typeof borrowRates !== 'object') return {};
        return Object.entries(borrowRates).reduce((acc, [ticker, info = {}]) => {
          const key = sanitizeTicker(ticker);
          if (!key) return acc;
          const annual = Number(info.annual);
          const safeAnnual = Number.isFinite(annual) && annual > 0 ? annual : 0;
          const hourly = Number(info.hourly);
          const safeHourly = Number.isFinite(hourly) && hourly > 0 ? hourly : annualToHourly(safeAnnual);
          const netAnnualRaw = Number(info.netAnnual);
          const adjustmentRaw = Number(info.adjustmentAnnual);
          const safeAdjustment = Number.isFinite(adjustmentRaw) && adjustmentRaw >= 0 ? Math.min(adjustmentRaw, safeAnnual) : (Number.isFinite(netAnnualRaw) && netAnnualRaw >= 0 ? Math.max(0, safeAnnual - netAnnualRaw) : 0);
          const safeNetAnnual = Number.isFinite(netAnnualRaw) && netAnnualRaw >= 0
            ? Math.min(netAnnualRaw, safeAnnual)
            : Math.max(0, safeAnnual - safeAdjustment);
          const safeNetHourly = annualToHourly(safeNetAnnual);
          acc[key] = {
            ...info,
            label: info.label || key,
            annual: safeAnnual,
            hourly: safeHourly,
            netAnnual: safeNetAnnual,
            netHourly: safeNetHourly,
            adjustmentAnnual: safeAdjustment,
          };
          return acc;
        }, {});
      }, [borrowRates]);
      const borrowTickerList = useMemo(() => Object.keys(borrowRatesByTicker), [borrowRatesByTicker]);
      const toNumber = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : 0;
      };
      const sanitizeAssets = (list) => {
        return (Array.isArray(list) ? list : []).map((item, idx) => {
          const ticker = sanitizeTicker(item.ticker);
          return {
            id: item.id ?? idx + 1,
            name: item.name ?? `Activo ${idx + 1}`,
            ticker,
            qty: toNumber(item.qty),
            price: toNumber(item.price),
            priceAuto: item.priceAuto === false ? false : true,
            useAsCollateral: item.useAsCollateral === false ? false : true,
            ltv: ltvByTicker[ticker] ?? item.ltv ?? defaultLtv,
            loanAssigned: Math.max(0, toNumber(item.loanAssigned)),
          };
        });
      };
      const sanitizeCashflowPlan = (rawPlan, fallbackRepay = null) => {
        const base = {
          payments: [],
          earns: [],
          manual: [],
          scenarioShocks: { base: 0, bear: -0.25, bull: 0.15 },
          activeScenario: 'base',
        };
        const safe = { ...base, ...(rawPlan || {}) };
        const ensureISO = (value, fallback) => {
          if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
          return fallback;
        };
        const toPos = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? Math.max(0, n) : 0;
        };
        const payments = Array.isArray(safe.payments)
          ? safe.payments.map((item, idx) => {
              const principal = toPos(item.principal);
              const interest = toPos(item.interest);
              const amount = toPos(item.amount);
              const total = amount > 0 ? amount : principal + interest;
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Pago ${idx + 1}`,
                date: ensureISO(item.date, fallbackRepay || todayISO()),
                amount: total,
                ticker: sanitizeTicker(item.ticker) || '',
              };
            })
          : [];
        const earns = Array.isArray(safe.earns)
          ? safe.earns.map((item, idx) => {
              const freq = ['daily', 'weekly', 'monthly'].includes(item.frequency) ? item.frequency : 'monthly';
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Flujo ${idx + 1}`,
                platform: item.platform || '',
                token: item.token || '',
                amount: toPos(item.amount),
                frequency: freq,
                startDate: ensureISO(item.startDate, todayISO()),
                endDate: ensureISO(item.endDate, fallbackRepay || ensureISO(item.startDate, todayISO())),
                defiLlamaId: typeof item.defiLlamaId === 'string' ? item.defiLlamaId : '',
              };
            })
          : [];
        const manual = Array.isArray(safe.manual)
          ? safe.manual.map((item, idx) => {
              const direction = item.direction === 'inflow' ? 'inflow' : 'outflow';
              const collateralImpact = ['increase', 'decrease', 'none'].includes(item.collateralImpact)
                ? item.collateralImpact
                : 'none';
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Evento ${idx + 1}`,
                date: ensureISO(item.date, todayISO()),
                amount: toPos(item.amount),
                direction,
                collateralImpact,
              };
            })
          : [];
        const scenarioKeys = Object.keys(base.scenarioShocks);
        const scenarioShocks = { ...base.scenarioShocks };
        Object.keys(safe.scenarioShocks || {}).forEach((key) => {
          const num = Number(safe.scenarioShocks[key]);
          if (Number.isFinite(num)) {
            scenarioShocks[key] = num;
            if (!scenarioKeys.includes(key)) scenarioKeys.push(key);
          }
        });
        const activeScenario = scenarioKeys.includes(safe.activeScenario) ? safe.activeScenario : 'base';
        return { payments, earns, manual, scenarioShocks, activeScenario };
      };
      const sanitizeBenchmarkConfig = (rawConfig) => {
        const base = {
          rateMatrix: [
            { id: 'loan-default', platform: 'Plataforma CeFi', product: 'Préstamo estándar', type: 'APR', value: 0.12 },
            { id: 'yield-default', platform: 'Rendimiento', product: 'Estrategia base', type: 'APY', value: 0.10 },
          ],
          strategies: [
            {
              id: 'strategy-1',
              label: 'Carry base',
              lenderRateId: 'loan-default',
              yieldRateId: 'yield-default',
              apr: 0.12,
              apy: 0.10,
              feesIn: 0,
              feesOut: 0,
              amountOverride: null,
              riskCeFiLender: true,
              riskDeFiYield: false,
              riskNewProtocol: false,
              defiLlamaId: '',
            },
          ],
        };
        const safe = { ...base, ...(rawConfig || {}) };
        const matrix = Array.isArray(safe.rateMatrix)
          ? safe.rateMatrix.map((item, idx) => ({
              id: item.id ?? `rate-${idx + 1}`,
              platform: item.platform || 'Plataforma',
              product: item.product || 'Producto',
              type: item.type === 'APY' ? 'APY' : 'APR',
              value: Number(item.value) || 0,
            }))
          : base.rateMatrix;
        const strategies = Array.isArray(safe.strategies)
          ? safe.strategies.map((item, idx) => ({
              id: item.id ?? `strategy-${idx + 1}`,
              label: item.label || `Estrategia ${idx + 1}`,
              lenderRateId: item.lenderRateId || matrix[0]?.id || 'loan-default',
              yieldRateId: item.yieldRateId || matrix[1]?.id || 'yield-default',
              apr: Number(item.apr) || 0,
              apy: Number(item.apy) || 0,
              feesIn: Number(item.feesIn) || 0,
              feesOut: Number(item.feesOut) || 0,
              amountOverride: item.amountOverride == null || item.amountOverride === '' ? null : Math.max(0, Number(item.amountOverride) || 0),
              riskCeFiLender: item.riskCeFiLender !== false,
              riskDeFiYield: item.riskDeFiYield === true,
              riskNewProtocol: item.riskNewProtocol === true,
              defiLlamaId: typeof item.defiLlamaId === 'string' ? item.defiLlamaId : '',
            }))
          : base.strategies;
        return { rateMatrix: matrix, strategies };
      };
      const storageKeys = useMemo(() => ({
        assets: `spm_${id}_assets_v1`,
        params: `spm_${id}_params_v2`,
        cashflow: `spm_${id}_cashflow_v1`,
        benchmark: `spm_${id}_benchmark_v1`,
      }), [id]);
      const baseAssets = useMemo(() => sanitizeAssets(platformDefaultAssets), [platformDefaultAssets, ltvByTicker, defaultLtv]);
      const baseExchangeRates = useMemo(() => {
        const merged = { ...DEFAULT_EXCHANGE_RATES, ...(platformDefaultParams?.exchangeRates || {}) };
        merged.USD = 1;
        return merged;
      }, [platformDefaultParams]);
      const sanitizeExchangeRates = useCallback((rawRates, legacyUsdToArs) => {
        const next = { ...baseExchangeRates };
        const source = rawRates && typeof rawRates === 'object' ? rawRates : {};
        const legacy = Number.isFinite(legacyUsdToArs) ? legacyUsdToArs : null;
        for (const { code } of SUPPORTED_CURRENCIES) {
          if (code === 'USD') { next.USD = 1; continue; }
          const candidate = source[code];
          const value = Number(candidate);
          if (Number.isFinite(value) && value > 0) {
            next[code] = value;
          } else if (code === 'ARS' && legacy != null && legacy > 0) {
            next[code] = legacy;
          } else if (!Number.isFinite(Number(next[code])) || next[code] <= 0) {
            next[code] = DEFAULT_EXCHANGE_RATES[code] ?? 1;
          }
        }
        next.USD = 1;
        return next;
      }, [baseExchangeRates]);
      const sanitizeLoanRequests = useCallback((rawRequests) => {
        if (!Array.isArray(rawRequests)) return [];
        return rawRequests
          .map((item, idx) => {
            const amount = Math.max(0, Number(item?.amount) || 0);
            if (!(amount > 0)) return null;
            const ticker = sanitizeTicker(item?.ticker || '');
            const id = typeof item?.id === 'string' && item.id
              ? item.id
              : `loan-${idx + 1}-${ticker || 'GEN'}`;
            return { id, amount, ticker };
          })
          .filter(Boolean);
      }, []);

      const sanitizeLoanLedger = useCallback((rawLedger) => {
        if (!isBinance || !rawLedger || typeof rawLedger !== 'object') return {};
        const fallbackDate = todayISO();
        return Object.entries(rawLedger).reduce((acc, [ticker, entry = {}]) => {
          const key = sanitizeTicker(ticker);
          if (!key) return acc;
          const original = Math.max(0, Number(entry.originalPrincipal) || 0);
          const outstanding = Math.max(0, Number(entry.outstanding) || 0);
          const payments = Array.isArray(entry.payments)
            ? entry.payments
                .map((payment, idx) => {
                  const amount = Math.max(0, Number(payment?.amount) || 0);
                  if (!(amount > 0)) return null;
                  const date = typeof payment?.date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(payment.date)
                    ? payment.date
                    : null;
                  return {
                    id: typeof payment?.id === 'string' && payment.id ? payment.id : `${key}-payment-${idx + 1}`,
                    amount,
                    date,
                    note: typeof payment?.note === 'string' ? payment.note : '',
                  };
                })
                .filter(Boolean)
            : [];
          const paidTotal = payments.reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
          const rawInterest = Number(entry.interestAccrued);
          const computedInterest = Math.max(0, outstanding - Math.max(0, original - paidTotal));
          const interestAccrued = Number.isFinite(rawInterest) && rawInterest >= 0 ? rawInterest : computedInterest;
          const annualRate = Number(entry.annualRate);
          const netAnnualRate = Number(entry.netAnnualRate);
          const liquidationPriceHint = Number(entry.liquidationPriceHint);
          const initialLtv = Number(entry.initialLtv);
          const initialCollateralValueRaw = Number(entry.initialCollateralValue ?? entry.initialCollateralUsd ?? entry.initialCollateral);
          const borrowDate = typeof entry.borrowDate === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(entry.borrowDate)
            ? entry.borrowDate
            : null;
          const lastUpdated = typeof entry.lastUpdated === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(entry.lastUpdated)
            ? entry.lastUpdated
            : fallbackDate;
          acc[key] = {
            originalPrincipal: original > 0 ? original : Math.max(0, outstanding + paidTotal - interestAccrued),
            outstanding: outstanding > 0 ? outstanding : Math.max(0, original - paidTotal + interestAccrued),
            payments,
            paidTotal,
            interestAccrued,
            annualRate: Number.isFinite(annualRate) && annualRate > 0 ? annualRate : null,
            netAnnualRate: Number.isFinite(netAnnualRate) && netAnnualRate > 0 ? netAnnualRate : null,
            liquidationPriceHint: Number.isFinite(liquidationPriceHint) && liquidationPriceHint > 0 ? liquidationPriceHint : null,
            borrowDate,
            lastUpdated,
            notes: typeof entry.notes === 'string' ? entry.notes : '',
            initialLtv: Number.isFinite(initialLtv) && initialLtv > 0 ? initialLtv : null,
            initialCollateralValue: Number.isFinite(initialCollateralValueRaw) && initialCollateralValueRaw > 0 ? initialCollateralValueRaw : null,
          };
          return acc;
        }, {});
      }, [isBinance, sanitizeTicker]);

      const baseParams = useMemo(() => {
        const fallback = {
          exchangeRates: { ...baseExchangeRates },
          loyaltyModel: loyaltyModelFallback,
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
          manualLoanAllocation: false,
          loanRequests: [],
        };
        const merged = { ...fallback, ...platformDefaultParams };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.exchangeRates = sanitizeExchangeRates(merged.exchangeRates, merged.usdToArs);
        if (isBinance) {
          const defaultTicker = borrowTickerList[0] || '';
          const candidate = sanitizeTicker(merged.binanceBorrowTicker);
          merged.binanceBorrowTicker = borrowRatesByTicker[candidate] ? candidate : defaultTicker;
        }
        return merged;
      }, [platformDefaultParams, loyaltyModelFallback, loyaltyModels, baseExchangeRates, isBinance, borrowTickerList, borrowRatesByTicker]);
      const baseCashflowPlan = useMemo(
        () => sanitizeCashflowPlan(previewSnapshot?.cashflow, (previewSnapshot?.repayDate || previewSnapshot?.cashflow?.payments?.[0]?.date || todayISO())),
        [previewSnapshot]
      );
      const baseBenchmarkConfig = useMemo(
        () => sanitizeBenchmarkConfig(previewSnapshot?.benchmark),
        [previewSnapshot]
      );
      const baseLoanLedger = useMemo(
        () => sanitizeLoanLedger(platformLoanLedger),
        [sanitizeLoanLedger, platformLoanLedger]
      );
      const sanitizeParams = (raw) => {
        const merged = { ...baseParams, ...(raw || {}) };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.manualLoanAllocation = !!merged.manualLoanAllocation;
        merged.loanRequests = sanitizeLoanRequests(merged.loanRequests);
        if (isBinance) {
          const defaultTicker = borrowTickerList[0] || '';
          const candidate = sanitizeTicker(merged.binanceBorrowTicker);
          merged.binanceBorrowTicker = borrowRatesByTicker[candidate] ? candidate : defaultTicker;
        }
        return merged;
      };

      const applyPreviewSnapshot = () => {
        if (!previewSnapshot) return;
        const {
          assets: previewAssets,
          params: previewParams,
          loanAmount: previewLoanAmount,
          repayDate: previewRepayDate,
          repayInDays,
          currency: previewCurrency,
        } = previewSnapshot;

        if (Array.isArray(previewAssets)) {
          setAssets(sanitizeAssets(previewAssets));
        }

        let sanitizedPreviewParams = null;
        if (previewParams) {
          sanitizedPreviewParams = sanitizeParams(previewParams);
          setParams(sanitizedPreviewParams);
        }

        if (previewSnapshot?.cashflow) {
          setCashflowPlan(sanitizeCashflowPlan(previewSnapshot.cashflow, previewSnapshot.repayDate || previewSnapshot.cashflow?.payments?.[0]?.date || repayDate));
        }

        if (previewSnapshot?.benchmark) {
          setBenchmarkConfig(sanitizeBenchmarkConfig(previewSnapshot.benchmark));
        }

        if (Number.isFinite(previewLoanAmount)) {
          const amount = Math.max(0, Number(previewLoanAmount) || 0);
          setLoanDraftAmount(amount);
          setParams((prev) => {
            const baseParams = sanitizedPreviewParams || prev;
            const defaultTicker = isBinance
              ? (sanitizeTicker(baseParams?.binanceBorrowTicker) || borrowTickerList[0] || '')
              : '';
            const nextRequests = amount > 0
              ? sanitizeLoanRequests([{ id: `loan-preview-${Date.now()}`, amount, ticker: defaultTicker }])
              : [];
            return { ...prev, loanRequests: nextRequests };
          });
        }

        if (typeof previewCurrency === 'string' && previewCurrency) {
          setSelectedCurrency(previewCurrency);
        } else if (typeof previewSnapshot?.showArs === 'boolean') {
          setSelectedCurrency(previewSnapshot.showArs ? 'ARS' : 'USD');
        }

        if (previewRepayDate) {
          setRepayDate(previewRepayDate);
        } else if (Number.isFinite(repayInDays)) {
          const d = new Date();
          d.setDate(d.getDate() + Math.max(0, Math.round(repayInDays)));
          setRepayDate(d.toISOString().slice(0, 10));
        }
      };

      const [assets, setAssets] = useState(() => {
        if (typeof window === 'undefined') return baseAssets;
        try {
          const saved = localStorage.getItem(storageKeys.assets);
          if (saved) {
            return sanitizeAssets(JSON.parse(saved));
          }
        } catch {}
        return baseAssets;
      });
      const [assetsOriginKey, setAssetsOriginKey] = useState(storageKeys.assets);

      const [params, setParams] = useState(() => {
        if (typeof window === 'undefined') return baseParams;
        try {
          const saved = localStorage.getItem(storageKeys.params);
          if (saved) {
            return sanitizeParams(JSON.parse(saved));
          }
        } catch {}
        return baseParams;
      });
      const [paramsOriginKey, setParamsOriginKey] = useState(storageKeys.params);
      const loanRequests = useMemo(
        () => sanitizeLoanRequests(params.loanRequests),
        [params.loanRequests, sanitizeLoanRequests]
      );

      const [fxMeta, setFxMeta] = useState({ loading: false, lastUpdated: null, error: null });

      const fetchOfficialFxRates = useCallback(async () => {
        setFxMeta((prev) => ({ ...prev, loading: true, error: null }));
        try {
          const symbols = FX_SYMBOLS.join(',');
          let ratesPayload = {};
          if (symbols) {
            const res = await fetch(`https://api.exchangerate.host/latest?base=USD&symbols=${symbols}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            ratesPayload = await res.json();
          }
          const nextRates = sanitizeExchangeRates(ratesPayload?.rates || {});
          try {
            const usdtRes = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=tether&vs_currencies=usd');
            if (usdtRes.ok) {
              const usdtData = await usdtRes.json();
              const usdtUsd = Number(usdtData?.tether?.usd);
              if (Number.isFinite(usdtUsd) && usdtUsd > 0) {
                nextRates.USDT = 1 / usdtUsd;
              }
            }
          } catch {}
          setParams((prev) => ({
            ...prev,
            exchangeRates: nextRates,
          }));
          setFxMeta({ loading: false, lastUpdated: Date.now(), error: null });
        } catch (error) {
          setFxMeta((prev) => ({
            ...prev,
            loading: false,
            error: String(error?.message || error || 'Error desconocido'),
          }));
        }
      }, [sanitizeExchangeRates, setParams]);

      const [cashflowPlan, setCashflowPlan] = useState(() => {
        if (typeof window === 'undefined') return baseCashflowPlan;
        try {
          const saved = localStorage.getItem(storageKeys.cashflow);
          if (saved) {
            return sanitizeCashflowPlan(JSON.parse(saved), previewSnapshot?.repayDate || todayISO());
          }
        } catch {}
        return baseCashflowPlan;
      });
      const [cashflowOriginKey, setCashflowOriginKey] = useState(storageKeys.cashflow);

      const [benchmarkConfig, setBenchmarkConfig] = useState(() => {
        if (typeof window === 'undefined') return baseBenchmarkConfig;
        try {
          const saved = localStorage.getItem(storageKeys.benchmark);
          if (saved) {
            return sanitizeBenchmarkConfig(JSON.parse(saved));
          }
        } catch {}
        return baseBenchmarkConfig;
      });
      const [benchmarkOriginKey, setBenchmarkOriginKey] = useState(storageKeys.benchmark);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem('spm_platform', platformId); } catch {}
      }, [platformId]);

      useEffect(() => {
        setAssets(() => {
          if (typeof window === 'undefined') {
            setAssetsOriginKey(storageKeys.assets);
            return baseAssets;
          }
          try {
            const saved = localStorage.getItem(storageKeys.assets);
            if (saved) {
              const parsed = sanitizeAssets(JSON.parse(saved));
              setAssetsOriginKey(storageKeys.assets);
              return parsed;
            }
          } catch {}
          setAssetsOriginKey(storageKeys.assets);
          return baseAssets;
        });
      }, [storageKeys.assets, baseAssets]);

      useEffect(() => {
        setParams(() => {
          if (typeof window === 'undefined') {
            setParamsOriginKey(storageKeys.params);
            return baseParams;
          }
          try {
            const saved = localStorage.getItem(storageKeys.params);
            if (saved) {
              const parsed = sanitizeParams(JSON.parse(saved));
              setParamsOriginKey(storageKeys.params);
              return parsed;
            }
          } catch {}
          setParamsOriginKey(storageKeys.params);
          return baseParams;
        });
      }, [storageKeys.params, baseParams, platformId]);

      useEffect(() => {
        fetchOfficialFxRates();
      }, [fetchOfficialFxRates]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (assetsOriginKey !== storageKeys.assets) return;
        try { localStorage.setItem(storageKeys.assets, JSON.stringify(assets)); } catch {}
      }, [assets, storageKeys.assets, assetsOriginKey]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (paramsOriginKey !== storageKeys.params) return;
        try { localStorage.setItem(storageKeys.params, JSON.stringify(params)); } catch {}
      }, [params, storageKeys.params, paramsOriginKey]);

      const [loanDraftAmount, setLoanDraftAmount] = useState(0);
      const [repayDate, setRepayDate] = useState(() => {
        const d = new Date(); d.setDate(d.getDate() + 60); return d.toISOString().slice(0, 10);
      });
      const [selectedCurrency, setSelectedCurrency] = useState(() => {
        if (previewSnapshot?.currency) return previewSnapshot.currency;
        if (typeof previewSnapshot?.showArs === 'boolean') {
          return previewSnapshot.showArs ? 'ARS' : 'USD';
        }
        return 'USD';
      });
      const [lastPriceTs, setLastPriceTs] = useState(null);
      const [liveError, setLiveError] = useState(null);
      const buildLoanRequest = useCallback((amount, ticker) => ({
        id: `loan-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        amount: Math.max(0, Number(amount) || 0),
        ticker: sanitizeTicker(ticker || ''),
      }), []);
      const handleAddLoanRequest = useCallback(() => {
        if (!(loanDraftAmount > 0)) return;
        const resolvedTicker = isBinance ? (binanceBorrowTicker || borrowTickerList[0] || '') : '';
        const entry = buildLoanRequest(loanDraftAmount, resolvedTicker);
        setParams((prev) => ({
          ...prev,
          loanRequests: sanitizeLoanRequests([...(prev.loanRequests || []), entry]),
        }));
        setLoanDraftAmount(0);
      }, [loanDraftAmount, isBinance, binanceBorrowTicker, borrowTickerList, buildLoanRequest, setParams, sanitizeLoanRequests, setLoanDraftAmount]);
      const handleRemoveLoanRequest = useCallback((id) => {
        setParams((prev) => ({
          ...prev,
          loanRequests: sanitizeLoanRequests((prev.loanRequests || []).filter((item) => item.id !== id)),
        }));
      }, [setParams, sanitizeLoanRequests]);
      const handleClearLoanRequests = useCallback(() => {
        setParams((prev) => ({ ...prev, loanRequests: [] }));
        setLoanDraftAmount(0);
      }, [setParams, setLoanDraftAmount]);

      const updateCashflowPlan = (updater) => {
        setCashflowPlan((prev) => {
          const base = typeof updater === 'function' ? updater(prev) : { ...prev, ...(updater || {}) };
          return sanitizeCashflowPlan(base, repayDate);
        });
      };

      const updateBenchmarkConfig = (updater) => {
        setBenchmarkConfig((prev) => {
          const base = typeof updater === 'function' ? updater(prev) : { ...prev, ...(updater || {}) };
          return sanitizeBenchmarkConfig(base);
        });
      };

      useEffect(() => {
        setCashflowPlan(() => {
          if (typeof window === 'undefined') {
            setCashflowOriginKey(storageKeys.cashflow);
            return baseCashflowPlan;
          }
          try {
            const saved = localStorage.getItem(storageKeys.cashflow);
            if (saved) {
              const parsed = sanitizeCashflowPlan(JSON.parse(saved), repayDate);
              setCashflowOriginKey(storageKeys.cashflow);
              return parsed;
            }
          } catch {}
          setCashflowOriginKey(storageKeys.cashflow);
          return baseCashflowPlan;
        });
      }, [storageKeys.cashflow, baseCashflowPlan, repayDate]);

      useEffect(() => {
        setBenchmarkConfig(() => {
          if (typeof window === 'undefined') {
            setBenchmarkOriginKey(storageKeys.benchmark);
            return baseBenchmarkConfig;
          }
          try {
            const saved = localStorage.getItem(storageKeys.benchmark);
            if (saved) {
              const parsed = sanitizeBenchmarkConfig(JSON.parse(saved));
              setBenchmarkOriginKey(storageKeys.benchmark);
              return parsed;
            }
          } catch {}
          setBenchmarkOriginKey(storageKeys.benchmark);
          return baseBenchmarkConfig;
        });
      }, [storageKeys.benchmark, baseBenchmarkConfig]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (cashflowOriginKey !== storageKeys.cashflow) return;
        try { localStorage.setItem(storageKeys.cashflow, JSON.stringify(cashflowPlan)); } catch {}
      }, [cashflowPlan, storageKeys.cashflow, cashflowOriginKey]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (benchmarkOriginKey !== storageKeys.benchmark) return;
        try { localStorage.setItem(storageKeys.benchmark, JSON.stringify(benchmarkConfig)); } catch {}
      }, [benchmarkConfig, storageKeys.benchmark, benchmarkOriginKey]);

      const currency = selectedCurrency;
      const usdRate = params.exchangeRates?.[currency] ?? 1;
      const usdtPerUsdRaw = Number(params.exchangeRates?.USDT);
      const usdPerUsdt = Number.isFinite(usdtPerUsdRaw) && usdtPerUsdRaw > 0 ? 1 / usdtPerUsdRaw : 1;
      const loanRate = usdRate * usdPerUsdt;
      const formatUsd = useCallback((value, showCurrency = true) => fmt(value * usdRate, currency, showCurrency), [usdRate, currency]);
      const formatLoan = useCallback((value, showCurrency = true) => fmt(value * loanRate, currency, showCurrency), [loanRate, currency]);
      const loanRequestsTotals = useMemo(() => {
        const totals = {};
        loanRequests.forEach((item) => {
          const ticker = sanitizeTicker(item.ticker || '');
          if (!ticker) return;
          totals[ticker] = (totals[ticker] || 0) + item.amount;
        });
        if (Object.keys(totals).length === 0 && isBinance) {
          Object.entries(baseLoanLedger).forEach(([ticker, entry = {}]) => {
            const amount = Math.max(0, Number(entry.outstanding) || 0);
            if (!(amount > 0)) return;
            totals[ticker] = amount;
          });
        }
        return totals;
      }, [loanRequests, isBinance, baseLoanLedger]);
      const loanAmount = useMemo(
        () => Object.values(loanRequestsTotals).reduce((acc, amount) => acc + (Number(amount) || 0), 0),
        [loanRequestsTotals]
      );
      const loanAmountUsd = loanAmount * usdPerUsdt;
      const binanceLoanLedger = useMemo(() => {
        if (!isBinance) return {};
        const clone = Object.entries(baseLoanLedger).reduce((acc, [ticker, entry]) => {
          acc[ticker] = {
            ...entry,
            payments: Array.isArray(entry?.payments) ? entry.payments.map((p) => ({ ...p })) : [],
          };
          return acc;
        }, {});
        const now = nowTs;
        const tickers = new Set([...Object.keys(clone), ...Object.keys(loanRequestsTotals)]);
        tickers.forEach((ticker) => {
          const key = sanitizeTicker(ticker);
          if (!key) return;
          const requestedOutstanding = Math.max(0, Number(loanRequestsTotals[key]) || 0);
          const current = clone[key] || { payments: [], paidTotal: 0, interestAccrued: 0, originalPrincipal: requestedOutstanding };
          const payments = Array.isArray(current.payments) ? current.payments.map((p) => ({ ...p })) : [];
          const paidFromEntry = Number(current.paidTotal);
          const paidTotal = Number.isFinite(paidFromEntry) && paidFromEntry > 0
            ? paidFromEntry
            : payments.reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
          let recordedOutstanding = Number.isFinite(current.outstanding) && current.outstanding > 0
            ? Math.max(0, Number(current.outstanding))
            : 0;
          if (requestedOutstanding > 0) {
            recordedOutstanding = requestedOutstanding;
          }
          const baseInterestRaw = Number(current.interestAccrued);
          const baseOriginal = current.originalPrincipal > 0
            ? current.originalPrincipal
            : Math.max(0, recordedOutstanding + paidTotal - (Number.isFinite(baseInterestRaw) ? Math.max(0, baseInterestRaw) : 0));
          const principalOutstanding = Math.max(0, baseOriginal - paidTotal);
          if (!(recordedOutstanding > 0) && principalOutstanding > 0) {
            recordedOutstanding = principalOutstanding + Math.max(0, baseInterestRaw || 0);
          }
          const baseInterest = Number.isFinite(baseInterestRaw) && baseInterestRaw >= 0
            ? Math.min(Math.max(0, baseInterestRaw), recordedOutstanding)
            : Math.max(0, recordedOutstanding - principalOutstanding);
          const borrowInfo = borrowRatesByTicker[key] || {};
          const annualRate = Number.isFinite(current.annualRate) && current.annualRate > 0
            ? current.annualRate
            : (Number.isFinite(borrowInfo.annual) && borrowInfo.annual > 0 ? borrowInfo.annual : null);
          const netAnnualRate = Number.isFinite(current.netAnnualRate) && current.netAnnualRate >= 0
            ? current.netAnnualRate
            : (Number.isFinite(borrowInfo.netAnnual) && borrowInfo.netAnnual >= 0
              ? borrowInfo.netAnnual
              : (Number.isFinite(borrowInfo.annual) && borrowInfo.annual > 0 ? borrowInfo.annual : (annualRate ?? 0)));
          const hourlyRate = Number.isFinite(borrowInfo.hourly) && borrowInfo.hourly > 0
            ? borrowInfo.hourly
            : (Number.isFinite(current.hourlyRate) && current.hourlyRate > 0
              ? current.hourlyRate
              : annualToHourly(annualRate || 0));
          const lastUpdatedDate = coerceDateValue(current.lastUpdated) || coerceDateValue(current.borrowDate);
          const hoursElapsed = lastUpdatedDate ? Math.max(0, (now - lastUpdatedDate.getTime()) / MS_IN_HOUR) : 0;
          const incrementalInterest = principalOutstanding > 0 && hourlyRate > 0 && hoursElapsed > 0
            ? principalOutstanding * (Math.pow(1 + hourlyRate, hoursElapsed) - 1)
            : 0;
          const liveInterest = Math.max(0, baseInterest + incrementalInterest);
          const liveOutstanding = principalOutstanding + liveInterest;
          clone[key] = {
            ...current,
            payments,
            paidTotal,
            originalPrincipal: baseOriginal,
            outstanding: liveOutstanding,
            outstandingRecorded: recordedOutstanding,
            interestAccrued: liveInterest,
            interestAccruedBase: baseInterest,
            interestAccruedRealtime: Math.max(0, liveInterest - baseInterest),
            annualRate,
            netAnnualRate,
            hourlyRate,
            lastAccrualTs: now,
            accrualHoursElapsed: hoursElapsed,
          };
        });
        return clone;
      }, [isBinance, baseLoanLedger, loanRequestsTotals, borrowRatesByTicker, nowTs]);
      const binanceLedgerOutstandingTotal = useMemo(() => {
        if (!isBinance) return 0;
        return Object.values(binanceLoanLedger).reduce((acc, entry) => acc + (Math.max(0, Number(entry?.outstanding) || 0)), 0);
      }, [isBinance, binanceLoanLedger]);
      const binanceLedgerTotals = useMemo(() => {
        if (!isBinance) {
          return {
            original: 0,
            outstanding: loanAmount,
            interest: 0,
            paid: 0,
            initialCollateral: 0,
          };
        }
        return Object.entries(binanceLoanLedger).reduce((acc, [ticker, entry]) => {
          const original = Math.max(0, Number(entry?.originalPrincipal) || 0);
          const outstanding = Math.max(0, Number(entry?.outstanding) || 0);
          const interest = Math.max(0, Number(entry?.interestAccrued) || 0);
          const paid = Math.max(0, Number(entry?.paidTotal) || 0);
          const initialCollateralValue = Number(entry?.initialCollateralValue);
          const initialLtv = Number(entry?.initialLtv);
          let collateralBase = 0;
          if (Number.isFinite(initialCollateralValue) && initialCollateralValue > 0) {
            collateralBase = initialCollateralValue;
          } else if (Number.isFinite(initialLtv) && initialLtv > 0) {
            collateralBase = initialLtv > 0 ? original / initialLtv : 0;
          } else {
            const policy = ltvByTicker[ticker] ?? defaultLtv;
            collateralBase = policy > 0 ? original / policy : 0;
          }
          acc.original += original;
          acc.outstanding += outstanding;
          acc.interest += interest;
          acc.paid += paid;
          acc.initialCollateral += Number.isFinite(collateralBase) && collateralBase > 0 ? collateralBase : 0;
          return acc;
        }, { original: 0, outstanding: 0, interest: 0, paid: 0, initialCollateral: 0 });
      }, [isBinance, binanceLoanLedger, loanAmount, ltvByTicker, defaultLtv]);
      const binanceOriginalPrincipalTotal = binanceLedgerTotals.original;
      const binanceInterestAccruedTotal = binanceLedgerTotals.interest;
      const binanceInitialCollateralTotal = binanceLedgerTotals.initialCollateral;
      const binanceTotalToRepay = Math.max(0, binanceOriginalPrincipalTotal + binanceInterestAccruedTotal);
      const binanceInitialLtv = binanceInitialCollateralTotal > 0
        ? binanceOriginalPrincipalTotal / binanceInitialCollateralTotal
        : 0;
      const pct = (value, digits = 1) => formatPercent(Number(value), {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits,
      });

      const tickerToId = (ticker) => {
        const key = sanitizeTicker(ticker);
        return coingeckoIds[key] ?? GLOBAL_COINGECKO_IDS[key];
      };

      const tickersKey = useMemo(() => assets.filter(a=>a.priceAuto!==false).map(a=>sanitizeTicker(a.ticker)).sort().join(','), [assets]);

      const inFlight = useRef(false);
      const importInputRef = useRef(null);
      const exportMenuRef = useRef(null);
      const autoMasterRef = useRef(null);
      const collateralMasterRef = useRef(null);
      const [exportMenuOpen, setExportMenuOpen] = useState(false);
      async function fetchLivePricesNow(force = false) {
        try {
          if (inFlight.current) return; inFlight.current = true;
          setLiveError(null);
          if (!params.liveQuotes && !force) { inFlight.current = false; return; }
          const ids = Array.from(new Set(assets.filter(a => a.priceAuto !== false).map(a => tickerToId(a.ticker)).filter(Boolean)));
          if (!ids.length) { setLastPriceTs(Date.now()); inFlight.current = false; return; }
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
        finally { inFlight.current = false; }
      }

      async function fetchPricesForTickers(tickers = []) {
        try {
          if (!params.liveQuotes) return;
          const ids = Array.from(new Set(tickers.map(tickerToId).filter(Boolean)));
          if (!ids.length) return;
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
      }

      const closeExportMenu = () => setExportMenuOpen(false);

      const handleExportJSON = () => {
        const blob = new Blob([JSON.stringify({ assets, params, cashflowPlan, benchmarkConfig }, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${exportPrefix}_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        closeExportMenu();
      };

      const handleImportRequest = () => {
        closeExportMenu();
        importInputRef.current?.click();
      };

      const handleResetParams = () => {
        if (confirm("¿Restablecer parámetros por defecto?")) {
          localStorage.removeItem(storageKeys.params);
          setParams({ ...baseParams });
          setParamsOriginKey(storageKeys.params);
          setLoanDraftAmount(0);
        }
        closeExportMenu();
      };

      const handleResetAssets = () => {
        if (confirm("¿Restablecer activos por defecto?")) {
          localStorage.removeItem(storageKeys.assets);
          setAssets(sanitizeAssets(platformDefaultAssets));
          setAssetsOriginKey(storageKeys.assets);
        }
        closeExportMenu();
      };

      const handleToggleAllAuto = (checked) => {
        const nextTickers = checked
          ? Array.from(new Set(assets.map((asset) => sanitizeTicker(asset.ticker)).filter(Boolean)))
          : [];
        setAssets((prev) => prev.map((asset) => ({ ...asset, priceAuto: checked })));
        if (checked && nextTickers.length) {
          fetchPricesForTickers(nextTickers);
        }
      };

      const handleToggleAllCollateral = (checked) => {
        setAssets((prev) => prev.map((asset) => ({ ...asset, useAsCollateral: checked })));
      };

      const handleResetPlanners = () => {
        if (confirm("¿Limpiar plan de cashflow y benchmark?")) {
          localStorage.removeItem(storageKeys.cashflow);
          localStorage.removeItem(storageKeys.benchmark);
          setCashflowPlan(baseCashflowPlan);
          setBenchmarkConfig(baseBenchmarkConfig);
          setCashflowOriginKey(storageKeys.cashflow);
          setBenchmarkOriginKey(storageKeys.benchmark);
        }
        closeExportMenu();
      };

      const handleImportFile = (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        file.text()
          .then((text) => {
            try {
              const parsed = JSON.parse(text);
              if (parsed.assets) {
                setAssets(sanitizeAssets(parsed.assets));
                setAssetsOriginKey(storageKeys.assets);
              }
              if (parsed.params) {
                setParams(sanitizeParams(parsed.params));
                setParamsOriginKey(storageKeys.params);
              }
              if (parsed.cashflowPlan) {
                setCashflowPlan(sanitizeCashflowPlan(parsed.cashflowPlan, repayDate));
                setCashflowOriginKey(storageKeys.cashflow);
              }
              if (parsed.benchmarkConfig) {
                setBenchmarkConfig(sanitizeBenchmarkConfig(parsed.benchmarkConfig));
                setBenchmarkOriginKey(storageKeys.benchmark);
              }
            } catch (err) {
              alert(`No se pudo importar el archivo: ${err?.message || err}`);
            }
          })
          .finally(() => {
            if (importInputRef.current) importInputRef.current.value = '';
          });
      };

      useEffect(() => {
        if (!exportMenuOpen) return;
        if (typeof document === 'undefined') return;
        const handleClick = (event) => {
          if (!exportMenuRef.current) return;
          if (exportMenuRef.current.contains(event.target)) return;
          closeExportMenu();
        };
        const handleKey = (event) => {
          if (event.key === 'Escape') closeExportMenu();
        };
        document.addEventListener('mousedown', handleClick);
        document.addEventListener('keydown', handleKey);
        return () => {
          document.removeEventListener('mousedown', handleClick);
          document.removeEventListener('keydown', handleKey);
        };
      }, [exportMenuOpen]);

      useEffect(() => {
        if (!params.liveQuotes) return;
        fetchLivePricesNow();
        const sec = Math.max(LIVE_REFRESH_SECONDS, Number(params.refreshSec || LIVE_REFRESH_SECONDS));
        const t = setInterval(fetchLivePricesNow, sec * 1000);
        return () => clearInterval(t);
      }, [params.liveQuotes, params.refreshSec, tickersKey]);

      const loyaltyTicker = loyalty?.tokenTicker ? sanitizeTicker(loyalty.tokenTicker) : null;

      const totals = useMemo(() => {
        const withValue = assets.map((a, idx) => {
          const ticker = sanitizeTicker(a.ticker);
          const qty = toNumber(a.qty);
          const price = toNumber(a.price);
          const value = qty * price;
          const ltv = ltvByTicker[ticker] ?? a.ltv ?? defaultLtv;
          const loanAssigned = Math.max(0, toNumber(a.loanAssigned));
          return { ...a, ticker, qty, price, value, ltv, loanAssigned, useAsCollateral: a.useAsCollateral !== false };
        });
        const total = withValue.reduce((acc, a) => acc + a.value, 0);
        const totalLoyalty = loyaltyTicker ? withValue.filter(a => a.ticker === loyaltyTicker).reduce((acc, a) => acc + a.value, 0) : 0;
        const rest = total - totalLoyalty;
        const ratioVsRest = rest > 0 ? (totalLoyalty / rest) : (totalLoyalty > 0 ? Number.POSITIVE_INFINITY : 0);
        const ratioVsTotal = total > 0 ? (totalLoyalty / total) : 0;
        const collaterals = withValue.filter(a => a.useAsCollateral);
        const totalCollateralValue = collaterals.reduce((acc, a) => acc + a.value, 0);
        const maxBorrow = collaterals.reduce((acc, a) => acc + a.value * ((ltvByTicker[a.ticker] ?? a.ltv ?? defaultLtv) || 0), 0);
        return { withValue, total, totalLoyalty, rest, ratioVsRest, ratioVsTotal, totalCollateralValue, maxBorrow };
      }, [assets, loyaltyTicker, ltvByTicker, defaultLtv]);

      const allAuto = assets.length > 0 && assets.every((asset) => asset.priceAuto !== false);
      const someAuto = assets.some((asset) => asset.priceAuto !== false);
      const allCollateral = assets.length > 0 && assets.every((asset) => asset.useAsCollateral);
      const someCollateral = assets.some((asset) => asset.useAsCollateral);

      const binanceBorrowTicker = useMemo(() => {
        if (!isBinance) return null;
        const candidate = sanitizeTicker(params.binanceBorrowTicker);
        if (candidate && borrowRatesByTicker[candidate]) return candidate;
        return borrowTickerList[0] || null;
      }, [isBinance, params.binanceBorrowTicker, borrowRatesByTicker, borrowTickerList]);
      const binanceBorrowInfo = binanceBorrowTicker ? borrowRatesByTicker[binanceBorrowTicker] : null;
      const binanceActiveLoanEntries = useMemo(() => {
        if (!isBinance) return [];
        return Object.entries(loanRequestsTotals).filter(([, amount]) => amount > 0);
      }, [isBinance, loanRequestsTotals]);
      const binanceBorrowAnnualRate = useMemo(() => {
        if (!isBinance) return 0;
        if (loanAmount > 0 && binanceActiveLoanEntries.length > 0) {
          return binanceActiveLoanEntries.reduce((acc, [ticker, amount]) => {
            const info = borrowRatesByTicker[ticker];
            const rate = info?.annual ?? binanceBorrowInfo?.annual ?? 0;
            return acc + rate * (amount / loanAmount);
          }, 0);
        }
        return binanceBorrowInfo?.annual ?? 0;
      }, [isBinance, loanAmount, binanceActiveLoanEntries, borrowRatesByTicker, binanceBorrowInfo]);
      const binanceBorrowNetAnnualRate = useMemo(() => {
        if (!isBinance) return 0;
        if (loanAmount > 0 && binanceActiveLoanEntries.length > 0) {
          return binanceActiveLoanEntries.reduce((acc, [ticker, amount]) => {
            const info = borrowRatesByTicker[ticker];
            const net = info?.netAnnual ?? info?.annual ?? binanceBorrowInfo?.netAnnual ?? binanceBorrowInfo?.annual ?? 0;
            return acc + net * (amount / loanAmount);
          }, 0);
        }
        return binanceBorrowInfo?.netAnnual ?? binanceBorrowInfo?.annual ?? 0;
      }, [isBinance, loanAmount, binanceActiveLoanEntries, borrowRatesByTicker, binanceBorrowInfo]);
      const binanceBorrowAdjustment = useMemo(
        () => Math.max(0, binanceBorrowAnnualRate - binanceBorrowNetAnnualRate),
        [binanceBorrowAnnualRate, binanceBorrowNetAnnualRate]
      );
      const binanceBorrowLabel = useMemo(() => {
        if (!isBinance) return null;
        if (binanceActiveLoanEntries.length === 0) {
          return binanceBorrowInfo?.label || (binanceBorrowTicker || null);
        }
        if (binanceActiveLoanEntries.length === 1) {
          const [ticker] = binanceActiveLoanEntries[0];
          return borrowRatesByTicker[ticker]?.label || ticker;
        }
        const tickers = binanceActiveLoanEntries.map(([ticker]) => ticker).join(', ');
        return `${binanceActiveLoanEntries.length} criptos (${tickers})`;
      }, [isBinance, binanceActiveLoanEntries, borrowRatesByTicker, binanceBorrowInfo, binanceBorrowTicker]);

      useEffect(() => {
        if (autoMasterRef.current) {
          autoMasterRef.current.indeterminate = !allAuto && someAuto;
        }
      }, [allAuto, someAuto]);

      useEffect(() => {
        if (collateralMasterRef.current) {
          collateralMasterRef.current.indeterminate = !allCollateral && someCollateral;
        }
      }, [allCollateral, someCollateral]);

      const loyaltyModelActive = params.loyaltyModel ?? loyaltyModelFallback;

      const loyaltyTier = useMemo(() => {
        if (!loyalty) return aprConfig.baseTier ?? loyalty?.baseLabel ?? "—";
        if (totals.total < minBalancePerks) return loyalty.belowMinimumLabel ?? loyalty.baseLabel ?? "Sin perks";
        const ratioUsed = loyaltyModelActive === "vsTotal" ? totals.ratioVsTotal : totals.ratioVsRest;
        for (const tier of loyalty.tierThresholds ?? []) {
          if (ratioUsed >= tier.minRatio) return tier.label;
        }
        return loyalty.baseLabel ?? (aprConfig.baseTier ?? "Base");
      }, [loyalty, totals.total, minBalancePerks, loyaltyModelActive, totals.ratioVsTotal, totals.ratioVsRest, aprConfig.baseTier]);

      const aprStandardTable = aprConfig.standard ?? {};
      const aprDiscountTable = aprConfig.discounted ?? aprStandardTable;
      const aprBaseTier = aprConfig.baseTier ?? (loyalty?.baseLabel ?? "Base");
      const aprBase = aprConfig.base ?? aprStandardTable[aprBaseTier] ?? aprStandardTable[loyalty?.baseLabel] ?? 0.20;
      const lowCostEligibleTiers = aprConfig.lowCostEligibleTiers ?? loyalty?.lowCostEligibleTiers ?? [];
      const earlyRuleDays = aprConfig.earlyRuleDays ?? 45;
      const earlyAPR = aprConfig.earlyAPR ?? aprBase;

      const recommendedLoanAtTarget = useMemo(() => targetLtv * totals.totalCollateralValue, [targetLtv, totals.totalCollateralValue]);
      const capLowCost = useMemo(() => Math.min(recommendedLoanAtTarget, totals.maxBorrow), [recommendedLoanAtTarget, totals.maxBorrow]);

      const chosenAPR = useMemo(() => {
        if (isBinance) {
          return binanceBorrowAnnualRate;
        }
        const table = loanAmountUsd <= recommendedLoanAtTarget ? aprDiscountTable : aprStandardTable;
        const aprFromTier = table?.[loyaltyTier];
        if (typeof aprFromTier === 'number') return aprFromTier;
        if (aprBaseTier && typeof table?.[aprBaseTier] === 'number') return table[aprBaseTier];
        if (loyalty?.baseLabel && typeof table?.[loyalty.baseLabel] === 'number') return table[loyalty.baseLabel];
        return aprBase;
      }, [isBinance, binanceBorrowAnnualRate, loanAmountUsd, recommendedLoanAtTarget, aprDiscountTable, aprStandardTable, loyaltyTier, aprBaseTier, aprBase, loyalty?.baseLabel]);

      const daysUntilRepay = useMemo(() => {
        const a = new Date(); const b = new Date(repayDate);
        const diffMs = Math.max(0, b.getTime() - a.getTime());
        return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      }, [repayDate]);

      const interestCalc = useMemo(() => {
        const P = loanAmount; const d = daysUntilRepay; const r = chosenAPR;
        const earlyDays = Math.max(0, earlyRuleDays - d);
        const main = P * (Math.pow(1 + r / 365, d) - 1);
        const early = d < earlyRuleDays ? P * (Math.pow(1 + earlyAPR / 365, earlyDays) - 1) : 0;
        const total = main + early; return { main, early, total, repayTotal: P + total };
      }, [loanAmount, daysUntilRepay, chosenAPR, earlyRuleDays, earlyAPR]);


      const earnEligible = totals.total >= minBalancePerks && params.earnOptIn;
      const earnMonthly = useMemo(() => {
        if (!earnEligible) return 0;
        const days = 30;
        return totals.withValue.reduce((acc, a) => {
          if (!params.earnOnCollateral && a.useAsCollateral) return acc;
          const apr = earnAprTop[sanitizeTicker(a.ticker)] ?? 0;
          return acc + a.value * (Math.pow(1 + apr/365, days) - 1);
        }, 0);
      }, [earnEligible, params.earnOnCollateral, totals.withValue, earnAprTop]);

      const timeline = useMemo(() => {
        const totalDays = Math.max(1, daysUntilRepay);
        const steps = Math.max(4, Math.min(12, Math.ceil(totalDays / 20)));
        const arr = [];
        for (let i = 0; i <= steps; i++) {
          const day = (totalDays / steps) * i;
          const interest = loanAmount * (Math.pow(1 + chosenAPR / 365, day) - 1);
          let earn = 0;
          if (earnEligible) {
            earn = totals.withValue.reduce((acc, asset) => {
              if (!params.earnOnCollateral && asset.useAsCollateral) return acc;
              const apr = earnAprTop[sanitizeTicker(asset.ticker)] ?? 0;
              return acc + asset.value * (Math.pow(1 + apr / 365, day) - 1);
            }, 0);
          }
          const balance = Math.max(0, loanAmount + interest - earn);
          arr.push({ day, cost: interest, earn, balance });
        }
        return arr;
      }, [chosenAPR, daysUntilRepay, earnEligible, loanAmount, params.earnOnCollateral, totals.withValue, earnAprTop]);
      const totalEarnDuringPeriod = timeline.length ? timeline[timeline.length - 1].earn : 0;
      const netInterestPeriod = interestCalc.total - totalEarnDuringPeriod;
      const standardNetAnnualRate = loanAmount > 0 && daysUntilRepay > 0 ? (Math.pow(1 + netInterestPeriod / loanAmount, 365 / daysUntilRepay) - 1) : 0;

      const cashflowDerived = useMemo(() =>
        computeCashflowProjections(cashflowPlan, {
          loanAmount,
          apr: chosenAPR,
          repayDate,
          totalCollateralValue: totals.totalCollateralValue,
          targetLtv,
          marginCallLtv,
          autoRepayLtv,
          scenarioShocks: cashflowPlan?.scenarioShocks,
          loanByTicker: loanRequestsTotals,
        }),
      [cashflowPlan, loanAmount, chosenAPR, repayDate, totals.totalCollateralValue, targetLtv, marginCallLtv, autoRepayLtv, loanRequestsTotals]);

      const scheduledPrincipal = Math.max(0, cashflowDerived?.scheduledPrincipal || 0);
      const scheduledInterest = Math.max(0, cashflowDerived?.scheduledInterest || 0);
      const paidPrincipal = Math.min(loanAmount, scheduledPrincipal);
      const paidInterest = scheduledInterest;
      const totalPaid = Math.max(0, paidPrincipal + paidInterest);
      const hasCashflowPlanPayments = useMemo(() => {
        if (!Array.isArray(cashflowPlan?.payments)) return false;
        return cashflowPlan.payments.some((item) => {
          const amount = Number(item?.amount ?? item?.principal ?? 0);
          const interest = Number(item?.interest ?? 0);
          return (Number.isFinite(amount) && amount > 0) || (Number.isFinite(interest) && interest > 0);
        });
      }, [cashflowPlan]);
      const binancePlanPaidTotal = totalPaid;
      const binancePaidDisplayTotal = binancePlanPaidTotal;
      const binancePaidLabel = 'Pagos planificados';
      const binanceNetLoanValue = Math.max(
        0,
        binanceOriginalPrincipalTotal + binanceInterestAccruedTotal - binancePaidDisplayTotal,
      );
      const projectedFinalPayoff = Math.max(0, cashflowDerived?.projectedFinalPayoff || 0);
      const totalProjectedOutflows = Math.max(0, cashflowDerived?.totalCost || 0);
      const plannedOutstanding = Math.max(0, cashflowDerived?.outstandingAfterPlan ?? loanAmount);
      const plannedCollateralDelta = cashflowDerived?.collateralDeltaPlanned ?? 0;
      const collateralAfterPlan = Math.max(0, cashflowDerived?.collateralAfterPlan ?? (totals.totalCollateralValue + plannedCollateralDelta));
      const monthlyLoanCost = useMemo(
        () => plannedOutstanding * (Math.pow(1 + chosenAPR / 365, 30) - 1),
        [plannedOutstanding, chosenAPR],
      );
      const lowCostHeadroom = useMemo(
        () => Math.max(0, capLowCost - plannedOutstanding * usdPerUsdt),
        [capLowCost, plannedOutstanding, usdPerUsdt],
      );
      const currentOverallLTV = useMemo(() => {
        if (!(totals.totalCollateralValue > 0)) return 0;
        const netLoanBase = isBinance ? binanceNetLoanValue : plannedOutstanding;
        const netLoanUsd = netLoanBase * usdPerUsdt;
        return netLoanUsd / totals.totalCollateralValue;
      }, [isBinance, binanceNetLoanValue, plannedOutstanding, totals.totalCollateralValue, usdPerUsdt]);
      const plannedOverallLTV = collateralAfterPlan > 0 && Number.isFinite(plannedOutstanding)
        ? (plannedOutstanding * usdPerUsdt) / collateralAfterPlan
        : (plannedOutstanding > 0 ? 1 : 0);
      const ltvGaugeValue = Number.isFinite(cashflowDerived?.ltvForGauge) ? Math.max(0, cashflowDerived.ltvForGauge) : plannedOverallLTV;
      const ltvScenarioLabel = cashflowDerived?.scenarioLabel;
      const cashflowAlerts = useMemo(
        () => normalizeAlertItems(cashflowDerived?.alerts),
        [cashflowDerived],
      );
      const toneForLtvValue = (value) => {
        if (!Number.isFinite(value)) return undefined;
        if (ltvHealthyThreshold > 0 && value <= ltvHealthyThreshold) return "ok";
        if (ltvWarnThreshold > 0 && value <= ltvWarnThreshold) return "warn";
        if (value > 0) return "danger";
        return undefined;
      };
      const ltvTone = toneForLtvValue(ltvGaugeValue);
      const plannedCollateralChange = collateralAfterPlan - totals.totalCollateralValue;
      const binanceLoanAfterPlan = plannedOutstanding;
      const binanceOutstandingRatio = loanAmount > 0
        ? Math.max(0, Math.min(1, binanceLoanAfterPlan / loanAmount))
        : 0;
      const binanceCollateralAfterPlan = collateralAfterPlan;
      const binanceLtvAfterPlan = plannedOverallLTV;
      const binanceInitialLtvTone = toneForLtvValue(binanceInitialLtv);
      const binanceCurrentLtvTone = toneForLtvValue(currentOverallLTV);
      const binanceLoanNetSubtle = [
        binanceInterestAccruedTotal > 0 ? `Interés ${formatLoan(binanceInterestAccruedTotal)}` : null,
        binancePaidDisplayTotal > 0 ? `${binancePaidLabel} ${formatLoan(binancePaidDisplayTotal)}` : null,
      ].filter(Boolean).join(' · ') || 'Sin movimientos registrados';
      const binancePaidSubtle = hasCashflowPlanPayments
        ? 'Pagos planificados desde Cashflow'
        : 'Sin pagos planificados';
      const binanceInitialCollateralSubtle = binanceInitialCollateralTotal > 0
        ? `Colateral inicial ${formatUsd(binanceInitialCollateralTotal)}`
        : '—';
      const binanceNetLtvSubtle = totals.totalCollateralValue > 0
        ? `Colateral actual ${formatUsd(totals.totalCollateralValue)}`
        : 'Sin colateral';
      const binanceExtraCollateralNeeded = ltvHealthyThreshold > 0 ? Math.max(0, binanceLoanAfterPlan / ltvHealthyThreshold - binanceCollateralAfterPlan) : 0;
      const binanceRepayNeeded = Math.max(0, binanceLoanAfterPlan - binanceCollateralAfterPlan * ltvHealthyThreshold);
      const binanceBufferToCaution = Math.max(0, binanceCollateralAfterPlan * ltvWarnThreshold - binanceLoanAfterPlan);
      const binanceCautionLabel = ltvWarnThreshold > ltvHealthyThreshold ? `${toPct(ltvHealthyThreshold, 0)} – ${toPct(ltvWarnThreshold, 0)}` : `>${toPct(ltvHealthyThreshold, 0)}`;
      const currentLiquidationValue = marginCallLtv > 0 ? plannedOutstanding / marginCallLtv : 0;
      const currentLiquidationBuffer = totals.totalCollateralValue - currentLiquidationValue;
      const binanceLiquidationValue = marginCallLtv > 0 ? binanceLoanAfterPlan / marginCallLtv : 0;
      const binanceLiquidationBuffer = binanceCollateralAfterPlan - binanceLiquidationValue;

      const formatBinanceBufferValue = (buffer) => {
        if (!Number.isFinite(buffer)) return '—';
        const formatted = formatUsd(Math.abs(buffer));
        return buffer >= 0 ? formatted : `Déficit ${formatted}`;
      };

      const toneForBinanceBuffer = (buffer) => {
        if (!Number.isFinite(buffer)) return undefined;
        return buffer >= 0 ? "ok" : "danger";
      };

      const manualLoanAllocationEnabled = !!params.manualLoanAllocation;

      const collateralBreakdown = useMemo(() => {
        const totalCollateral = totals.totalCollateralValue || 0;
        if (!(totalCollateral > 0)) {
          return {
            items: [],
            manualActive: false,
            manualEnabled: manualLoanAllocationEnabled,
            manualTotal: 0,
            loanAllocated: 0,
            weightedAprOffset: isBinance ? binanceBorrowAdjustment : 0,
            weightedNetApr: isBinance ? binanceBorrowNetAnnualRate : chosenAPR,
          };
        }
        const outstandingMap = cashflowDerived?.outstandingByTicker || null;
        const hasOutstandingMap = !!(outstandingMap && Object.keys(outstandingMap).length > 0);
        const manualTotal = totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.loanAssigned > 0)
          .reduce((acc, asset) => acc + asset.loanAssigned, 0);
        const manualEnabled = manualLoanAllocationEnabled;
        const manualActive = manualEnabled && manualTotal > 0;
        const directLoanActive = isBinance ? Object.keys(loanRequestsTotals).length > 0 : loanAmount > 0;
        const directLoanSum = Object.values(loanRequestsTotals).reduce((acc, value) => acc + value, 0);
        const outstandingDirectTotal = hasOutstandingMap
          ? Object.values(outstandingMap).reduce((acc, value) => {
              const num = Number(value);
              return acc + (Number.isFinite(num) && num > 0 ? num : 0);
            }, 0)
          : (isBinance ? directLoanSum : directLoanSum * (binanceOutstandingRatio || 0));
        const loanBase = isBinance
          ? (binanceLedgerOutstandingTotal > 0 ? binanceLedgerOutstandingTotal : Math.max(0, directLoanSum || plannedOutstanding))
          : Math.max(0, plannedOutstanding);
        const items = totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.value > 0)
          .map((asset) => {
            const ticker = sanitizeTicker(asset.ticker);
            const policyLTV = ltvByTicker[ticker] ?? asset.ltv ?? defaultLtv;
            const maxBorrowForAsset = asset.value * policyLTV;
            const share = asset.value / totalCollateral;
            const mappedLoanRaw = directLoanActive ? Math.max(0, loanRequestsTotals[ticker] || 0) : 0;
            const mappedLoan = directLoanActive
              ? (hasOutstandingMap
                ? Math.max(0, Number(outstandingMap?.[ticker]) || 0)
                : mappedLoanRaw)
              : 0;
            const ledgerEntry = isBinance ? binanceLoanLedger[ticker] : null;
            let allocatedLoan = manualActive
              ? Math.max(0, asset.loanAssigned || 0)
              : (directLoanActive ? mappedLoan : loanBase * share);
            if (isBinance && ledgerEntry?.outstanding > 0) {
              allocatedLoan = ledgerEntry.outstanding;
            }
            const usageVsCap = maxBorrowForAsset > 0 ? allocatedLoan / maxBorrowForAsset : 0;
            const actualLtv = asset.value > 0 ? allocatedLoan / asset.value : 0;
            const earnApr = earnAprTop[ticker] ?? 0;
            const baseOffset = actualLtv > 0 ? earnApr / actualLtv : 0;
            const borrowInfo = isBinance ? borrowRatesByTicker[ticker] || {} : {};
            const annualApr = isBinance
              ? (Number.isFinite(ledgerEntry?.annualRate) && ledgerEntry.annualRate > 0
                ? ledgerEntry.annualRate
                : (borrowInfo.annual ?? binanceBorrowAnnualRate))
              : chosenAPR;
            const netAprRaw = isBinance
              ? (Number.isFinite(ledgerEntry?.netAnnualRate) && ledgerEntry.netAnnualRate >= 0
                ? ledgerEntry.netAnnualRate
                : (borrowInfo.netAnnual ?? borrowInfo.annual ?? annualApr))
              : Math.max(0, chosenAPR - baseOffset);
            const netApr = Math.max(0, netAprRaw);
            const aprOffset = isBinance ? Math.max(0, annualApr - netApr) : baseOffset;
            let tone = "ok";
            if (isBinance) {
              const warnCut = ltvHealthyThreshold || 0;
              const dangerCut = ltvWarnThreshold > 0 ? ltvWarnThreshold : Math.max(warnCut, marginCallLtv);
              if (dangerCut > 0 && actualLtv >= dangerCut) {
                tone = "danger";
              } else if (warnCut > 0 && actualLtv >= warnCut) {
                tone = "warn";
              }
            } else {
              if (usageVsCap >= 1 || actualLtv >= policyLTV || plannedOverallLTV >= autoRepayLtv) {
                tone = "danger";
              } else if (usageVsCap > 0.75 || actualLtv > policyLTV * 0.9 || plannedOverallLTV >= marginCallLtv) {
                tone = "warn";
              }
            }
            const loanShareDenom = isBinance && binanceLedgerOutstandingTotal > 0
              ? binanceLedgerOutstandingTotal
              : manualActive
                ? manualTotal
                : directLoanActive
                  ? (hasOutstandingMap
                    ? (outstandingDirectTotal > 0 ? outstandingDirectTotal : loanBase)
                    : (directLoanSum > 0 ? directLoanSum : loanBase))
                  : loanBase;
            const paidTotal = Math.max(0, Number(ledgerEntry?.paidTotal) || 0);
            const interestAccrued = Math.max(0, Number(ledgerEntry?.interestAccrued) || 0);
            const originalPrincipal = Number.isFinite(ledgerEntry?.originalPrincipal) && ledgerEntry.originalPrincipal > 0
              ? ledgerEntry.originalPrincipal
              : Math.max(0, allocatedLoan + paidTotal - interestAccrued);
            const liquidationValue = marginCallLtv > 0 ? allocatedLoan / marginCallLtv : null;
            const qty = Number(asset.qty) || 0;
            const computedLiquidationPrice = marginCallLtv > 0 && qty > 0 ? (allocatedLoan / marginCallLtv) / qty : null;
            const liquidationPrice = Number.isFinite(ledgerEntry?.liquidationPriceHint) && ledgerEntry.liquidationPriceHint > 0
              ? ledgerEntry.liquidationPriceHint
              : computedLiquidationPrice;
            const currentPrice = Number(asset.price) > 0 ? asset.price : null;
            const liquidationBufferValue = Number.isFinite(liquidationValue) ? asset.value - liquidationValue : null;
            const liquidationBufferPct = currentPrice && liquidationPrice && currentPrice > 0
              ? Math.max(0, (currentPrice - liquidationPrice) / currentPrice)
              : null;
            return {
              id: asset.id,
              name: asset.name || ticker || `Activo ${asset.id}`,
              ticker,
              value: asset.value,
              share,
              policyLTV,
              policyPct: policyLTV * 100,
              maxBorrowForAsset,
              allocatedLoan,
              usageVsCap: Math.max(0, usageVsCap),
              actualLtv,
              earnApr,
              aprOffset,
              netApr,
              loanShare: loanShareDenom > 0 ? allocatedLoan / loanShareDenom : 0,
              tone,
              annualApr,
              ledger: ledgerEntry ? { ...ledgerEntry, payments: Array.isArray(ledgerEntry.payments) ? ledgerEntry.payments.map((p) => ({ ...p })) : [] } : null,
              paidTotal,
              interestAccrued,
              originalPrincipal,
              liquidationPrice,
              liquidationBufferPct,
              liquidationBufferValue,
              currentPrice,
              qty,
              liquidationValue,
            };
          })
          .sort((a, b) => b.value - a.value);
        const totalAllocated = manualActive
          ? manualTotal
          : directLoanActive
            ? (isBinance ? (binanceLedgerOutstandingTotal || directLoanSum || loanBase) : (loanBase))
            : items.reduce((acc, item) => acc + item.allocatedLoan, 0);
        const weightedAprOffset = totalAllocated > 0
          ? items.reduce((acc, item) => acc + Math.max(0, item.aprOffset || 0) * (item.allocatedLoan / totalAllocated), 0)
          : (isBinance ? binanceBorrowAdjustment : 0);
        const weightedNetApr = totalAllocated > 0
          ? items.reduce((acc, item) => acc + (item.netApr ?? chosenAPR) * (item.allocatedLoan / totalAllocated), 0)
          : (isBinance ? binanceBorrowNetAnnualRate : Math.max(0, chosenAPR - weightedAprOffset));
        return {
          items,
          manualActive,
          manualEnabled,
          manualTotal,
          loanAllocated: totalAllocated || loanBase,
          weightedAprOffset,
          weightedNetApr,
        };
      }, [autoRepayLtv, binanceBorrowAdjustment, binanceBorrowNetAnnualRate, binanceOutstandingRatio, binanceLoanLedger, binanceLedgerOutstandingTotal, borrowRatesByTicker, cashflowDerived?.outstandingByTicker, defaultLtv, earnAprTop, isBinance, loanAmount, loanRequestsTotals, manualLoanAllocationEnabled, marginCallLtv, plannedOverallLTV, plannedOutstanding, totals.totalCollateralValue, totals.withValue, ltvByTicker, ltvHealthyThreshold, ltvWarnThreshold]);

      const binanceNetAprOffset = isBinance ? Math.max(0, collateralBreakdown.weightedAprOffset || 0) : 0;
      const binanceNetAprBase = isBinance ? Math.max(0, collateralBreakdown.weightedNetApr ?? chosenAPR) : 0;
      const binanceNetAnnualRate = isBinance ? Math.max(0, binanceNetAprBase) : 0;
      const netAnnualRate = isBinance ? binanceNetAnnualRate : standardNetAnnualRate;
      const binanceNetAprSubtle = isBinance
        ? (binanceOutstandingRatio < 0.999
          ? `Saldo neto ${toPct(binanceOutstandingRatio, 0)} · tasa neta ${toPct(binanceNetAprBase, 2)}`
          : (binanceNetAprOffset > 0
            ? `Préstamo ${toPct(chosenAPR, 2)} − ajuste ${toPct(binanceNetAprOffset, 2)}`
            : `Préstamo ${toPct(chosenAPR, 2)}`))
        : undefined;

      const extraCollateralForTarget = useMemo(() => {
        if (targetLtv <= 0) return 0;
        const neededCollateral = (plannedOutstanding * usdPerUsdt) / targetLtv;
        return Math.max(0, neededCollateral - totals.totalCollateralValue);
      }, [plannedOutstanding, targetLtv, totals.totalCollateralValue, usdPerUsdt]);

      const loyaltyReqs = useMemo(() => {
        if (!loyalty) return null;
        const denom = loyaltyModelActive === "vsTotal" ? totals.total : totals.rest;
        const tiers = (loyalty.tierThresholds ?? []).map((tier) => {
          const required = denom * tier.minRatio;
          const missing = Math.max(0, required - totals.totalLoyalty);
          return { ...tier, required, missing };
        });
        return { denom, tiers };
      }, [loyalty, loyaltyModelActive, totals.total, totals.rest, totals.totalLoyalty]);

      const meetsLowCost = useMemo(() => {
        const withinTarget = loanAmountUsd <= recommendedLoanAtTarget;
        if (lowCostEligibleTiers.length === 0) {
          return totals.total >= minBalancePerks && withinTarget;
        }
        const hasTier = lowCostEligibleTiers.includes(loyaltyTier);
        return totals.total >= minBalancePerks && withinTarget && hasTier;
      }, [loanAmountUsd, recommendedLoanAtTarget, loyaltyTier, totals.total, lowCostEligibleTiers, minBalancePerks]);

      const handleAssetChange = (id, patch) => setAssets(prev => prev.map(a => (a.id === id ? { ...a, ...patch } : a)));

      const addRow = () => {
        const nextId = Math.max(0, ...assets.map(a => a.id)) + 1;
        setAssets(prev => ([...prev, { id: nextId, name: "Nuevo", ticker: "TKN", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: defaultLtv, loanAssigned: 0 }]));
      };
      const removeRow = (id) => setAssets(prev => prev.filter(a => a.id !== id));

      const displayPlatformName = platformName || platformId;


      useEffect(() => {
        document.title = `Simulador de Préstamos / ${displayPlatformName}`;
      }, [displayPlatformName]);

      useEffect(() => {
        applyTheme(themeName);
      }, [themeName]);

      return (
        <div className="min-h-screen w-full text-neutral-900">
          <div className={`${headerClass} text-white`}>
            <div className="mx-auto max-w-7xl px-4 py-6">
              <header className="flex flex-wrap items-end justify-between gap-4">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">{`Simulador de Préstamos / ${displayPlatformName}`}</h1>
                  <p className={`${accentClass}`}>{platformTagline}</p>
                </div>
                <div className="flex flex-col items-end gap-3 sm:flex-row sm:items-center">
                  <div ref={exportMenuRef} className="relative">
                    <input
                      ref={importInputRef}
                      type="file"
                      accept="application/json"
                      className="hidden"
                      onChange={handleImportFile}
                    />
                    <button
                      type="button"
                      onClick={() => setExportMenuOpen((open) => !open)}
                      className="nx-btn text-sm"
                      aria-haspopup="true"
                      aria-expanded={exportMenuOpen}
                    >
                      Plantillas &amp; datos
                    </button>
                    {exportMenuOpen && (
                      <div className="absolute right-0 z-20 mt-3 w-60 rounded-2xl border border-neutral-200 bg-white p-2 text-neutral-700 shadow-2xl">
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm font-semibold hover:bg-neutral-100" onClick={handleExportJSON}>Exportar JSON</button>
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm font-semibold hover:bg-neutral-100" onClick={handleImportRequest}>Importar JSON</button>
                        <div className="my-1 border-t border-neutral-200" />
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100" onClick={handleResetParams}>Reset parámetros</button>
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100" onClick={handleResetAssets}>Reset activos</button>
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100" onClick={handleResetPlanners}>Reset planners</button>
                      </div>
                    )}
                  </div>
                  <div className="flex flex-wrap items-center justify-end gap-4">
                    <div className="flex items-center gap-2">
                      <label className="text-sm font-medium">Plataforma</label>
                      <select value={platformId} onChange={(e) => setPlatformId(PLATFORM_IDS.includes(e.target.value) ? e.target.value : initialPlatformId)} className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80">
                        {PLATFORM_IDS.map((pid) => (
                          <option key={pid} value={pid} className="text-neutral-900">{PLATFORM_CONFIGS[pid]?.name ?? pid}</option>
                        ))}
                      </select>
                    </div>
                    <div className="flex items-center gap-2 text-sm font-medium">
                      <label htmlFor="currency-select">Mostrar en</label>
                      <select
                        id="currency-select"
                        value={currency}
                        onChange={(e) => setSelectedCurrency(e.target.value)}
                        className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80"
                      >
                        {SUPPORTED_CURRENCIES.map((option) => (
                          <option
                            key={option.code}
                            value={option.code}
                            className="text-neutral-900"
                            title={option.label}
                          >
                            {option.code}
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>
                </div>
              </header>
            </div>
          </div>

          <div className="mx-auto max-w-7xl px-4 py-6">
            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
              {(isBinance ? [
                { key: 'loan-current', title: 'Préstamo total', value: formatLoan(binanceOriginalPrincipalTotal), subtle: binanceOriginalPrincipalTotal > 0 ? 'Capital original' : '—' },
                { key: 'loan-plan', title: 'Préstamo neto', value: formatLoan(binanceNetLoanValue), subtle: binanceLoanNetSubtle },
                { key: 'loan-paid', title: 'Pagos hechos', value: formatLoan(binancePaidDisplayTotal), subtle: binancePaidSubtle },
                { key: 'collateral-current', title: 'Colateral actual', value: formatUsd(totals.totalCollateralValue) },
                { key: 'ltv-current', title: 'LTV inicial', value: toPct(binanceInitialLtv, 2), tone: binanceInitialLtvTone, subtle: binanceInitialCollateralSubtle },
                { key: 'ltv-plan', title: 'LTV neto', value: toPct(currentOverallLTV, 2), tone: binanceCurrentLtvTone, subtle: binanceNetLtvSubtle },
                { key: 'apr', title: 'Tasa anual (APR)', value: toPct(chosenAPR, 2), subtle: binanceBorrowLabel || undefined },
                {
                  key: 'apr-net',
                  title: 'Tasa anual neta',
                  value: toPct(netAnnualRate, 2),
                  subtle: binanceNetAprSubtle,
                  tone: netAnnualRate <= chosenAPR ? 'ok' : undefined,
                },
                {
                  key: 'interest-monthly',
                  title: 'Interés mensual estimado',
                  value: formatLoan(monthlyLoanCost),
                  subtle: `${toPct(chosenAPR, 2)} APR base`,
                },
                { key: 'repay-total', title: 'Total a devolver', value: formatLoan(binanceTotalToRepay) },
              ] : [
                { key: 'balance', title: 'Balance total', value: formatUsd(totals.total) },
                { key: 'loyalty', title: loyalty ? (loyalty.kpiLabel || 'Loyalty Tier') : 'Programa', value: loyalty ? loyaltyTier : '—', subtle: loyalty && totals.total < minBalancePerks ? '(balance < mínimo)' : undefined },
                { key: 'apr', title: 'APR crédito', value: toPct(chosenAPR, 2), subtle: meetsLowCost ? 'Low-Cost activo' : undefined },
                { key: 'cap-lowcost', title: 'Cap. Low-Cost (≤20% LTV)', value: formatUsd(capLowCost), subtle: 'potencial' },
                { key: 'ltv-top', title: 'Tope por LTVs', value: formatUsd(totals.maxBorrow) },
                { key: 'loan-target', title: 'Préstamo recomendado (≤20%)', value: formatUsd(recommendedLoanAtTarget) },
                { key: 'interest-total', title: 'Interés hasta repago', value: formatLoan(interestCalc.total), subtle: `${daysUntilRepay} días` },
                { key: 'repay-total', title: 'Total a devolver', value: formatLoan(totalProjectedOutflows), subtle: projectedFinalPayoff > 0 ? `Pago final proyectado ${formatLoan(projectedFinalPayoff)}` : undefined },
                { key: 'earn-monthly', title: 'Earn mensual (hasta)', value: formatUsd(earnMonthly), subtle: earnEligible ? (minBalancePerks > 0 ? `Savings ≥ US$${formatDecimal(minBalancePerks, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}` : undefined) : 'no elegible' },
              ]).map((item) => (
                <KPI key={item.key} title={item.title} value={item.value} subtle={item.subtle} tone={item.tone} variant={item.variant || 'button'} />
              ))}
            </section>

            {isBinance && collateralBreakdown.items.length > 0 && (
              <section className="mb-8">
                <div className="mb-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                  <h3 className="text-lg font-semibold text-neutral-800">Detalle por cripto (Binance Loans)</h3>
                  <p className="text-sm text-neutral-500">LTV, préstamo asignado y APR neta por cada colateral.</p>
                </div>
                <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">
                  {collateralBreakdown.items.map((item) => (
                    <BinanceAssetCard
                      key={item.id}
                      item={item}
                      currency={currency}
                      formatUsd={formatUsd}
                      formatLoan={formatLoan}
                      chosenAPR={chosenAPR}
                    />
                  ))}
                  <CollateralLoanShareCard
                    breakdown={collateralBreakdown.items}
                    currency={currency}
                    formatUsd={formatUsd}
                    formatLoan={formatLoan}
                    loanAmount={plannedOutstanding}
                    overallLTV={binanceLtvAfterPlan}
                    healthyThreshold={ltvHealthyThreshold}
                    warnThreshold={ltvWarnThreshold}
                    autoRepayThreshold={autoRepayLtv}
                  />
                </div>
              </section>
            )}

            <section className="mb-10 grid grid-cols-1 xl:grid-cols-2 gap-6 items-start">
              <div className="space-y-6">
                <Card title="Préstamo & Repago">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 justify-items-center">
                    <Field label={`Monto a pedir (${currency})`} align="center" className="w-full max-w-xs">
                      <LocaleNumberInput
                        value={loanDraftAmount * loanRate}
                        onChange={(v) => setLoanDraftAmount(Math.max(0, v / loanRate))}
                        decimals={2}
                        min={0}
                        className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                      />
                    </Field>
                    <Field label="Fecha de repago" align="center" className="w-full max-w-xs">
                      <input
                        type="date"
                        className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                        value={repayDate}
                        min={todayISO()}
                        onChange={(e)=> setRepayDate(e.target.value)}
                      />
                    </Field>
                    {isBinance && borrowTickerList.length > 0 && (
                      <Field label="Cripto del préstamo" align="center" className="w-full max-w-xs md:col-span-2">
                        <select
                          value={binanceBorrowTicker || ''}
                          onChange={(e) => setParams({ ...params, binanceBorrowTicker: sanitizeTicker(e.target.value) })}
                          className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                        >
                          {borrowTickerList.map((ticker) => (
                            <option key={`borrow-${ticker}`} value={ticker}>
                              {borrowRatesByTicker[ticker]?.label || ticker} · {toPct(borrowRatesByTicker[ticker]?.annual ?? 0, 2)} APR
                            </option>
                          ))}
                        </select>
                      </Field>
                    )}
                  </div>
                  <div className="mt-4 flex flex-col items-center justify-center gap-3 md:flex-row">
                    <button
                      type="button"
                      onClick={handleAddLoanRequest}
                      disabled={!(loanDraftAmount > 0)}
                      className="nx-btn text-sm disabled:cursor-not-allowed disabled:opacity-60"
                    >
                      Agregar préstamo
                    </button>
                    {loanRequests.length > 0 && (
                      <button
                        type="button"
                        onClick={handleClearLoanRequests}
                        className="nx-btn nx-btn-ghost text-sm"
                      >
                        Limpiar préstamos
                      </button>
                    )}
                    <span className="text-sm font-medium text-neutral-600">
                      Total cargado: {formatLoan(loanAmount)}
                    </span>
                  </div>
                  {isBinance && (
                    <p className="mt-6 text-sm text-neutral-500 text-center">
                      Distribución actual: <span className="font-semibold text-neutral-700">{binanceBorrowLabel || '—'}</span>.{' '}
                      {params.manualLoanAllocation
                        ? 'Estás distribuyendo el préstamo manualmente entre los colaterales activos.'
                        : (binanceActiveLoanEntries.length > 0
                          ? 'Se respeta la asignación por cripto que agregaste en la lista.'
                          : 'La herramienta reparte el préstamo de forma proporcional al valor del colateral.')}
                    </p>
                  )}
                  <div className="mt-4 w-full">
                    {loanRequests.length > 0 ? (
                      <div className="rounded-2xl border border-neutral-200 bg-white/70 p-3 shadow-inner">
                        <div className="flex flex-col gap-2">
                          {loanRequests.map((request) => {
                            const ticker = sanitizeTicker(request.ticker || '');
                            const info = isBinance && ticker ? borrowRatesByTicker[ticker] : null;
                            const label = info?.label || (ticker || 'General');
                            const share = loanAmount > 0 ? request.amount / loanAmount : 0;
                            const aprText = info?.annual != null ? toPct(info.annual, 2) : '—';
                            return (
                              <div
                                key={request.id}
                                className="grid grid-cols-1 gap-2 rounded-xl bg-neutral-50 px-3 py-2 text-sm text-neutral-700 shadow-sm md:grid-cols-[minmax(0,1fr)_auto_auto] md:items-center"
                              >
                                <div>
                                  <div className="font-semibold text-neutral-900">{label}</div>
                                  <div className="text-xs text-neutral-500">
                                    {share > 0 ? `${toPct(share, 1)} del total` : 'Sin distribución'}{info ? ` · ${aprText} APR` : ''}
                                  </div>
                                </div>
                                <div className="text-right font-semibold text-neutral-800">
                                  {formatLoan(request.amount)}
                                </div>
                                <div className="text-right">
                                  <button
                                    type="button"
                                    onClick={() => handleRemoveLoanRequest(request.id)}
                                    className="nx-btn nx-btn-ghost nx-btn-sm"
                                  >
                                    Quitar
                                  </button>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ) : (
                      <p className="text-center text-sm text-neutral-500">No agregaste préstamos todavía.</p>
                    )}
                  </div>
                  <div className="mt-6 space-y-3">
                    {isBinance ? (
                      <p className="text-sm text-neutral-500 text-center">
                        Distribución actual: <span className="font-semibold text-neutral-700">{binanceBorrowLabel || '—'}</span>.{' '}
                        {params.manualLoanAllocation
                          ? 'Estás distribuyendo el préstamo manualmente entre los colaterales activos.'
                          : (binanceActiveLoanEntries.length > 0
                            ? 'Se respeta la asignación por cripto que agregaste en la lista.'
                            : 'La herramienta reparte el préstamo de forma proporcional al valor del colateral.')}
                      </p>
                    ) : (
                      <>
                        <Pill label="LTV si pides esto" value={toPct(plannedOverallLTV, 2)} tone={ltvTone} />
                        <Pill label="≤20% LTV (fijo)" value={loanAmountUsd <= recommendedLoanAtTarget ? "Sí" : "No"} tone={loanAmountUsd <= recommendedLoanAtTarget ? "ok" : "warn"} />
                        <Pill label="¿Califica Low-Cost?" value={meetsLowCost ? "Sí" : "No"} tone={meetsLowCost ? "ok" : "warn"} />
                        <Pill label="Margen Low-Cost" value={formatUsd(lowCostHeadroom)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                      </>
                    )}
                  </div>
                </Card>

                <Card title="Proyección del préstamo">
                  <TrendChart data={timeline} currency={currency} rate={loanRate} />
                </Card>

                <CashflowPlanner
                  plan={cashflowPlan}
                  derived={cashflowDerived}
                  onPlanChange={updateCashflowPlan}
                  currency={currency}
                  rate={loanRate}
                  fmt={fmt}
                  loanAmount={loanAmount}
                  chosenAPR={chosenAPR}
                  interestCalc={interestCalc}
                  daysUntilRepay={daysUntilRepay}
                  repayDate={repayDate}
                  totals={totals}
                  targetLtv={targetLtv}
                  marginCallLtv={marginCallLtv}
                  autoRepayLtv={autoRepayLtv}
                  scenarioDefaults={cashflowPlan?.scenarioShocks}
                  focusRingClass={focusRingClass}
                  earnMonthly={earnMonthly}
                  earnEligible={earnEligible}
                  minBalancePerks={minBalancePerks}
                />

              </div>

              <div className="space-y-6">
                <Card title="Salud del préstamo">
                  <LTVGauge value={ltvGaugeValue} zones={ltvGaugeZones} markers={ltvGaugeMarkers} />
                  <div className="mt-2 text-center text-xs text-neutral-500">
                    {ltvScenarioLabel ? `Escenario activo: ${ltvScenarioLabel}` : 'Escenario base sin shocks.'}
                  </div>
                  {cashflowAlerts.length > 0 && (
                    <div className="mt-3 space-y-2 text-xs">
                      {cashflowAlerts.slice(0, 2).map((alert) => {
                        const tone = ALERT_TONE_STYLES[alert.tone] || ALERT_TONE_STYLES.info;
                        return (
                          <div
                            key={alert.id}
                            className={`rounded-xl border px-3 py-2 ${tone.border} ${tone.bg} ${tone.text}`}
                          >
                            {alert.message}
                          </div>
                        );
                      })}
                    </div>
                  )}
                  <div className="mt-4 space-y-2">
                    {isBinance ? (
                      <>
                        <Line label="LTV inicial" value={toPct(binanceInitialLtv, 2)} tone={binanceInitialLtvTone} />
                        <Line label="LTV neto" value={toPct(currentOverallLTV, 2)} tone={binanceCurrentLtvTone} />
                        <Line label="LTV proyectado (cashflow)" value={Number.isFinite(ltvGaugeValue) ? toPct(ltvGaugeValue, 2) : '∞'} tone={ltvTone} />
                        <Line label="Rango saludable" value={`≤ ${toPct(ltvHealthyThreshold, 0)}`} muted />
                        <Line label="Riesgo medio" value={binanceCautionLabel} muted />
                        <Line label="Margin call" value={toPct(marginCallLtv, 0)} muted />
                        <Line label="Auto-liquidación" value={toPct(autoRepayLtv, 0)} muted />
                        <Line label="Buffer actual" value={formatBinanceBufferValue(currentLiquidationBuffer)} tone={toneForBinanceBuffer(currentLiquidationBuffer)} />
                        <Line label="Buffer simulado" value={formatBinanceBufferValue(binanceLiquidationBuffer)} tone={toneForBinanceBuffer(binanceLiquidationBuffer)} />
                      </>
                    ) : (
                      <>
                        <Line label="LTV proyectado (cashflow)" value={Number.isFinite(ltvGaugeValue) ? toPct(ltvGaugeValue, 1) : '∞'} tone={ltvTone} />
                        <Line label="LTV actual" value={toPct(currentOverallLTV, 1)} muted />
                        <Line label="Objetivo Low-Cost" value={toPct(targetLtv, 0)} muted />
                        <Line label="Margin call" value={toPct(marginCallLtv, 0)} muted />
                        <Line label="Auto-repay" value={toPct(autoRepayLtv, 0)} muted />
                        <Line label="Cap Low-Cost" value={formatUsd(capLowCost)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                      </>
                    )}
                  </div>
                </Card>

                <BenchmarkCeFiDeFi
                  config={benchmarkConfig}
                  onChange={updateBenchmarkConfig}
                  fmt={fmt}
                  currency={currency}
                  rate={loanRate}
                  loanAmount={loanAmount}
                  chosenAPR={chosenAPR}
                  daysUntilRepay={daysUntilRepay}
                  scenarioName={ltvScenarioLabel}
                  cashflowNet={cashflowDerived?.netBalanceFinal}
                  defaultMatrix={baseBenchmarkConfig?.rateMatrix}
                />

                {!isBinance && (
                  <Card title="Diagnóstico & Sugerencias">
                  <ul className="list-disc pl-5 space-y-2 text-sm">
                    {loyalty ? (
                      <li>
                      Tu {loyalty.ratioLabel ?? `ratio ${loyalty.tokenTicker?.toUpperCase() || ''}`} es <b>{toPct(totals.ratioVsRest, 2)} vs resto</b> / <b>{toPct(totals.ratioVsTotal, 2)} vs total</b>. Modelo activo: <b>{loyaltyModelActive === "vsTotal" ? "vs total" : "vs resto"}</b>. Nivel actual: <b>{loyaltyTier}</b>.
                        {totals.total < minBalancePerks && (<span className="text-neutral-600"> (El balance total no supera el mínimo de perks).</span>)}
                      </li>
                    ) : (
                      <li>Esta plataforma no requiere ratio de token para acceder a mejores tasas: el enfoque es puramente por colateral.</li>
                    )}
                    {loyalty && loyaltyReqs?.tiers?.length ? (
                      <li>
                        {loyaltyReqs.tiers.map((tier, idx) => (
                          <span key={tier.label}>{idx > 0 ? ' · ' : ''}Para <b>{tier.label}</b> faltan {formatUsd(tier.missing)}</span>
                        ))}
                      </li>
                    ) : null}
                    <li>
                      Con tu colateral actual, el tope por LTVs es {formatUsd(totals.maxBorrow)}. El cap Low-Cost (≤{toPct(targetLtv, 0)}) permite pedir hasta {formatUsd(capLowCost)} y deja {formatUsd(lowCostHeadroom)} de margen.
                    </li>
                    <li>
                      Para sostener un préstamo neto de {formatLoan(plannedOutstanding)} y mantener ≤{toPct(targetLtv, 0)} LTV se requieren {formatUsd(extraCollateralForTarget)} adicionales en colateral.
                    </li>
                    <li>
                      APR estimado: <b>{toPct(chosenAPR, 2)}</b>{isBinance && binanceBorrowLabel ? ` (${binanceBorrowLabel})` : ''}. Interés hasta repago ({daysUntilRepay} días): {formatLoan(interestCalc.total)}.{interestCalc.early > 0 && <span> Incluye interés por "early rule".</span>}
                    </li>
                    <li>
                      Earn (flex) mensual estimado {earnEligible ? (minBalancePerks > 0 ? "(tope)" : "") : (minBalancePerks > 0 ? "(requiere balance mínimo)" : "(no elegible)")}: <b>{formatUsd(earnMonthly)}</b>.
                    </li>
                  </ul>
                  </Card>
                )}
              </div>
            </section>

            <section className="mb-10">
              <div className="flex flex-col items-center gap-4 md:flex-row md:items-center md:justify-between mb-4">
                <h2 className="text-xl font-semibold text-center md:text-left">Activos y colateral</h2>
                <div className="flex flex-wrap items-center justify-center gap-2">
                  <button onClick={addRow} className="nx-btn text-sm">Añadir activo</button>
                  <button onClick={() => { localStorage.removeItem(storageKeys.assets); setAssets(sanitizeAssets(platformDefaultAssets)); }} className="nx-btn nx-btn-ghost text-sm">Reset</button>
                  <label className="flex items-center gap-2 rounded-full border border-neutral-200 bg-white px-3 py-1 text-xs font-medium shadow-sm">
                    <input type="checkbox" ref={autoMasterRef} className="h-4 w-4" checked={allAuto} onChange={(e) => handleToggleAllAuto(e.target.checked)} />
                    Auto (todos)
                  </label>
                  <label className="flex items-center gap-2 rounded-full border border-neutral-200 bg-white px-3 py-1 text-xs font-medium shadow-sm">
                    <input type="checkbox" ref={collateralMasterRef} className="h-4 w-4" checked={allCollateral} onChange={(e) => handleToggleAllCollateral(e.target.checked)} />
                    Colateral (todos)
                  </label>
                  <label className="flex items-center gap-2 rounded-full border border-amber-200 bg-amber-50 px-3 py-1 text-xs font-medium text-amber-700 shadow-sm">
                    <input
                      type="checkbox"
                      className="h-4 w-4 accent-amber-500"
                      checked={!!params.manualLoanAllocation}
                      onChange={(e) => setParams({ ...params, manualLoanAllocation: e.target.checked })}
                    />
                    Asignar préstamo manualmente
                  </label>
                </div>
                {params.manualLoanAllocation && (
                  <p className="mt-2 text-center text-xs text-neutral-500">Distribuí el préstamo por activo en la columna "Préstamo asignado" para reflejar cómo Binance exige definir el colateral.</p>
                )}
              </div>

              <div className="overflow-x-auto rounded-2xl nx-card bg-white">
                <table className="min-w-full text-sm">
                  <thead className="bg-neutral-900 text-white sticky top-0 z-10">
                    <tr>
                      <Th>Activo</Th>
                      <Th>Ticker</Th>
                      <Th>Cantidad</Th>
                      <Th>Precio (USD)</Th>
                      <Th>Auto</Th>
                      <Th>Valor</Th>
                      <Th>Préstamo asignado (USD)</Th>
                      <Th>Colateral</Th>
                      <Th>LTV (fijo)</Th>
                      <Th>APR Earn (flex máx)</Th>
                      <Th></Th>
                    </tr>
                  </thead>
                  <tbody>
                    {totals.withValue.map((a) => (
                      <tr key={a.id} className="border-t border-neutral-100 even:bg-neutral-50 hover:bg-neutral-100/50 transition-colors">
                        <Td align="center">
                          <input value={a.name} onChange={(e) => handleAssetChange(a.id, { name: e.target.value })} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input value={a.ticker} onChange={(e) => { const newT = sanitizeTicker(e.target.value); const newL = ltvByTicker[newT] ?? defaultLtv; handleAssetChange(a.id, { ticker: newT, ltv: newL }); if (a.priceAuto !== false) { fetchPricesForTickers([newT]); } }} className="w-24 rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <LocaleNumberInput
                            value={a.qty}
                            onChange={(v) => handleAssetChange(a.id, { qty: Math.max(0, v) })}
                            decimals={4}
                            className={`w-full rounded-xl border border-neutral-300 px-2 py-1 text-center focus:outline-none focus:ring-2 ${focusRingClass}`}
                          />
                        </Td>
                        <Td align="center">
                          <LocaleNumberInput
                            value={a.price}
                            onChange={(v) => handleAssetChange(a.id, { price: Math.max(0, v) })}
                            decimals={4}
                            disabled={a.priceAuto !== false}
                            className={`w-full rounded-xl border border-neutral-300 px-2 py-1 text-center focus:outline-none focus:ring-2 ${focusRingClass} disabled:bg-neutral-50 disabled:text-neutral-400`}
                          />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" checked={a.priceAuto !== false} onChange={(e) => { handleAssetChange(a.id, { priceAuto: e.target.checked }); if (e.target.checked) { fetchPricesForTickers([a.ticker]); } }} className="h-5 w-5" />
                        </Td>
                        <Td align="center" className="font-medium">{formatUsd(a.value)}</Td>
                        <Td align="center">
                          <LocaleNumberInput
                            value={a.loanAssigned}
                            onChange={(v) => handleAssetChange(a.id, { loanAssigned: Math.max(0, v) })}
                            decimals={2}
                            disabled={!params.manualLoanAllocation}
                            className={`w-full rounded-xl border border-neutral-300 px-2 py-1 text-center focus:outline-none focus:ring-2 ${focusRingClass} ${!params.manualLoanAllocation ? 'bg-neutral-50 text-neutral-400' : ''}`}
                          />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" title="Si está activo, este activo cuenta como colateral para LTV y Tope por LTVs" checked={a.useAsCollateral} onChange={(e) => handleAssetChange(a.id, { useAsCollateral: e.target.checked })} className="h-5 w-5" />
                        </Td>
                        <Td align="center" title="Política de LTV fija por plataforma">
                          <span className="inline-block rounded-xl bg-neutral-100 px-3 py-1 font-semibold">{pct(ltvByTicker[sanitizeTicker(a.ticker)] ?? a.ltv ?? 0)}</span>
                        </Td>
                        <Td align="center" title="Flexible Savings – tasa tope mostrada públicamente">
                          <span className="inline-block rounded-xl bg-blue-50 text-blue-700 px-3 py-1 font-semibold">{pct(earnAprTop[sanitizeTicker(a.ticker)] ?? 0)}</span>
                        </Td>
                        <Td align="center">
                          <button onClick={() => removeRow(a.id)} className="nx-btn nx-btn-ghost nx-btn-sm">Borrar</button>
                        </Td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="mb-10">
              <Card title="Ideas para un simulador único">
                <p className="text-sm text-neutral-600">Backlog sugerido para diferenciar la herramienta y hacerla monetizable.</p>
                <ol className="mt-3 list-decimal space-y-3 pl-5 text-sm text-neutral-700">
                  {improvementIdeas.map((idea) => (
                    <li key={idea.id}>
                      <div className="font-semibold text-neutral-900">{idea.title}</div>
                      <p className="text-xs text-neutral-500 mt-1">{idea.description}</p>
                    </li>
                  ))}
                </ol>
              </Card>
            </section>

            {disclaimers?.finePrint && (
              <p className="mb-6 text-xs text-neutral-500 text-center">{disclaimers.finePrint}</p>
            )}

            <footer className="text-xs text-neutral-500 space-y-1 text-center md:text-left">
              <p>© {new Date().getFullYear()} – Demo técnica. Estilos y métricas se adaptan según la plataforma elegida.</p>
              <p>Activos digitales: actualización automática cada {LIVE_REFRESH_SECONDS} segundos (fuente CoinGecko). Tipos de cambio oficiales: actualización cada {FX_REFRESH_MINUTES} minutos (exchangerate.host).</p>
            </footer>
      </div>
    </div>
  );
}

    function CashflowPlanner({
      plan,
      derived,
      onPlanChange,
      currency,
      rate,
      fmt,
      loanAmount,
      chosenAPR,
      interestCalc,
      daysUntilRepay,
      repayDate,
      totals,
      targetLtv,
      marginCallLtv,
      autoRepayLtv,
      scenarioDefaults,
      focusRingClass,
      earnMonthly,
      earnEligible,
      minBalancePerks,
    }) {
      const safePlan = plan || {};
      const baseScenarios = { base: 0, bear: -0.25, bull: 0.15, ...(scenarioDefaults || {}) };
      const combinedShocks = { ...baseScenarios, ...(safePlan.scenarioShocks || {}), ...(derived?.scenarioShocks || {}) };
      const scenarioKeys = Object.keys(combinedShocks);
      const activeScenario = scenarioKeys.includes(safePlan.activeScenario)
        ? safePlan.activeScenario
        : (derived?.activeScenario && scenarioKeys.includes(derived.activeScenario) ? derived.activeScenario : scenarioKeys[0]);
      const timeline = derived?.timeline || [];
      const chartData = derived?.chartData || [];
      const fundingGaps = derived?.fundingGaps || [];
      const alerts = useMemo(
        () => normalizeAlertItems(derived?.alerts),
        [derived],
      );
      const netFinal = derived?.netBalanceFinal ?? loanAmount;
      const minNet = derived?.minNetBalance ?? netFinal;
      const outstandingPlan = derived?.outstandingAfterPlan ?? loanAmount;
      const scheduledPrincipalPlan = derived?.scheduledPrincipal ?? 0;
      const scheduledInterestPlan = derived?.scheduledInterest ?? 0;
      const projectedPayoffPlan = derived?.projectedFinalPayoff ?? Math.max(0, outstandingPlan);
      const totalScheduledOutflows = scheduledPrincipalPlan + scheduledInterestPlan;

      const scenarioLabels = { base: 'Base', bear: 'Bajista', bull: 'Alcista' };

      const normalizeTicker = (value) => (typeof value === 'string' ? value.trim().toUpperCase() : '');
      const loanByTicker = derived?.loanByTicker || {};
      const outstandingByTicker = derived?.outstandingByTicker || {};
      const paymentTickerOptions = useMemo(() => {
        const bucket = new Set();
        Object.keys(loanByTicker || {}).forEach((ticker) => {
          const key = normalizeTicker(ticker);
          if (key) bucket.add(key);
        });
        Object.keys(outstandingByTicker || {}).forEach((ticker) => {
          const key = normalizeTicker(ticker);
          if (key) bucket.add(key);
        });
        (totals?.withValue || []).forEach((asset) => {
          if (asset?.ticker) {
            const key = normalizeTicker(asset.ticker);
            if (key) bucket.add(key);
          }
        });
        return Array.from(bucket).sort();
      }, [loanByTicker, outstandingByTicker, totals?.withValue]);
      const defaultPaymentTicker = paymentTickerOptions[0] || '';

      const setScenarioShock = (key, valuePct) => {
        const pct = Number(valuePct);
        if (!Number.isFinite(pct)) return;
        onPlanChange((prev) => ({
          ...prev,
          scenarioShocks: { ...(prev?.scenarioShocks || {}), [key]: pct / 100 },
        }));
      };

      const setActiveScenario = (value) => {
        if (!scenarioKeys.includes(value)) return;
        onPlanChange({ activeScenario: value });
      };

      const updateListItem = (listName, id, patch) => {
        onPlanChange((prev) => ({
          ...prev,
          [listName]: (prev?.[listName] || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
        }));
      };

      const removeListItem = (listName, id) => {
        onPlanChange((prev) => ({
          ...prev,
          [listName]: (prev?.[listName] || []).filter((item) => item.id !== id),
        }));
      };

      const addPayment = () => {
        const nextId = Math.max(0, ...((safePlan.payments || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          payments: [...(prev?.payments || []), {
            id: nextId,
            date: repayDate,
            amount: Math.max(0, loanAmount || 0),
            label: `Pago ${nextId}`,
            ticker: defaultPaymentTicker,
          }],
        }));
      };

      const addEarn = () => {
        const nextId = Math.max(0, ...((safePlan.earns || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          earns: [...(prev?.earns || []), {
            id: nextId,
            startDate: todayISO(),
            endDate: repayDate,
            frequency: 'monthly',
            amount: Math.max(0, earnMonthly || 0),
            platform: '',
            token: '',
            label: `Earn ${nextId}`,
          }],
        }));
      };

      const addManual = () => {
        const nextId = Math.max(0, ...((safePlan.manual || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          manual: [...(prev?.manual || []), {
            id: nextId,
            date: todayISO(),
            amount: 1000,
            direction: 'outflow',
            collateralImpact: 'increase',
            label: `Evento ${nextId}`,
          }],
        }));
      };

      const formatMoney = (value) => fmt(value * rate, currency);

      const summaryTiles = [
        { label: 'Balance final proyectado', value: formatMoney(netFinal), tone: netFinal >= 0 ? 'text-emerald-600' : 'text-rose-600', hint: `Mínimo ${formatMoney(minNet)}` },
        { label: 'Capital pendiente (plan)', value: formatMoney(outstandingPlan), tone: 'text-neutral-700' },
        { label: 'Pagos programados', value: formatMoney(totalScheduledOutflows), tone: totalScheduledOutflows > 0 ? 'text-neutral-700' : 'text-neutral-500', hint: totalScheduledOutflows > 0 ? `Capital ${formatMoney(scheduledPrincipalPlan)} · Interés cancelado ${formatMoney(scheduledInterestPlan)}` : 'Sin pagos programados' },
        { label: 'Pago final proyectado', value: formatMoney(projectedPayoffPlan), tone: projectedPayoffPlan >= 0 ? 'text-neutral-700' : 'text-rose-600', hint: outstandingPlan > 0 ? 'Restante tras plan' : 'Cubierto por plan' },
        { label: 'Earn mensual', value: fmt(earnMonthly * rate, currency), tone: 'text-neutral-700', hint: earnEligible ? 'Earn activo' : 'Earn inactivo' },
      ];

      return (
        <Card title="Planificador de cashflow">
          <div className="space-y-6 text-sm">
            <div className="grid grid-cols-1 gap-3">
              {summaryTiles.map((tile) => (
                <div key={tile.label} className="rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                  <div className="text-xs text-neutral-500 uppercase">{tile.label}</div>
                  <div className={`text-lg font-semibold ${tile.tone}`}>{tile.value}</div>
                  {tile.hint && <div className="text-[11px] text-neutral-500">{tile.hint}</div>}
                </div>
              ))}
            </div>

            <div>
              <h4 className="mb-2 text-sm font-semibold text-neutral-700">Curva de saldo neto</h4>
              <TrendChart data={chartData} currency={currency} rate={rate} />
            </div>

            <div className="rounded-2xl border border-neutral-200 bg-white p-4 space-y-4">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div>
                  <div className="text-sm font-semibold text-neutral-700">Escenarios de estrés</div>
                  <p className="text-xs text-neutral-500">Define shocks de precio (%) y selecciona cuál alimenta el velocímetro de LTV.</p>
                </div>
                <select value={activeScenario} onChange={(e) => setActiveScenario(e.target.value)} className={`rounded-full border border-neutral-300 px-3 py-1.5 text-sm font-semibold focus:outline-none focus:ring-2 ${focusRingClass}`}>
                  {scenarioKeys.map((key) => (
                    <option key={key} value={key}>{scenarioLabels[key] || key}</option>
                  ))}
                </select>
              </div>
              <div className="grid grid-cols-1 gap-3 text-xs sm:grid-cols-2 xl:grid-cols-3">
                {scenarioKeys.map((key) => (
                  <div key={`scenario-${key}`} className={`rounded-2xl border ${activeScenario === key ? 'border-blue-400 bg-blue-50/40' : 'border-neutral-200 bg-neutral-50/60'} p-3 space-y-2`}>
                    <div className="flex items-center justify-between">
                      <span className="font-semibold text-neutral-700">{scenarioLabels[key] || key}</span>
                      <LocaleNumberInput
                        value={(combinedShocks[key] ?? 0) * 100}
                        onChange={(v) => setScenarioShock(key, v)}
                        decimals={2}
                        allowNegative
                        className={`w-20 rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                      />
                    </div>
                    <div className="text-[11px] text-neutral-500">Shock sobre colateral</div>
                    <div className="text-[11px] text-neutral-600">LTV final: {derived?.scenarioSummaries?.[key]?.last != null && Number.isFinite(derived.scenarioSummaries[key].last) ? formatPercent(derived.scenarioSummaries[key].last, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) : '—'}</div>
                    <div className="text-[11px] text-neutral-600">Saldo: {derived?.scenarioSummaries?.[key]?.net != null ? formatMoney(derived.scenarioSummaries[key].net) : formatMoney(netFinal)}</div>
                  </div>
                ))}
              </div>
              {alerts.length > 0 && (
                <div className="space-y-2 text-xs">
                  {alerts.map((alert) => {
                    const tone = ALERT_TONE_STYLES[alert.tone] || ALERT_TONE_STYLES.info;
                    return (
                      <div
                        key={alert.id}
                        className={`rounded-2xl border px-3 py-2 ${tone.border} ${tone.bg} ${tone.text}`}
                      >
                        {alert.message}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            {fundingGaps.length > 0 && (
              <div className="rounded-2xl border border-rose-200 bg-rose-50 px-4 py-3 text-xs text-rose-700">
                <div className="font-semibold mb-1">Gaps de liquidez detectados</div>
                <ul className="list-disc pl-5 space-y-1">
                  {fundingGaps.map((gap, idx) => (
                    <li key={`gap-${idx}`}>Día {gap.day} ({gap.date}) · saldo neto {formatMoney(gap.net)}</li>
                  ))}
                </ul>
              </div>
            )}

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Pagos programados</h4>
                <button className="nx-btn nx-btn-sm" onClick={addPayment}>Agregar pago</button>
              </div>
              <div className="space-y-3">
                {(safePlan.payments || []).length === 0 && (
                  <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">No hay pagos definidos. Añade uno para proyectar obligaciones.</div>
                )}
                {(safePlan.payments || []).map((item) => (
                  <div key={item.id} className="grid grid-cols-1 md:grid-cols-5 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3 text-xs">
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Fecha</div>
                      <input type="date" value={item.date || ''} onChange={(e) => updateListItem('payments', item.id, { date: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Monto total</div>
                      <LocaleNumberInput
                        value={item.amount ?? item.principal ?? 0}
                        onChange={(v) => updateListItem('payments', item.id, { amount: Math.max(0, v) })}
                        decimals={2}
                        min={0}
                        className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                      />
                      <div className="mt-1 text-[10px] text-neutral-500">Se descuenta interés acumulado primero.</div>
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Cripto</div>
                      <select
                        value={item.ticker || ''}
                        onChange={(e) => updateListItem('payments', item.id, { ticker: normalizeTicker(e.target.value) })}
                        className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}
                      >
                        <option value="">General / proporcional</option>
                        {paymentTickerOptions.map((ticker) => (
                          <option key={`payment-token-${ticker}`} value={ticker}>{ticker}</option>
                        ))}
                      </select>
                    </div>
                    <div className="md:col-span-1">
                      <div className="text-[11px] uppercase text-neutral-400">Nota</div>
                      <input type="text" value={item.label || ''} onChange={(e) => updateListItem('payments', item.id, { label: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div className="flex items-end justify-end sm:col-span-2 xl:col-span-1">
                      <button className="text-rose-600 hover:underline" onClick={() => removeListItem('payments', item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Flujos de Earn / staking</h4>
                <button className="nx-btn nx-btn-sm" onClick={addEarn}>Agregar flujo</button>
              </div>
              <div className="space-y-3">
                {(safePlan.earns || []).length === 0 && (
                  <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">Suma tus estrategias de rendimiento para cubrir el costo del préstamo.</div>
                )}
                {(safePlan.earns || []).map((item) => (
                  <div key={item.id} className="grid grid-cols-1 gap-2 sm:grid-cols-2 xl:grid-cols-6 rounded-2xl border border-neutral-200 bg-white px-4 py-3 text-xs">
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Inicio</div>
                      <input type="date" value={item.startDate || ''} onChange={(e) => updateListItem('earns', item.id, { startDate: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Fin</div>
                      <input type="date" value={item.endDate || ''} onChange={(e) => updateListItem('earns', item.id, { endDate: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Frecuencia</div>
                      <select value={item.frequency || 'monthly'} onChange={(e) => updateListItem('earns', item.id, { frequency: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                        <option value="daily">Diario</option>
                        <option value="weekly">Semanal</option>
                        <option value="monthly">Mensual</option>
                      </select>
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Monto</div>
                      <LocaleNumberInput
                        value={item.amount ?? 0}
                        onChange={(v) => updateListItem('earns', item.id, { amount: Math.max(0, v) })}
                        decimals={2}
                        min={0}
                        className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                      />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Origen</div>
                      <input type="text" value={item.platform || ''} onChange={(e) => updateListItem('earns', item.id, { platform: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div className="flex items-end justify-between gap-2 sm:col-span-2 xl:col-span-1">
                      <input type="text" value={item.token || ''} placeholder="Token" onChange={(e) => updateListItem('earns', item.id, { token: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      <button className="text-rose-600 hover:underline" onClick={() => removeListItem('earns', item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Eventos manuales</h4>
                <button className="nx-btn nx-btn-sm" onClick={addManual}>Agregar evento</button>
              </div>
              <div className="space-y-3">
                {(safePlan.manual || []).length === 0 && (
                  <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">Registra recargas de colateral o retiros planificados.</div>
                )}
                {(safePlan.manual || []).map((item) => (
                  <div key={item.id} className="grid grid-cols-1 gap-2 sm:grid-cols-2 xl:grid-cols-5 rounded-2xl border border-neutral-200 bg-white px-4 py-3 text-xs">
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Fecha</div>
                      <input type="date" value={item.date || ''} onChange={(e) => updateListItem('manual', item.id, { date: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Monto</div>
                      <LocaleNumberInput
                        value={item.amount ?? 0}
                        onChange={(v) => updateListItem('manual', item.id, { amount: v })}
                        decimals={2}
                        allowNegative
                        className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                      />
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Dirección</div>
                      <select value={item.direction || 'outflow'} onChange={(e) => updateListItem('manual', item.id, { direction: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                        <option value="outflow">Salida</option>
                        <option value="inflow">Entrada</option>
                      </select>
                    </div>
                    <div>
                      <div className="text-[11px] uppercase text-neutral-400">Colateral</div>
                      <select value={item.collateralImpact || 'increase'} onChange={(e) => updateListItem('manual', item.id, { collateralImpact: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                        <option value="increase">Aumenta</option>
                        <option value="decrease">Disminuye</option>
                        <option value="none">Sin cambio</option>
                      </select>
                    </div>
                    <div className="flex items-end justify-between gap-2 sm:col-span-2 xl:col-span-1">
                      <input type="text" value={item.label || ''} placeholder="Descripción" onChange={(e) => updateListItem('manual', item.id, { label: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      <button className="text-rose-600 hover:underline" onClick={() => removeListItem('manual', item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="rounded-2xl border border-neutral-200 bg-neutral-50/70 px-4 py-3 text-[11px] text-neutral-600 space-y-1">
              <div>APR: {formatPercent(chosenAPR, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} · Interés total estimado: {formatMoney(interestCalc?.total || 0)} · Plazo restante: {daysUntilRepay} días</div>
              <div>Colateral: {formatMoney(totals.totalCollateralValue || 0)} · Objetivo LTV: {formatPercent(targetLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })} · Margin call: {formatPercent(marginCallLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })} · Auto-repay: {formatPercent(autoRepayLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</div>
            </div>
          </div>
        </Card>
      );
    }

    function computeCashflowProjectionsDetailed(plan, context = {}) {
      const {
        loanAmount = 0,
        apr = 0,
        repayDate,
        totalCollateralValue = 0,
        targetLtv = 0.2,
        marginCallLtv = 0.7,
        autoRepayLtv = 0.85,
        scenarioShocks = {},
      } = context;
      const safePlan = plan || {};
      const baseScenarios = { base: 0, bear: -0.25, bull: 0.15, ...(safePlan.scenarioShocks || {}), ...(scenarioShocks || {}) };
      const scenarioKeys = Object.keys(baseScenarios);
      const activeScenario = scenarioKeys.includes(safePlan.activeScenario) ? safePlan.activeScenario : scenarioKeys[0];
      const msInDay = 24 * 60 * 60 * 1000;
      const today = new Date(); today.setHours(0, 0, 0, 0);
      const parseDate = (value, fallback) => {
        if (value instanceof Date && !Number.isNaN(value.getTime())) {
          const d = new Date(value.getTime()); d.setHours(0, 0, 0, 0); return d;
        }
        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
          const d = new Date(value); if (!Number.isNaN(d.getTime())) { d.setHours(0,0,0,0); return d; }
        }
        return fallback ? new Date(fallback.getTime()) : new Date(today.getTime());
      };
      const endDate = parseDate(repayDate, today);
      const events = [];
      const pushEvent = (event) => {
        const date = parseDate(event.date, today);
        events.push({ ...event, date });
      };
      pushEvent({ id: 'loan', type: 'loan', date: today, amount: loanAmount, label: 'Desembolso' });

      (safePlan.payments || []).forEach((item, idx) => {
        const total = Math.max(0, Number(item.amount ?? item.principal) || 0);
        if (!(total > 0)) return;
        pushEvent({
          id: `payment-${item.id ?? idx}`,
          type: 'payment',
          date: item.date || endDate,
          label: item.label || `Pago ${idx + 1}`,
          amount: -total,
          paymentTotal: total,
          ticker: item.ticker ? normalizeTicker(item.ticker) : undefined,
        });
      });

      const freqToDays = { daily: 1, weekly: 7, monthly: 30 };
      (safePlan.earns || []).forEach((item, idx) => {
        const step = freqToDays[item.frequency] || 30;
        const amount = Number(item.amount) || 0;
        if (!(amount > 0) || step <= 0) return;
        let current = parseDate(item.startDate, today);
        const limit = parseDate(item.endDate, endDate);
        let count = 0;
        while (current.getTime() <= limit.getTime() && count < 120) {
          pushEvent({ id: `earn-${item.id ?? idx}-${count}`, type: 'earn', date: current, label: item.label || `Earn ${idx + 1}`, amount });
          current = new Date(current.getTime() + step * msInDay);
          count += 1;
        }
      });

      (safePlan.manual || []).forEach((item, idx) => {
        const amount = Number(item.amount) || 0;
        if (!(amount > 0)) return;
        const direction = item.direction === 'inflow' ? 1 : -1;
        const impact = item.collateralImpact;
        const collateralDelta = impact === 'increase' ? amount : impact === 'decrease' ? -amount : 0;
        pushEvent({
          id: `manual-${item.id ?? idx}`,
          type: 'manual',
          date: item.date || today,
          label: item.label || `Evento ${idx + 1}`,
          amount: amount * direction,
          collateralDelta,
        });
      });

      events.sort((a, b) => a.date.getTime() - b.date.getTime());

      let outstanding = loanAmount;
      let collateral = Math.max(0, totalCollateralValue);
      let cumulativeCash = 0;
      let accruedInterest = 0;
      let totalEarn = 0;
      let totalOutflows = 0;
      let scheduledPrincipal = 0;
      let scheduledInterest = 0;
      let collateralDeltaTotal = 0;
      let projectedFinalPayoff = 0;
      let minNet = Number.POSITIVE_INFINITY;
      const timeline = [];
      const alerts = [];
      const fundingGaps = [];
      const scenarioSummaries = {};
      scenarioKeys.forEach((key) => { scenarioSummaries[key] = { last: 0, net: loanAmount, max: 0 }; });

      let lastDate = today;
      const addSnapshot = (event) => {
        const day = Math.max(0, Math.round((event.date.getTime() - today.getTime()) / msInDay));
        const scenarioStats = {};
        scenarioKeys.forEach((key) => {
          const shock = Number(baseScenarios[key]) || 0;
          const adjustedCollateral = collateral * (1 + shock);
          const ltv = adjustedCollateral > 0 ? outstanding / adjustedCollateral : (outstanding > 0 ? Number.POSITIVE_INFINITY : 0);
          scenarioStats[key] = ltv;
          scenarioSummaries[key].last = ltv;
          scenarioSummaries[key].net = cumulativeCash - accruedInterest;
          scenarioSummaries[key].max = Math.max(scenarioSummaries[key].max || 0, Number.isFinite(ltv) ? ltv : 0);
          if (ltv >= autoRepayLtv) {
            alerts.push(`Escenario ${key} supera auto-liquidación (${formatPercent(autoRepayLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}) en día ${day}.`);
          } else if (ltv >= marginCallLtv) {
            alerts.push(`Escenario ${key} supera margin call (${formatPercent(marginCallLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}) en día ${day}.`);
          }
        });
        const netBalance = cumulativeCash - accruedInterest;
        minNet = Math.min(minNet, netBalance);
        if (netBalance < 0) {
          const existingGap = fundingGaps.find((gap) => gap.day === day);
          if (!existingGap) fundingGaps.push({ day, date: event.date.toISOString().slice(0, 10), net: netBalance });
        }
        timeline.push({
          id: event.id,
          type: event.type,
          label: event.label,
          date: event.date.toISOString().slice(0, 10),
          day,
          amount: event.amount,
          interestAccrued: accruedInterest,
          cashCumulative: cumulativeCash,
          netBalance,
          outstanding,
          scenarioStats,
          totalCost: totalOutflows,
          totalEarn,
        });
        lastDate = event.date;
      };

      events.forEach((event) => {
        const deltaDays = Math.max(0, Math.round((event.date.getTime() - lastDate.getTime()) / msInDay));
        if (deltaDays > 0 && outstanding > 0) {
          const interest = outstanding * (Math.pow(1 + apr / 365, deltaDays) - 1);
          accruedInterest += interest;
        }
        cumulativeCash += event.amount || 0;
        if ((event.amount || 0) >= 0) totalEarn += event.amount || 0; else totalOutflows += Math.abs(event.amount || 0);
        if (event.type === 'payment') {
          const totalPayment = Math.max(0, Number(event.paymentTotal) || Math.abs(event.amount) || 0);
          if (totalPayment > 0) {
            let remainingPayment = totalPayment;
            const interestPaid = Math.min(accruedInterest, remainingPayment);
            if (interestPaid > 0) {
              scheduledInterest += interestPaid;
              accruedInterest = Math.max(0, accruedInterest - interestPaid);
              remainingPayment -= interestPaid;
            }
            if (remainingPayment > 0) {
              const principalPaid = Math.min(outstanding, remainingPayment);
              if (principalPaid > 0) {
                scheduledPrincipal += principalPaid;
                outstanding = Math.max(0, outstanding - principalPaid);
                remainingPayment -= principalPaid;
              }
            }
            if (remainingPayment > 0) {
              cumulativeCash += remainingPayment;
              totalOutflows = Math.max(0, totalOutflows - remainingPayment);
            }
          }
        }
        if (event.collateralDelta) {
          const delta = Number(event.collateralDelta) || 0;
          collateralDeltaTotal += delta;
          collateral = Math.max(0, collateral + delta);
        }
        addSnapshot(event);
      });

      if (endDate.getTime() > lastDate.getTime() && outstanding > 0) {
        const deltaDays = Math.max(0, Math.round((endDate.getTime() - lastDate.getTime()) / msInDay));
        if (deltaDays > 0) {
          const interest = outstanding * (Math.pow(1 + apr / 365, deltaDays) - 1);
          accruedInterest += interest;
        }
        addSnapshot({ id: 'carry', type: 'carry', label: 'Interés acumulado', date: endDate, amount: 0 });
      }

      const outstandingAfterPlan = outstanding;
      const collateralAfterPlan = collateral;
      const accruedAfterPlan = accruedInterest;

      if (outstanding > 0 || accruedInterest > 0) {
        projectedFinalPayoff = outstanding + accruedInterest;
        const payoff = -projectedFinalPayoff;
        cumulativeCash += payoff;
        totalOutflows += Math.abs(payoff);
        outstanding = 0;
        accruedInterest = 0;
        addSnapshot({ id: 'closure', type: 'closure', label: 'Pago final proyectado', date: endDate, amount: payoff });
      }

      const chartData = timeline.map((item) => ({ day: item.day, cost: item.totalCost, earn: item.totalEarn, balance: item.netBalance }));
      const uniqueAlerts = [...new Set(alerts)];
      const scenarioLabel = { base: 'Escenario base', bear: 'Escenario bajista', bull: 'Escenario alcista' }[activeScenario] || activeScenario;
      const firstSnapshot = timeline.length ? timeline[0] : null;
      const currentGaugeLtv = firstSnapshot && Number.isFinite(firstSnapshot.scenarioStats?.[activeScenario])
        ? firstSnapshot.scenarioStats[activeScenario]
        : (totalCollateralValue > 0 ? loanAmount / totalCollateralValue : 0);
      const peakGaugeLtv = timeline.reduce((max, item) => {
        const value = item.scenarioStats?.[activeScenario];
        return Number.isFinite(value) ? Math.max(max, value) : max;
      }, Number.NEGATIVE_INFINITY);
      const safePeakLtv = Number.isFinite(peakGaugeLtv) && peakGaugeLtv >= 0 ? peakGaugeLtv : currentGaugeLtv;

      return {
        timeline,
        chartData,
        alerts: uniqueAlerts,
        fundingGaps,
        netBalanceFinal: timeline.length ? timeline[timeline.length - 1].netBalance : loanAmount,
        minNetBalance: Number.isFinite(minNet) ? minNet : loanAmount,
        lastOutstanding: outstandingAfterPlan,
        outstandingAfterPlan,
        collateralAfterPlan,
        collateralDeltaPlanned: collateralDeltaTotal,
        scheduledPrincipal,
        scheduledInterest,
        totalCost: totalOutflows,
        totalEarn,
        projectedFinalPayoff,
        accruedInterestAfterPlan: accruedAfterPlan,
        scenarioSummaries,
        scenarioShocks: baseScenarios,
        activeScenario,
        ltvForGauge: currentGaugeLtv,
        ltvCurrent: currentGaugeLtv,
        ltvPeak: safePeakLtv,
        scenarioLabel,
      };
    }

    function BenchmarkCeFiDeFi({
      config,
      onChange,
      fmt,
      currency,
      rate,
      loanAmount,
      chosenAPR,
      daysUntilRepay,
      scenarioName,
      cashflowNet,
      defaultMatrix,
    }) {
      const safeConfig = config || {};
      const matrix = safeConfig.rateMatrix || [];
      const strategies = safeConfig.strategies || [];
      const termDays = Math.max(1, daysUntilRepay || 0);
      const baseAmount = loanAmount || 0;

      const updateRate = (id, patch) => onChange((prev) => ({
        ...prev,
        rateMatrix: (prev?.rateMatrix || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
      }));

      const removeRate = (id) => onChange((prev) => ({
        ...prev,
        rateMatrix: (prev?.rateMatrix || []).filter((item) => item.id !== id),
      }));

      const addRate = () => {
        const nextId = `rate-${Math.max(0, ...matrix.map((item) => Number(String(item.id).replace(/\D/g, '')) || 0)) + 1}`;
        onChange((prev) => ({
          ...prev,
          rateMatrix: [...(prev?.rateMatrix || []), { id: nextId, platform: 'Plataforma', product: 'Producto', type: 'APR', value: chosenAPR || 0 }],
        }));
      };

      const updateStrategy = (id, patch) => onChange((prev) => ({
        ...prev,
        strategies: (prev?.strategies || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
      }));

      const removeStrategy = (id) => onChange((prev) => ({
        ...prev,
        strategies: (prev?.strategies || []).filter((item) => item.id !== id),
      }));

      const addStrategy = () => {
        const nextId = `strategy-${Math.max(0, ...strategies.map((item) => Number(String(item.id).replace(/\D/g, '')) || 0)) + 1}`;
        const loanRate = matrix[0]?.id || defaultMatrix?.[0]?.id || 'loan-default';
        const yieldRate = matrix[1]?.id || defaultMatrix?.[1]?.id || 'yield-default';
        onChange((prev) => ({
          ...prev,
          strategies: [...(prev?.strategies || []), {
            id: nextId,
            label: `Estrategia ${nextId}`,
            lenderRateId: loanRate,
            yieldRateId: yieldRate,
            apr: matrix.find((r) => r.id === loanRate)?.value ?? chosenAPR ?? 0,
            apy: matrix.find((r) => r.id === yieldRate)?.value ?? 0,
            feesIn: 0,
            feesOut: 0,
            riskCeFiLender: true,
            riskDeFiYield: false,
            riskNewProtocol: false,
          }],
        }));
      };

      const findRate = (id) => matrix.find((item) => item.id === id);

      const computeResult = (strategy) => {
        const amount = strategy.amountOverride != null ? Number(strategy.amountOverride) || 0 : baseAmount;
        const apr = Number.isFinite(strategy.apr) ? strategy.apr : (findRate(strategy.lenderRateId)?.value || 0);
        const apy = Number.isFinite(strategy.apy) ? strategy.apy : (findRate(strategy.yieldRateId)?.value || 0);
        const fees = (Number(strategy.feesIn) || 0) + (Number(strategy.feesOut) || 0);
        const interestPaid = amount > 0 ? amount * (Math.pow(1 + apr / 365, termDays) - 1) : 0;
        const interestEarned = amount > 0 ? amount * (Math.pow(1 + apy / 365, termDays) - 1) : 0;
        const spread = interestEarned - interestPaid - fees;
        const netPct = amount > 0 ? Math.max(-0.99, spread / amount) : 0;
        const annualized = termDays > 0 ? (Math.pow(1 + netPct, 365 / termDays) - 1) : 0;
        const riskPenalty = (strategy.riskDeFiYield ? 0.02 : 0) + (strategy.riskNewProtocol ? 0.03 : 0) + (strategy.riskCeFiLender ? 0 : 0.01);
        return {
          spread,
          annualized,
          adjustedAnnual: annualized - riskPenalty,
          amount,
          apr,
          apy,
          fees,
          interestPaid,
          interestEarned,
        };
      };

      const results = strategies.map((strategy) => ({ strategy, metrics: computeResult(strategy) }));
      const ranked = [...results].sort((a, b) => (b.metrics.adjustedAnnual || 0) - (a.metrics.adjustedAnnual || 0));

      const formatMoney = (value) => fmt(value * rate, currency);

      return (
        <Card title="Benchmark CeFi vs. CeFi/DeFi">
          <div className="space-y-6 text-xs">
            <div className="rounded-2xl border border-neutral-200 bg-neutral-50/70 px-4 py-3 space-y-1 text-neutral-600">
              <div>Monto base: {formatMoney(baseAmount)} · APR préstamo: {formatPercent(chosenAPR, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} · Plazo: {termDays} días</div>
              <div>Escenario cashflow: {scenarioName || 'Base'} · Saldo neto proyectado: {cashflowNet != null ? formatMoney(cashflowNet) : '—'}</div>
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Matriz de tasas</h4>
                <button className="nx-btn nx-btn-sm" onClick={addRate}>Agregar tasa</button>
              </div>
              <div className="space-y-2">
                {matrix.length === 0 && <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-neutral-500">Define al menos una tasa APR/APY para combinar estrategias.</div>}
                {matrix.map((item) => (
                  <div key={item.id} className="grid grid-cols-1 md:grid-cols-5 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                    <input type="text" value={item.platform || ''} onChange={(e) => updateRate(item.id, { platform: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1" placeholder="Plataforma" />
                    <input type="text" value={item.product || ''} onChange={(e) => updateRate(item.id, { product: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1" placeholder="Producto" />
                    <select value={item.type || 'APR'} onChange={(e) => updateRate(item.id, { type: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1">
                      <option value="APR">APR</option>
                      <option value="APY">APY</option>
                    </select>
                    <LocaleNumberInput
                      value={item.value ?? 0}
                      onChange={(v) => updateRate(item.id, { value: v })}
                      decimals={2}
                      className="rounded-full border border-neutral-300 px-2 py-1 text-right"
                    />
                    <div className="flex items-end justify-end">
                      <button className="text-rose-600 hover:underline" onClick={() => removeRate(item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Estrategias</h4>
                <button className="nx-btn nx-btn-sm" onClick={addStrategy}>Agregar estrategia</button>
              </div>
              <div className="space-y-3">
                {strategies.length === 0 && <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-neutral-500">Crea combinaciones préstamo → rendimiento para medir el spread neto.</div>}
                {strategies.map((strategy) => {
                  const metrics = computeResult(strategy);
                  const position = ranked.findIndex((item) => item.strategy.id === strategy.id) + 1;
                  return (
                    <div key={strategy.id} className="grid grid-cols-1 md:grid-cols-6 gap-2 rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                      <div className="md:col-span-2 space-y-1">
                        <input type="text" value={strategy.label || ''} onChange={(e) => updateStrategy(strategy.id, { label: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1" placeholder="Nombre de la estrategia" />
                        <select value={strategy.lenderRateId || ''} onChange={(e) => updateStrategy(strategy.id, { lenderRateId: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1">
                          <option value="">Sin tasa</option>
                          {matrix.map((item) => <option key={`lend-${item.id}`} value={item.id}>{item.platform} · {item.product}</option>)}
                        </select>
                        <LocaleNumberInput
                          value={strategy.apr ?? metrics.apr}
                          onChange={(v) => updateStrategy(strategy.id, { apr: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                        />
                      </div>
                      <div className="space-y-1">
                        <select value={strategy.yieldRateId || ''} onChange={(e) => updateStrategy(strategy.id, { yieldRateId: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1">
                          <option value="">Sin tasa</option>
                          {matrix.map((item) => <option key={`yield-${item.id}`} value={item.id}>{item.platform} · {item.product}</option>)}
                        </select>
                        <LocaleNumberInput
                          value={strategy.apy ?? metrics.apy}
                          onChange={(v) => updateStrategy(strategy.id, { apy: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                        />
                        <LocaleNumberInput
                          value={Number.isFinite(strategy.amountOverride) ? strategy.amountOverride : null}
                          onChange={(v) => updateStrategy(strategy.id, { amountOverride: v == null ? null : v })}
                          decimals={2}
                          allowEmpty
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                          placeholder="Monto personalizado"
                        />
                      </div>
                      <div className="space-y-1">
                        <LocaleNumberInput
                          value={strategy.feesIn ?? 0}
                          onChange={(v) => updateStrategy(strategy.id, { feesIn: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                          placeholder="Fee entrada"
                        />
                        <LocaleNumberInput
                          value={strategy.feesOut ?? 0}
                          onChange={(v) => updateStrategy(strategy.id, { feesOut: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                          placeholder="Fee salida"
                        />
                        <div className="text-[11px] text-neutral-500">Spread: {formatMoney(metrics.spread)}</div>
                      </div>
                      <div className="space-y-1 text-[11px] text-neutral-600">
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskCeFiLender !== false} onChange={(e) => updateStrategy(strategy.id, { riskCeFiLender: e.target.checked })} /> Custodia CeFi</label>
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskDeFiYield === true} onChange={(e) => updateStrategy(strategy.id, { riskDeFiYield: e.target.checked })} /> Yield DeFi</label>
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskNewProtocol === true} onChange={(e) => updateStrategy(strategy.id, { riskNewProtocol: e.target.checked })} /> Smart contract nuevo</label>
                      </div>
                      <div className="space-y-1">
                        <div className={`text-sm font-semibold ${metrics.spread >= 0 ? 'text-emerald-600' : 'text-rose-600'}`}>{formatMoney(metrics.spread)}</div>
                        <div className="text-[11px] text-neutral-500">Anualizado: {formatPercent(metrics.annualized, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                        <div className="text-[11px] text-neutral-500">Ajustado riesgo: {formatPercent(metrics.adjustedAnnual, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                      </div>
                      <div className="flex items-end justify-between gap-2">
                        <div className="text-sm font-semibold text-neutral-700">#{position || '–'}</div>
                        <button className="text-rose-600 hover:underline" onClick={() => removeStrategy(strategy.id)}>Eliminar</button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            {ranked.length > 0 && (
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                {ranked.slice(0, 3).map((item, idx) => (
                  <div key={`rank-${item.strategy.id}`} className="rounded-2xl border border-neutral-200 bg-white px-4 py-3">
                    <div className="text-[11px] uppercase text-neutral-400">Top {idx + 1}</div>
                    <div className="text-sm font-semibold text-neutral-700">{item.strategy.label || item.strategy.id}</div>
                    <div className="text-[11px] text-neutral-500">Spread ajustado {formatPercent(item.metrics.adjustedAnnual, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                    <div className="text-[11px] text-neutral-500">Spread neto {formatMoney(item.metrics.spread)}</div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </Card>
      );
    }

    // UI helpers (pocas funciones y tono visual)
    function KPI({ title, value, subtle, tone, variant }) {
      const toneCls = tone === 'ok' ? 'text-emerald-200' : tone === 'danger' ? 'text-rose-200' : '';
      const baseCls = variant === 'button' ? 'nx-kpi-btn' : 'bg-white nx-kpi';
      return (
        <div className={`relative overflow-hidden rounded-2xl p-4 shadow-sm transition-transform duration-200 ${baseCls} cursor-pointer`} role="button" aria-label={title}>
          <div className={`text-xs uppercase tracking-wide text-center ${variant==='button' ? 'text-white/80' : 'text-neutral-500'}`}>{title}</div>
          <div className={`mt-1 text-xl font-bold text-center ${toneCls}`}>{value}</div>
          {subtle && <div className={`text-xs mt-1 text-center ${variant==='button' ? 'text-white/70' : 'text-neutral-500'}`}>{subtle}</div>}
        </div>
      );
    }
    function Card({ title, children }) {
      return (
        <div className="flex h-full flex-col rounded-2xl bg-white p-5 shadow-sm nx-card">
          <div className="mb-4 text-center">
            <h3 className="text-lg font-semibold tracking-tight text-neutral-800">{title}</h3>
          </div>
          <div className="flex-1">
            {children}
          </div>
        </div>
      );
    }
    function Field({ label, children, align = "left", className = "" }) {
      const centered = align === "center";
      return (
        <label className={`${centered ? "flex flex-col items-center text-center gap-2 text-sm" : "block text-sm"} ${className}`}>
          <div className={`text-neutral-700 font-medium ${centered ? "text-base" : "mb-1"}`}>{label}</div>
          {children}
        </label>
      );
    }
    function LocaleNumberInput({
      value,
      onChange,
      decimals = 2,
      min,
      max,
      allowNegative = false,
      allowEmpty = false,
      className = '',
      onFocus,
      onBlur,
      disabled,
      ...rest
    }) {
      const safeDecimals = Math.max(decimals ?? 2, 2);
      const [display, setDisplay] = useState(() => formatNumberForInput(value, safeDecimals));
      const [focused, setFocused] = useState(false);
      useEffect(() => {
        if (focused) return;
        setDisplay(formatNumberForInput(value, safeDecimals));
      }, [value, focused, safeDecimals]);

      const clamp = (num) => {
        let next = Number.isFinite(num) ? num : 0;
        if (typeof min === 'number') next = Math.max(min, next);
        if (typeof max === 'number') next = Math.min(max, next);
        return next;
      };

      const updateValue = (raw) => {
        if (disabled) return;
        let sanitized = `${raw}`.replace(/\s+/g, '');
        if (!allowNegative) sanitized = sanitized.replace(/-/g, '');
        const hasNegative = allowNegative && /^-/.test(raw);
        sanitized = sanitized.replace(/[^0-9.,]/g, '');
        sanitized = sanitized.replace(/\./g, ',');
        const parts = sanitized.split(',');
        const integerPart = (parts.shift() || '').replace(/[^0-9]/g, '');
        const fractionRaw = parts.join('');
        const fractionPart = safeDecimals > 0 ? fractionRaw.slice(0, safeDecimals) : '';
        const rebuilt = `${hasNegative ? '-' : ''}${integerPart}${fractionPart ? `,${fractionPart}` : ''}`;
        setDisplay(rebuilt);
        if (rebuilt === '') {
          if (allowEmpty) {
            onChange?.(null);
          } else {
            const next = clamp(0);
            onChange?.(next);
          }
          return;
        }
        const parsed = parseLocaleNumber(rebuilt);
        if (!Number.isFinite(parsed)) return;
        const next = clamp(parsed);
        onChange?.(next);
      };

      const handleBlur = (event) => {
        setFocused(false);
        const parsed = parseLocaleNumber(display);
        if (Number.isFinite(parsed)) {
          const next = clamp(parsed);
          setDisplay(formatNumberForInput(next, safeDecimals));
          onChange?.(next);
        } else {
          if (allowEmpty && display === '') {
            onChange?.(null);
            setDisplay('');
            onBlur?.(event);
            return;
          }
          setDisplay(formatNumberForInput(clamp(value ?? 0), safeDecimals));
        }
        onBlur?.(event);
      };

      const handleFocus = (event) => {
        setFocused(true);
        setDisplay((prev) => (typeof prev === 'string' ? prev.replace(/\./g, '') : prev));
        onFocus?.(event);
        requestAnimationFrame(() => event.target.select?.());
      };

      return (
        <input
          type="text"
          inputMode="decimal"
          value={display}
          onChange={(e) => updateValue(e.target.value)}
          onFocus={handleFocus}
          onBlur={handleBlur}
          className={className}
          disabled={disabled}
          {...rest}
        />
      );
    }

    function NumberParam({ label, value, onChange, step = 1, ringClass = "focus:ring-blue-700" }) {
      const decimals = inferFractionDigits(step, 2);
      return (
        <Field label={label}>
          <LocaleNumberInput
            value={value}
            onChange={onChange}
            decimals={decimals}
            className={`w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 ${ringClass} text-right`}
          />
        </Field>
      );
    }
    function Th({ children }) { return (<th className="px-3 py-2 text-center align-middle text-xs font-semibold">{children}</th>); }
    function Td({ children, align = "left", ...rest }) {
      const alignClass = align === "right" ? "text-right" : align === "center" ? "text-center" : "text-left";
      return (<td {...rest} className={`px-3 py-2 align-middle ${alignClass}`}>{children}</td>);
    }
    function Pill({ label, value, tone = "neutral" }) {
      const tones = {
        ok: "bg-emerald-50 text-emerald-700 border-emerald-200",
        warn: "bg-amber-50 text-amber-700 border-amber-200",
        danger: "bg-rose-50 text-rose-700 border-rose-200",
        neutral: "bg-neutral-50 text-neutral-700 border-neutral-200",
      };
      return (
        <div className={`rounded-2xl border px-4 py-3 flex items-center justify-between gap-4 ${tones[tone]}`}>
          <span className="text-sm font-medium text-neutral-600">{label}</span>
          <span className="text-base font-semibold">{value}</span>
        </div>
      );
    }
    function Line({ label, value, muted = false, tone }) {
      const color = tone === "ok" ? "text-emerald-700" : tone === "warn" ? "text-amber-700" : tone === "danger" ? "text-rose-700" : "";
      return (
        <div className="flex items-center justify-between gap-4">
          <span className={`text-sm ${muted ? "text-neutral-400" : "text-neutral-700"}`}>{label}</span>
          <span className={`text-sm font-medium ${color}`}>{value}</span>
        </div>
      );
    }

    function LTVGauge({ value, zones = [], markers = [] }) {
      const clamp = (v) => Math.max(0, Math.min(1, Number.isFinite(v) ? v : 0));
      const size = 300;
      const center = size / 2;
      const radius = center - 18;
      const ring = 34;
      const startAngle = (Math.PI * 5) / 4; // 225°
      const sweepAngle = (Math.PI * 3) / 2; // 270°
      const angleFor = (pct) => startAngle - clamp(pct) * sweepAngle;
      const polarPoint = (pct, r = radius) => {
        const angle = angleFor(pct);
        return {
          angle,
          x: center + r * Math.cos(angle),
          y: center + r * Math.sin(angle),
        };
      };
      const describeArc = (from, to, r = radius) => {
        const start = polarPoint(from, r);
        const end = polarPoint(to, r);
        const delta = (to - from) * sweepAngle;
        const largeArc = Math.abs(delta) > Math.PI ? 1 : 0;
        const sweepFlag = delta <= 0 ? 1 : 0;
        return `M ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${end.x} ${end.y}`;
      };
      const palette = ['#064e3b', '#22c55e', '#facc15', '#fb923c', '#ef4444'];
      const normalizedZones = (zones.length ? zones : [
        { label: 'Muy saludable', max: 0.2, color: palette[0], legend: '0-20%', tone: 'ok' },
        { label: 'Saludable', max: 0.5, color: palette[1], legend: '20-50%', tone: 'ok' },
        { label: 'Vigilancia', max: 0.7, color: palette[2], legend: '50-70%', tone: 'warn' },
        { label: 'Tensión', max: 0.83, color: palette[3], legend: '70-83%', tone: 'warn' },
        { label: 'Crítico', max: 1, color: palette[4], legend: '>83%', tone: 'danger' },
      ]).map((zone, idx, arr) => ({
        label: zone.label ?? `Zona ${idx + 1}`,
        color: zone.color ?? palette[Math.min(idx, palette.length - 1)],
        legend: zone.legend ?? `≤${Math.round(clamp(zone.max) * 100)}%`,
        rawTo: clamp(zone.max),
        tone: zone.tone ?? (idx === 0 ? 'ok' : idx === arr.length - 1 ? 'danger' : 'warn'),
      }))
        .filter((zone, idx, arr) => zone.rawTo > 0 && idx === arr.findIndex((z) => z.rawTo === zone.rawTo))
        .sort((a, b) => a.rawTo - b.rawTo);
      const gap = 0.005;
      const segments = normalizedZones.reduce((acc, zone) => {
        const prev = acc[acc.length - 1];
        const from = prev ? prev.rawTo : 0;
        const capped = Math.min(Math.max(zone.rawTo, from), 1);
        if (capped <= from) return acc;
        const to = Math.max(Math.min(1, capped), from + 0.002);
        acc.push({ from, to, rawTo: capped, color: zone.color, label: zone.label, legend: zone.legend, tone: zone.tone });
        return acc;
      }, []);
      const valuePct = clamp(value);
      const pointerAngle = angleFor(valuePct);
      const pointerTip = polarPoint(valuePct, radius - ring * 0.25);
      const pointerBaseRadius = 22;
      const baseLeft = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle + Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle + Math.PI / 2),
      };
      const baseRight = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle - Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle - Math.PI / 2),
      };
      const pointerPath = `M ${baseLeft.x} ${baseLeft.y} L ${pointerTip.x} ${pointerTip.y} L ${baseRight.x} ${baseRight.y} Z`;
      const statusZone = segments.find((seg) => valuePct <= seg.rawTo + 1e-6) ?? segments[segments.length - 1];
      const status = statusZone?.label ?? '—';
      const toneKey = statusZone?.tone ?? 'warn';
      const toneStyles = {
        ok: { text: 'text-emerald-500', bg: 'bg-emerald-100/70', dot: '#22c55e' },
        warn: { text: 'text-amber-500', bg: 'bg-amber-100/70', dot: '#facc15' },
        danger: { text: 'text-rose-500', bg: 'bg-rose-100/70', dot: '#ef4444' },
      };
      const statusTone = toneStyles[toneKey] ?? toneStyles.warn;
      const valueLabelY = center + radius * 0.44;
      const statusLabelY = valueLabelY + 24;
      return (
        <div className="flex flex-col items-center">
          <svg viewBox={`0 0 ${size} ${size}`} className="w-full max-w-[340px]">
            <defs>
              <radialGradient id="gaugeDepth" cx="50%" cy="50%" r="60%">
                <stop offset="0%" stopColor="#ffffff" stopOpacity="0.98" />
                <stop offset="100%" stopColor="#e2e8f0" stopOpacity="0.55" />
              </radialGradient>
              <linearGradient id="gaugeRing" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.12)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <filter id="pointerShadow" x="-40%" y="-40%" width="180%" height="180%">
                <feDropShadow dx="0" dy="3" stdDeviation="3" floodColor="rgba(15,23,42,0.35)" />
              </filter>
              <filter id="ringShadow" x="-30%" y="-30%" width="160%" height="160%">
                <feDropShadow dx="0" dy="8" stdDeviation="12" floodColor="rgba(15,23,42,0.18)" floodOpacity="0.5" />
              </filter>
            </defs>
            <g filter="url(#ringShadow)">
              <circle cx={center} cy={center} r={radius + 10} fill="#f8fafc" />
              <circle cx={center} cy={center} r={radius + 6} fill="url(#gaugeRing)" opacity="0.65" />
              <circle cx={center} cy={center} r={radius - ring * 0.15} fill="url(#gaugeDepth)" />
            </g>
            {segments.map((seg, idx) => {
              const isFirst = idx === 0;
              const isLast = idx === segments.length - 1;
              const from = seg.from + (isFirst ? 0 : gap);
              const to = Math.max(from + 0.001, seg.to - (isLast ? 0 : gap));
              return (
                <path
                  key={`${seg.label}-${idx}`}
                  d={describeArc(from, to, radius)}
                  stroke={seg.color}
                  strokeWidth={ring}
                  strokeLinecap="round"
                  fill="none"
                  opacity="0.95"
                />
              );
            })}
            <g filter="url(#pointerShadow)">
              <path d={pointerPath} fill="#0f172a" opacity="0.92" />
            </g>
            <circle cx={center} cy={center} r={18} fill="#1e3a8a" stroke="#f8fafc" strokeWidth="5" />
            <circle cx={center} cy={center} r={6} fill="#f1f5f9" />
            <text
              x={center}
              y={valueLabelY}
              textAnchor="middle"
              className="fill-slate-700"
              style={{ fontWeight: 700, fontSize: '24px' }}
            >
              {formatPercent(valuePct, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
            </text>
            <text
              x={center}
              y={statusLabelY}
              textAnchor="middle"
              className="fill-slate-400"
              style={{ fontWeight: 600, fontSize: '11px', letterSpacing: '0.16em' }}
            >
              Salud
            </text>
          </svg>
          <div className={`mt-4 flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold ${statusTone.bg} ${statusTone.text}`}>
            <span className="inline-flex h-2.5 w-2.5 rounded-full" style={{ backgroundColor: statusTone.dot }} />
            {status}
          </div>
          <div className="mt-5 grid grid-cols-2 gap-3 text-[11px] font-semibold text-neutral-600">
            {segments.map((seg, idx) => (
              <div key={`${seg.label}-${idx}-legend`} className="flex items-center gap-2">
                <span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: seg.color }} />
                <span>{seg.legend ?? seg.label}</span>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function TrendChart({ data, currency, rate }) {
      if (!data || data.length < 2) {
        return <div className="text-sm text-neutral-500">Configura un monto y una fecha de repago para visualizar la trayectoria.</div>;
      }
      const maxVal = data.reduce((max, point) => {
        const candidates = [point.cost, point.earn, point.balance];
        for (const raw of candidates) {
          const value = Number(raw);
          if (Number.isFinite(value) && value > max) {
            max = value;
          }
        }
        return max;
      }, 0);
      if (!(maxVal > 0)) {
        return <div className="text-sm text-neutral-500">Agrega colateral o préstamo para generar la proyección.</div>;
      }
      const width = 420;
      const height = 220;
      const paddingX = 36;
      const paddingY = 28;
      const step = data.length > 1 ? (width - paddingX * 2) / (data.length - 1) : 0;
      const baseY = height - paddingY;
      const scaleY = (value) => {
        if (!maxVal) return baseY;
        const ratio = value / maxVal;
        const usableHeight = height - paddingY * 1.6;
        return baseY - ratio * usableHeight;
      };
      const pathFor = (key) => data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point[key]);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPath = data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point.balance);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPathClosed = `${areaPath} L ${paddingX + step * (data.length - 1)} ${baseY} L ${paddingX} ${baseY} Z`;
      const tickIndexes = Array.from(new Set([0, Math.floor(data.length / 2), data.length - 1])).filter(i => i >= 0 && i < data.length);
      const ticks = tickIndexes.map((i) => ({ x: paddingX + i * step, label: `Día ${Math.round(data[i].day)}` }));
      const colors = { balance: '#8b5cf6', cost: '#60a5fa', earn: '#34d399' };
      const lastPoint = data[data.length - 1];
      return (
        <div>
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full">
            <defs>
              <linearGradient id="chartBg" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.08)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <linearGradient id="balanceArea" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#a855f7" stopOpacity="0.35" />
                <stop offset="100%" stopColor="#a855f7" stopOpacity="0.05" />
              </linearGradient>
            </defs>
            <rect x="0" y="0" width={width} height={height} fill="url(#chartBg)" opacity="1" rx="18" />
            <path d={`M ${paddingX} ${baseY} L ${paddingX + step * (data.length - 1)} ${baseY}`} stroke="rgba(148,163,184,0.35)" strokeWidth="1.5" strokeLinecap="round" />
            <path d={areaPathClosed} fill="url(#balanceArea)" opacity="0.6" />
            <path d={pathFor('balance')} stroke={colors.balance} strokeWidth="3" fill="none" strokeLinecap="round" />
            <path d={pathFor('cost')} stroke={colors.cost} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="4 4" />
            <path d={pathFor('earn')} stroke={colors.earn} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="6 4" />
            {ticks.map((tick) => (
              <g key={tick.label} transform={`translate(${tick.x}, ${baseY + 14})`}>
                <circle cx="0" cy="0" r="2" fill="rgba(148,163,184,0.5)" />
                <text textAnchor="middle" dy="12" className="fill-slate-400" style={{ fontSize: '10px', letterSpacing: '0.04em' }}>{tick.label}</text>
              </g>
            ))}
            {data.map((point, index) => {
              const x = paddingX + index * step;
              return (
                <circle key={`dot-${index}`} cx={x} cy={scaleY(point.balance)} r="3.5" fill="#8b5cf6" stroke="#fff" strokeWidth="1.5" />
              );
            })}
          </svg>
          <div className="mt-3 flex flex-wrap gap-4 text-xs font-semibold text-neutral-500">
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.balance }} />Balance neto</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.cost }} />Costo (interés)</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.earn }} />Earn estimado</span>
          </div>
          <div className="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3 text-sm">
            <div className="rounded-xl bg-blue-50/70 px-3 py-2">
              <div className="text-xs uppercase text-blue-600">Interés total</div>
              <div className="text-sm font-semibold text-blue-700">{fmt(lastPoint.cost * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-emerald-50/70 px-3 py-2">
              <div className="text-xs uppercase text-emerald-600">Earn acumulado</div>
              <div className="text-sm font-semibold text-emerald-700">{fmt(lastPoint.earn * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-violet-50/70 px-3 py-2">
              <div className="text-xs uppercase text-violet-600">Balance estimado</div>
              <div className="text-sm font-semibold text-violet-700">{fmt(lastPoint.balance * rate, currency)}</div>
            </div>
          </div>
        </div>
      );
    }

    function BinanceAssetCard({ item, currency, formatUsd, formatLoan, chosenAPR }) {
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      const toneBar = { ok: '#10b981', warn: '#f97316', danger: '#ef4444' };
      const tickerUpper = (item.ticker || '').toUpperCase();
      const highlightEtbDetails = tickerUpper === 'ADA' || tickerUpper === 'ALGO';
      const usagePct = item.policyLTV > 0 ? Math.min(100, (item.actualLtv / item.policyLTV) * 100) : Math.min(100, item.actualLtv * 100);
      const annualApr = Number.isFinite(item.annualApr) ? item.annualApr : chosenAPR;
      const netTone = item.netApr < 0 ? 'text-emerald-600' : item.netApr <= annualApr ? 'text-neutral-900' : 'text-amber-600';
      const ledger = item.ledger || {};
      const interestAccrued = Number.isFinite(item.interestAccrued) ? Math.max(0, item.interestAccrued) : 0;
      const interestLabel = interestAccrued > 0 ? formatLoan(interestAccrued) : '—';
      const liquidationPrice = Number.isFinite(item.liquidationPrice) && item.liquidationPrice > 0 ? item.liquidationPrice : null;
      const liquidationDigits = liquidationPrice != null && liquidationPrice < 0.1 ? { minimumFractionDigits: 6, maximumFractionDigits: 8 } : { minimumFractionDigits: 4, maximumFractionDigits: 6 };
      const liquidationPriceLabel = liquidationPrice != null ? `$${formatDecimal(liquidationPrice, liquidationDigits)}` : '—';
      const borrowDate = ledger.borrowDate;
      const lastUpdated = ledger.lastUpdated;
      return (
        <div className="rounded-2xl border border-amber-100 bg-white/80 p-4 shadow-sm">
          <div className="flex items-start justify-between gap-3">
            <div>
              <div className="text-sm font-semibold text-neutral-900">{item.name}</div>
              <div className="text-xs text-neutral-500">{item.ticker || '—'}</div>
            </div>
            <span className={`rounded-full px-2 py-1 text-xs font-semibold ${toneBadge[item.tone] || toneBadge.ok}`}>
              {item.tone === 'ok' ? 'Sano' : item.tone === 'warn' ? 'Vigilar' : 'Riesgo'}
            </span>
          </div>
          <div className="mt-3 space-y-3 text-xs text-neutral-600">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">Colateral</div>
                <div className="text-sm font-semibold text-neutral-800">{formatUsd(item.value)}</div>
              </div>
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">{highlightEtbDetails ? 'ETB neto asignado' : 'Préstamo & flujos'}</div>
                <div className="text-sm font-semibold text-neutral-800">{formatLoan(item.allocatedLoan)}</div>
                <div className="text-[10px] text-neutral-500">Interés devengado {interestLabel}</div>
              </div>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">LTV neto</div>
                <div className="text-sm font-semibold text-neutral-800">{formatPercent(item.actualLtv, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}</div>
              </div>
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">Tasas Binance</div>
                <div className="text-sm font-semibold text-neutral-800">{formatPercent(annualApr, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} APR</div>
                <div className="text-[10px] text-neutral-500">Precio de liquidación estimada {liquidationPriceLabel}</div>
              </div>
            </div>
          </div>
          <div className="mt-3">
            <div className="h-2 w-full overflow-hidden rounded-full bg-neutral-200">
              <div className="h-full transition-all" style={{ width: `${usagePct.toFixed(1)}%`, backgroundColor: toneBar[item.tone] || toneBar.ok }} />
            </div>
            <div className="mt-1 flex justify-between text-[10px] text-neutral-500">
              <span>Uso</span>
              <span>Tope</span>
            </div>
          </div>
          <div className="mt-3">
            <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">APR neta Binance</div>
            <div className={`text-base font-semibold ${netTone}`}>{formatPercent(item.netApr, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
            {(borrowDate || lastUpdated) && (
              <div className="mt-1 text-[10px] text-neutral-500">
                {borrowDate && <div>Inicio préstamo: {borrowDate}</div>}
                {lastUpdated && <div>Última actualización: {lastUpdated}</div>}
              </div>
            )}
          </div>
        </div>
      );
    }

    function LoanDistributionDonut({ segments, size = 160 }) {
      const fallbackColors = ['#ef6784', '#4b8fda', '#f5b64d', '#38c5b8'];
      const center = size / 2;
      const outerRadius = center - 8;
      const innerRadius = outerRadius * 0.6;

      const degToRad = (deg) => (deg * Math.PI) / 180;
      const polarToCartesian = (angleDeg, radius) => {
        const rad = degToRad(angleDeg);
        return {
          x: center + radius * Math.cos(rad),
          y: center + radius * Math.sin(rad),
        };
      };

      const createSegmentPath = (startAngle, endAngle) => {
        const sweep = endAngle - startAngle;
        if (!Number.isFinite(sweep) || sweep <= 0.0001) {
          return '';
        }

        const notch = Math.min(Math.max(sweep * 0.18, 4), 18);
        const clippedStart = startAngle + notch;
        const clippedEnd = endAngle - notch;

        const largeArc = sweep > 180 ? 1 : 0;

        if (clippedEnd <= clippedStart) {
          const outerStart = polarToCartesian(startAngle, outerRadius);
          const outerEnd = polarToCartesian(endAngle, outerRadius);
          const innerEnd = polarToCartesian(endAngle, innerRadius);
          const innerStart = polarToCartesian(startAngle, innerRadius);
          return [
            `M ${outerStart.x.toFixed(2)} ${outerStart.y.toFixed(2)}`,
            `A ${outerRadius.toFixed(2)} ${outerRadius.toFixed(2)} 0 ${largeArc} 1 ${outerEnd.x.toFixed(2)} ${outerEnd.y.toFixed(2)}`,
            `L ${innerEnd.x.toFixed(2)} ${innerEnd.y.toFixed(2)}`,
            `A ${innerRadius.toFixed(2)} ${innerRadius.toFixed(2)} 0 ${largeArc} 0 ${innerStart.x.toFixed(2)} ${innerStart.y.toFixed(2)}`,
            'Z',
          ].join(' ');
        }

        const startOuter = polarToCartesian(clippedStart, outerRadius);
        const endOuter = polarToCartesian(clippedEnd, outerRadius);
        const startTip = polarToCartesian(startAngle + notch * 0.35, outerRadius * 0.94);
        const endTip = polarToCartesian(endAngle - notch * 0.35, outerRadius * 0.94);
        const innerEnd = polarToCartesian(endAngle - notch * 0.45, innerRadius);
        const innerStart = polarToCartesian(startAngle + notch * 0.45, innerRadius);

        return [
          `M ${startTip.x.toFixed(2)} ${startTip.y.toFixed(2)}`,
          `L ${startOuter.x.toFixed(2)} ${startOuter.y.toFixed(2)}`,
          `A ${outerRadius.toFixed(2)} ${outerRadius.toFixed(2)} 0 ${largeArc} 1 ${endOuter.x.toFixed(2)} ${endOuter.y.toFixed(2)}`,
          `L ${endTip.x.toFixed(2)} ${endTip.y.toFixed(2)}`,
          `L ${innerEnd.x.toFixed(2)} ${innerEnd.y.toFixed(2)}`,
          `A ${innerRadius.toFixed(2)} ${innerRadius.toFixed(2)} 0 ${largeArc} 0 ${innerStart.x.toFixed(2)} ${innerStart.y.toFixed(2)}`,
          'Z',
        ].join(' ');
      };

      let currentAngle = -90;
      const shapes = segments.map((seg, idx) => {
        const sweep = (Number.isFinite(seg.share) ? seg.share : 0) * 360;
        const start = currentAngle;
        const end = currentAngle + sweep;
        currentAngle = end;
        const path = createSegmentPath(start, end);
        return {
          path,
          color: seg.color || fallbackColors[idx % fallbackColors.length],
          key: `${seg.ticker || seg.name || 'segment'}-${idx}`,
        };
      }).filter((shape) => shape.path);

      if (shapes.length === 0) {
        return (
          <div className="relative flex h-36 w-36 items-center justify-center rounded-full bg-slate-100">
            <div className="h-20 w-20 rounded-full bg-white shadow-inner" />
          </div>
        );
      }

      return (
        <svg
          viewBox={`0 0 ${size} ${size}`}
          className="h-36 w-36"
          role="img"
          aria-label="Distribución visual del préstamo"
        >
          <defs>
            <filter id="donutShadow" x="-20%" y="-20%" width="140%" height="140%">
              <feDropShadow dx="0" dy="8" stdDeviation="8" floodColor="rgba(15,30,70,0.18)" />
            </filter>
          </defs>
          <g filter="url(#donutShadow)">
            {shapes.map((shape) => (
              <path
                key={shape.key}
                d={shape.path}
                fill={shape.color}
                stroke="rgba(255,255,255,0.9)"
                strokeWidth="1.5"
              />
            ))}
          </g>
          <circle
            cx={center}
            cy={center}
            r={innerRadius - 4}
            fill="#ffffff"
            stroke="rgba(15,30,70,0.08)"
            strokeWidth="2"
          />
        </svg>
      );
    }

    function CollateralLoanShareCard({ breakdown, currency, formatUsd, formatLoan, loanAmount, overallLTV, healthyThreshold, warnThreshold, autoRepayThreshold }) {
      const items = (breakdown || []).map((item) => {
        const share = item.loanShare > 0 ? item.loanShare : item.share;
        return { ...item, share: Math.max(0, share) };
      }).filter((item) => item.share > 0);
      if (items.length === 0) {
        return (
          <div className="rounded-2xl border border-amber-100 bg-white/80 p-4 shadow-sm text-sm text-neutral-500">
            Activa al menos un colateral con préstamo asignado para ver la distribución.
          </div>
        );
      }

      const toneColors = { ok: '#34d399', warn: '#facc15', danger: '#fb7185' };
      const assetPalette = ['#2563eb', '#f97316', '#10b981', '#8b5cf6', '#ec4899', '#14b8a6', '#facc15', '#0ea5e9', '#ef4444', '#22d3ee'];
      const distribution = items.map((item) => {
        const ledger = item.ledger || {};
        const ledgerOriginal = Number.isFinite(ledger.originalPrincipal) ? Math.max(0, ledger.originalPrincipal) : 0;
        const ledgerInterest = Number.isFinite(ledger.interestAccrued) ? Math.max(0, ledger.interestAccrued) : 0;
        const ledgerPaid = Number.isFinite(ledger.paidTotal) ? Math.max(0, ledger.paidTotal) : 0;
        const ledgerOutstanding = Math.max(0, ledgerOriginal + ledgerInterest - ledgerPaid);
        const recordedOutstanding = Number.isFinite(ledger.outstanding) ? Math.max(0, ledger.outstanding) : 0;
        const fallbackOutstanding = Number.isFinite(item.allocatedLoan) ? Math.max(0, item.allocatedLoan) : 0;
        const amount = ledgerOutstanding > 0
          ? ledgerOutstanding
          : (recordedOutstanding > 0 ? recordedOutstanding : fallbackOutstanding);
        return { ...item, amount };
      }).filter((item) => item.amount > 0);
      if (distribution.length === 0) {
        return (
          <div className="rounded-2xl border border-amber-100 bg-white/80 p-4 shadow-sm text-sm text-neutral-500">
            Activa al menos un colateral con préstamo asignado para ver la distribución.
          </div>
        );
      }

      const totalOutstanding = distribution.reduce((acc, item) => acc + item.amount, 0);
      const consideredLoan = totalOutstanding > 0 ? totalOutstanding : Math.max(0, loanAmount);
      const denominator = totalOutstanding > 0 ? totalOutstanding : (consideredLoan > 0 ? consideredLoan : 1);
      let accShare = 0;
      const segments = distribution.map((item, idx) => {
        const share = denominator > 0 ? item.amount / denominator : 0;
        const start = accShare;
        accShare += share;
        const end = Math.min(1, accShare);
        const color = assetPalette[idx % assetPalette.length];
        return { start, end, tone: item.tone, name: item.name, ticker: item.ticker, share, color, amount: item.amount };
      });
      const healthy = Number.isFinite(healthyThreshold) ? healthyThreshold : 0.2;
      const warn = Number.isFinite(warnThreshold) ? warnThreshold : Math.max(healthy + 0.2, healthy);
      const auto = Number.isFinite(autoRepayThreshold) ? autoRepayThreshold : 1;
      const overallTone = overallLTV <= healthy ? 'ok' : overallLTV <= warn ? 'warn' : 'danger';
      const overallLabel = overallTone === 'ok' ? 'Sano' : overallTone === 'warn' ? 'Vigilar' : 'Crítico';
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      const toneText = { ok: 'text-emerald-600', warn: 'text-amber-600', danger: 'text-rose-600' };
      const consideredLoanLabel = formatLoan(consideredLoan);
      const overallLtvLabel = formatPercent(overallLTV, { minimumFractionDigits: 1, maximumFractionDigits: 1 });

      return (
        <div className="rounded-2xl border border-amber-100 bg-white/80 p-4 shadow-sm flex flex-col gap-4">
          <div className="flex items-center justify-between">
            <div className="text-sm font-semibold text-neutral-900">Distribución del préstamo</div>
            <span className={`rounded-full px-2 py-1 text-[11px] font-semibold ${toneBadge[overallTone]}`}>{overallLabel}</span>
          </div>
          <div className="flex flex-col items-center gap-4">
            <LoanDistributionDonut segments={segments} />
            <div className="text-xs text-neutral-500 text-center">
              Préstamo considerado: <span className="font-semibold text-neutral-700">{formatLoan(consideredLoan)}</span>
            </div>
          </div>
          <div className="space-y-2 text-xs text-neutral-600">
            {segments.map((seg, idx) => (
              <div key={`${seg.ticker || seg.name || 'segment'}-${idx}`} className="flex items-center justify-between gap-3">
                <div className="flex items-center gap-2">
                  <span className="h-2.5 w-2.5 rounded-full" style={{ backgroundColor: seg.color || '#60a5fa' }} />
                  <span className="font-medium text-neutral-800">{seg.name}</span>
                </div>
                <div className="flex flex-col items-end">
                  <span className="font-semibold text-neutral-800">{formatPercent(seg.share, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}</span>
                  <span className="text-[10px] text-neutral-500">{formatLoan(seg.share * consideredLoan)}</span>
                </div>
              </div>
            ))}
          </div>
          <div className="flex flex-wrap gap-2 text-[10px] text-neutral-500">
            <span className="flex items-center gap-1"><span className="h-2 w-3 rounded-full" style={{ backgroundColor: toneColors.ok }} />Sano ≤ {formatPercent(healthy, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
            <span className="flex items-center gap-1"><span className="h-2 w-3 rounded-full" style={{ backgroundColor: toneColors.warn }} />Alerta ≤ {formatPercent(warn, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
            <span className="flex items-center gap-1"><span className="h-2 w-3 rounded-full" style={{ backgroundColor: toneColors.danger }} />Riesgo ≥ {formatPercent(auto, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
          </div>
        </div>
      );
    }

    // Tests mínimos (no tocar a menos que estén mal) + 2 nuevos
    function approxEq(a, b, eps = 1e-6) { return Math.abs(a - b) <= eps; }
    function runDevTests() {
      try {
        const nexo = PLATFORM_CONFIGS.nexo;
        const binance = PLATFORM_CONFIGS.binance;
        const youhodler = PLATFORM_CONFIGS.youhodler;
        const ledn = PLATFORM_CONFIGS.ledn;
        console.assert(approxEq((nexo.policies?.targetLtv ?? 0), 0.20), 'Test1: Target LTV Nexo 20%');
        console.assert(approxEq((nexo.ltvByTicker?.BTC ?? 0), 0.50), 'Test2: LTV BTC Nexo 50%');
        console.assert((binance.earnAprTop?.BNB ?? 0) >= 0.05, 'Test3: Earn BNB Binance ≥5%');
        console.assert(GLOBAL_COINGECKO_IDS.BTC === 'bitcoin', 'Test4: CoinGecko BTC');
        console.assert(PLATFORM_IDS.includes('nexo') && PLATFORM_IDS.includes('binance'), 'Test5: plataformas registradas');
        const lowCostNexo = nexo.apr?.lowCostEligibleTiers || [];
        console.assert(lowCostNexo.includes('Gold') && lowCostNexo.includes('Platinum'), 'Test6: Low-Cost tiers Nexo');
        const defaultTicker = (nexo.defaultAssets?.[0]?.ticker || '').toUpperCase();
        console.assert(defaultTicker === 'BTC', 'Test7: default asset BTC');
        console.assert((youhodler?.policies?.targetLtv ?? 0) >= 0.7, 'Test8: Target LTV YouHodler ≥70%');
        console.assert((ledn?.ltvByTicker?.BTC ?? 0) <= 0.7, 'Test9: LTV BTC Ledn ≤70%');
        console.assert(PLATFORM_IDS.includes('youhodler') && PLATFORM_IDS.includes('ledn'), 'Test10: nuevas plataformas registradas');
        console.log('%cSanity tests OK', 'color:green');
      } catch (e) { console.error('Sanity tests failed', e); }
    }
    if (typeof window !== 'undefined') { try { runDevTests(); } catch (_) {} }

    const container = document.getElementById('root');
    if (!container) {
      throw new Error('No se encontró el contenedor #root para montar la app.');
    }
    const root = ReactDOM.createRoot(container);
    root.render(
      <ErrorBoundary>
        <SimuladorPrestamos />
      </ErrorBoundary>
    );
  </script>
</body>
</html>
