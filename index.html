<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Préstamos</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    body{
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--theme-surface-soft, linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%));
      transition:background .3s ease;
    }
    :root{
      --theme-surface-soft:linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%);
      --theme-card-border:#dfe6ff;
      --theme-card-shadow:0 12px 30px rgba(16,35,90,.08);
      --theme-kpi-border:#e6eaf5;
      --theme-kpi-bg:linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%);
      --theme-kpi-shadow:0 16px 30px rgba(8,20,66,0.35);
      --theme-kpi-hover-shadow:0 22px 36px rgba(12,28,84,0.42);
      --theme-kpi-active-shadow:0 10px 18px rgba(10,24,70,0.3);
      --theme-btn-bg:linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%);
      --theme-btn-text:#fff;
      --theme-btn-border:rgba(255,255,255,0.22);
      --theme-btn-shadow:0 14px 28px rgba(15,33,90,0.32);
      --theme-btn-hover-shadow:0 20px 34px rgba(12,30,88,0.4);
      --theme-btn-active-shadow:0 10px 20px rgba(10,26,70,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%);
      --theme-ghost-text:#1e2f67;
      --theme-ghost-border:rgba(30,64,175,0.16);
      --theme-ghost-shadow:0 10px 22px rgba(15,30,70,0.12);
      --theme-ghost-hover-shadow:0 16px 26px rgba(15,30,70,0.18);
    }
    .theme-nexo{
      --theme-surface-soft:linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%);
      --theme-card-border:#dfe6ff;
      --theme-card-shadow:0 12px 30px rgba(16,35,90,.08);
      --theme-kpi-border:#e6eaf5;
      --theme-kpi-bg:linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%);
      --theme-kpi-shadow:0 16px 30px rgba(8,20,66,0.35);
      --theme-kpi-hover-shadow:0 22px 36px rgba(12,28,84,0.42);
      --theme-kpi-active-shadow:0 10px 18px rgba(10,24,70,0.3);
      --theme-btn-bg:linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%);
      --theme-btn-text:#fff;
      --theme-btn-border:rgba(255,255,255,0.22);
      --theme-btn-shadow:0 14px 28px rgba(15,33,90,0.32);
      --theme-btn-hover-shadow:0 20px 34px rgba(12,30,88,0.4);
      --theme-btn-active-shadow:0 10px 20px rgba(10,26,70,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%);
      --theme-ghost-text:#1e2f67;
      --theme-ghost-border:rgba(30,64,175,0.16);
      --theme-ghost-shadow:0 10px 22px rgba(15,30,70,0.12);
      --theme-ghost-hover-shadow:0 16px 26px rgba(15,30,70,0.18);
    }
    .theme-binance{
      --theme-surface-soft:linear-gradient(180deg,#fff6e6 0%,#ffedcc 100%);
      --theme-card-border:rgba(251,191,36,0.35);
      --theme-card-shadow:0 12px 30px rgba(146,64,14,0.15);
      --theme-kpi-border:rgba(253,224,71,0.45);
      --theme-kpi-bg:linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%);
      --theme-kpi-shadow:0 16px 30px rgba(146,64,14,0.32);
      --theme-kpi-hover-shadow:0 22px 36px rgba(124,45,18,0.42);
      --theme-kpi-active-shadow:0 10px 18px rgba(124,45,18,0.3);
      --theme-btn-bg:linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%);
      --theme-btn-text:#fff7db;
      --theme-btn-border:rgba(255,255,255,0.24);
      --theme-btn-shadow:0 14px 28px rgba(146,64,14,0.28);
      --theme-btn-hover-shadow:0 20px 34px rgba(124,45,18,0.35);
      --theme-btn-active-shadow:0 10px 20px rgba(124,45,18,0.25);
      --theme-ghost-bg:linear-gradient(150deg,#ffffff 0%,#fff7e6 100%);
      --theme-ghost-text:#7c2d12;
      --theme-ghost-border:rgba(217,119,6,0.3);
      --theme-ghost-shadow:0 10px 22px rgba(146,64,14,0.16);
      --theme-ghost-hover-shadow:0 16px 26px rgba(124,45,18,0.22);
    }
    /* Paleta y estilos base */
    .nx-gradient{background:linear-gradient(135deg,#0b1e4b 0%,#1b44a6 50%,#2052c1 100%)}
    .bn-gradient{background:linear-gradient(135deg,#1f2937 0%,#f59e0b 45%,#f97316 100%)}
    .nx-card{border:1px solid var(--theme-card-border); box-shadow:var(--theme-card-shadow); border-radius:1.5rem; transition:box-shadow .3s ease,border-color .3s ease;}
    .nx-kpi{border:1px solid var(--theme-kpi-border); transition:border-color .3s ease;}
    .nx-kpi-btn{
      position:relative;
      border-radius:1.25rem;
      background:var(--theme-kpi-bg);
      color:#fff;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-shadow);
      transition:transform .25s ease, box-shadow .25s ease, filter .25s ease;
    }
    .nx-kpi-btn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 -18px 30px rgba(0,0,0,0.18);
      pointer-events:none;
    }
    .nx-kpi-btn:hover{
      transform:translateY(-3px);
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-hover-shadow);
    }
    .nx-kpi-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-active-shadow);
    }
    .nx-btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:.4rem;
      background:var(--theme-btn-bg);
      color:var(--theme-btn-text);
      border-radius:1rem;
      padding:.55rem 1.35rem;
      font-weight:600;
      border:1px solid var(--theme-btn-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn:hover{
      transform:translateY(-2px);
      filter:brightness(1.03);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-hover-shadow);
    }
    .nx-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-active-shadow);
    }
    .nx-btn-ghost{
      background:var(--theme-ghost-bg);
      color:var(--theme-ghost-text);
      border:1px solid var(--theme-ghost-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn-ghost:hover{
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-hover-shadow);
    }
    .nx-btn-ghost:active{
      transform:translateY(1px);
    }
    .nx-btn-sm{padding:.35rem .95rem; font-size:.8rem; border-radius:.9rem;}
  </style>
</head>
<body class="theme-nexo">
  <div id="root"></div>

  <!-- React 18 UMD + ReactDOM + Babel (para compilar JSX en el navegador) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    // Simulador de Préstamos – HTML portable (sin build, con CDN)
    const DEFAULT_EXCHANGE_RATES = {
      USD: 1,
      ARS: 1000,
      EUR: 0.92,
      GBP: 0.79,
      CAD: 1.36,
      AUD: 1.53,
      CHF: 0.89,
      JPY: 157,
      BRL: 5.0,
      MXN: 17.2,
    };

    const SUPPORTED_CURRENCIES = [
      { code: "USD", label: "USD — Dólar estadounidense" },
      { code: "ARS", label: "ARS — Peso argentino" },
      { code: "EUR", label: "EUR — Euro" },
      { code: "GBP", label: "GBP — Libra esterlina" },
      { code: "CAD", label: "CAD — Dólar canadiense" },
      { code: "AUD", label: "AUD — Dólar australiano" },
      { code: "CHF", label: "CHF — Franco suizo" },
      { code: "JPY", label: "JPY — Yen japonés" },
      { code: "BRL", label: "BRL — Real brasileño" },
      { code: "MXN", label: "MXN — Peso mexicano" },
    ];
    const { useState, useEffect, useMemo, useRef } = React;

    const LIVE_REFRESH_SECONDS = 5;

    const PLATFORM_CONFIGS = {
      nexo: {
        id: "nexo",
        name: "Nexo",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        classes: {
          header: "nx-gradient",
          accent: "text-blue-100/90",
          body: "theme-nexo",
          focusRing: "focus:ring-blue-700",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          NEXO: "nexo",
          USDT: "tether",
          USDC: "usd-coin",
          ADA: "cardano",
          ALGO: "algorand",
          XRP: "ripple",
          BNB: "binancecoin",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.50,
          ETH: 0.50,
          NEXO: 0.15,
          XRP: 0.30,
          BNB: 0.30,
          USDC: 0.50,
          USDT: 0.50,
          ADA: 0.50,
          ALGO: 0.30,
          SOL: 0.30,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.07,
          USDC: 0.12,
          USDT: 0.12,
          NEXO: 0.04,
          XRP: 0.07,
          BNB: 0.07,
          SOL: 0.07,
          ADA: 0.02,
          ALGO: 0.02,
        },
        policies: {
          targetLtv: 0.20,
          marginCallLtv: 0.70,
          autoRepayLtv: 0.8333333333,
          minBalancePerks: 5000,
          defaultLtv: 0.25,
        },
        apr: {
          base: 0.189,
          standard: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.139,
            Platinum: 0.109,
          },
          discounted: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.059,
            Platinum: 0.029,
          },
          earlyRuleDays: 45,
          earlyAPR: 0.189,
          lowCostEligibleTiers: ["Gold", "Platinum"],
          baseTier: "Base",
        },
        loyalty: {
          tokenTicker: "NEXO",
          baseLabel: "Base",
          belowMinimumLabel: "Sin perks",
          tierThresholds: [
            { label: "Platinum", minRatio: 0.10 },
            { label: "Gold", minRatio: 0.05 },
            { label: "Silver", minRatio: 0.01 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (oficial)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Loyalty Tier",
          ratioLabel: "ratio NEXO",
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 7, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 15000,
          repayInDays: 120,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 8, price: 2100, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 25000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 6000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "USD Coin", ticker: "USDC", qty: 4000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 5000, price: 0.38, priceAuto: false, useAsCollateral: false },
            { id: 7, name: "Algorand", ticker: "ALGO", qty: 8000, price: 0.15, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "nexo_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Nexo.",
        },
      },
      binance: {
        id: "binance",
        name: "Binance",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        classes: {
          header: "bn-gradient",
          accent: "text-amber-100/90",
          body: "theme-binance",
          focusRing: "focus:ring-amber-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          BNB: "binancecoin",
          USDT: "tether",
          USDC: "usd-coin",
          BUSD: "binance-usd",
          ADA: "cardano",
          XRP: "ripple",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.65,
          ETH: 0.60,
          BNB: 0.65,
          USDT: 0.80,
          USDC: 0.80,
          BUSD: 0.85,
          ADA: 0.45,
          XRP: 0.50,
          SOL: 0.50,
        },
        earnAprTop: {
          BTC: 0.03,
          ETH: 0.03,
          BNB: 0.05,
          USDT: 0.06,
          USDC: 0.06,
          BUSD: 0.06,
          ADA: 0.02,
          XRP: 0.02,
          SOL: 0.03,
        },
        policies: {
          targetLtv: 0.50,
          marginCallLtv: 0.80,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.18,
          standard: {
            "Estándar": 0.18,
            "VIP 1": 0.16,
            "VIP 2": 0.14,
            "VIP 3": 0.12,
          },
          discounted: {
            "Estándar": 0.18,
            "VIP 1": 0.15,
            "VIP 2": 0.12,
            "VIP 3": 0.10,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.18,
          lowCostEligibleTiers: ["VIP 2", "VIP 3"],
          baseTier: "Estándar",
        },
        loyalty: {
          tokenTicker: "BNB",
          baseLabel: "Estándar",
          belowMinimumLabel: "Estándar",
          tierThresholds: [
            { label: "VIP 3", minRatio: 0.05 },
            { label: "VIP 2", minRatio: 0.03 },
            { label: "VIP 1", minRatio: 0.01 },
          ],
          models: [
            { id: "vsTotal", label: "vs total (BNB holdings)" },
          ],
          kpiLabel: "Nivel VIP",
          ratioLabel: "ratio BNB",
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "BNB", ticker: "BNB", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "BUSD", ticker: "BUSD", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 8, name: "XRP", ticker: "XRP", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsTotal",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 12000,
          repayInDays: 90,
          currency: "USD",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            loyaltyModel: "vsTotal",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.8, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 6, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "BNB", ticker: "BNB", qty: 150, price: 230, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 2000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "BUSD", ticker: "BUSD", qty: 1000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 4000, price: 0.4, priceAuto: false, useAsCollateral: false },
            { id: 7, name: "XRP", ticker: "XRP", qty: 5000, price: 0.5, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "binance_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Binance.",
        },
      },
    };

    const PLATFORM_THEME_CLASSES = Array.from(new Set([
      "theme-nexo",
      ...Object.values(PLATFORM_CONFIGS).map((cfg) => cfg?.classes?.body).filter(Boolean),
    ]));

    const PLATFORM_IDS = Object.keys(PLATFORM_CONFIGS);
    const GLOBAL_COINGECKO_IDS = Object.values(PLATFORM_CONFIGS).reduce((acc, cfg) => ({ ...acc, ...(cfg.coingeckoIds || {}) }), {});

    const fmt = (n, currency = "USD", show = true) =>
      show ? n.toLocaleString(undefined, { style: "currency", currency }) : n.toLocaleString();

    const todayISO = () => new Date().toISOString().slice(0, 10);

    function SimuladorPrestamos() {
      const initialPlatformId = PLATFORM_IDS[0];
      const [platformId, setPlatformId] = useState(() => {
        if (typeof window === 'undefined') return initialPlatformId;
        try {
          const stored = localStorage.getItem('spm_platform');
          return PLATFORM_IDS.includes(stored) ? stored : initialPlatformId;
        } catch {
          return initialPlatformId;
        }
      });

      const platform = PLATFORM_CONFIGS[platformId] ?? PLATFORM_CONFIGS[initialPlatformId];
      const {
        id,
        name: platformName,
        tagline,
        classes = {},
        coingeckoIds = {},
        ltvByTicker = {},
        earnAprTop = {},
        policies = {},
        apr: aprConfig = {},
        loyalty,
        defaultAssets: platformDefaultAssets = [],
        defaultParams: platformDefaultParams = {},
        exportPrefix = "simulador_prestamos",
        disclaimers = {},
      } = platform;

      const themeClass = classes.body || "theme-nexo";
      const focusRingClass = classes.focusRing || "focus:ring-blue-700";
      const headerClass = classes.header || "nx-gradient";
      const accentClass = classes.accent || "text-blue-100/90";
      const platformTagline = tagline || "Datos en vivo y cálculos de Earn (flexible) y crédito.";
      const targetLtv = policies.targetLtv ?? 0.20;
      const marginCallLtv = policies.marginCallLtv ?? 0.70;
      const autoRepayLtv = policies.autoRepayLtv ?? 0.85;
      const minBalancePerks = policies.minBalancePerks ?? 0;
      const defaultLtv = policies.defaultLtv ?? 0.25;
      const loyaltyModels = loyalty?.models ?? [];
      const loyaltyModelFallback = platformDefaultParams?.loyaltyModel ?? loyaltyModels[0]?.id ?? "vsRest";

      const sanitizeTicker = (t) => (t || "").toUpperCase();
      const toNumber = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : 0;
      };
      const sanitizeAssets = (list) => {
        return (Array.isArray(list) ? list : []).map((item, idx) => {
          const ticker = sanitizeTicker(item.ticker);
          return {
            id: item.id ?? idx + 1,
            name: item.name ?? `Activo ${idx + 1}`,
            ticker,
            qty: toNumber(item.qty),
            price: toNumber(item.price),
            priceAuto: item.priceAuto === false ? false : true,
            useAsCollateral: item.useAsCollateral === false ? false : true,
            ltv: ltvByTicker[ticker] ?? item.ltv ?? defaultLtv,
          };
        });
      };
      const storageKeys = useMemo(() => ({
        assets: `spm_${id}_assets_v1`,
        params: `spm_${id}_params_v2`,
      }), [id]);
      const baseAssets = useMemo(() => sanitizeAssets(platformDefaultAssets), [platformDefaultAssets, ltvByTicker, defaultLtv]);
      const baseExchangeRates = useMemo(() => {
        const merged = { ...DEFAULT_EXCHANGE_RATES, ...(platformDefaultParams?.exchangeRates || {}) };
        merged.USD = 1;
        return merged;
      }, [platformDefaultParams]);
      const sanitizeExchangeRates = (rawRates, legacyUsdToArs) => {
        const next = { ...baseExchangeRates };
        const source = rawRates && typeof rawRates === 'object' ? rawRates : {};
        const legacy = Number.isFinite(legacyUsdToArs) ? legacyUsdToArs : null;
        for (const { code } of SUPPORTED_CURRENCIES) {
          if (code === 'USD') { next.USD = 1; continue; }
          const candidate = source[code];
          const value = Number(candidate);
          if (Number.isFinite(value) && value > 0) {
            next[code] = value;
          } else if (code === 'ARS' && legacy != null && legacy > 0) {
            next[code] = legacy;
          } else if (!Number.isFinite(Number(next[code])) || next[code] <= 0) {
            next[code] = DEFAULT_EXCHANGE_RATES[code] ?? 1;
          }
        }
        next.USD = 1;
        return next;
      };
      const baseParams = useMemo(() => {
        const fallback = {
          exchangeRates: { ...baseExchangeRates },
          loyaltyModel: loyaltyModelFallback,
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        };
        const merged = { ...fallback, ...platformDefaultParams };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.exchangeRates = sanitizeExchangeRates(merged.exchangeRates, merged.usdToArs);
        return merged;
      }, [platformDefaultParams, loyaltyModelFallback, loyaltyModels, baseExchangeRates]);
      const sanitizeParams = (raw) => {
        const merged = { ...baseParams, ...(raw || {}) };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.exchangeRates = sanitizeExchangeRates(merged.exchangeRates, merged.usdToArs);
        return merged;
      };

      const applyPreviewSnapshot = () => {
        if (!previewSnapshot) return;
        const {
          assets: previewAssets,
          params: previewParams,
          loanAmount: previewLoanAmount,
          repayDate: previewRepayDate,
          repayInDays,
          currency: previewCurrency,
        } = previewSnapshot;

        if (Array.isArray(previewAssets)) {
          setAssets(sanitizeAssets(previewAssets));
        }

        if (previewParams) {
          setParams(sanitizeParams(previewParams));
        }

        if (Number.isFinite(previewLoanAmount)) {
          setLoanAmount(Number(previewLoanAmount) || 0);
        }

        if (typeof previewCurrency === 'string' && previewCurrency) {
          setSelectedCurrency(previewCurrency);
        } else if (typeof previewSnapshot?.showArs === 'boolean') {
          setSelectedCurrency(previewSnapshot.showArs ? 'ARS' : 'USD');
        }

        if (previewRepayDate) {
          setRepayDate(previewRepayDate);
        } else if (Number.isFinite(repayInDays)) {
          const d = new Date();
          d.setDate(d.getDate() + Math.max(0, Math.round(repayInDays)));
          setRepayDate(d.toISOString().slice(0, 10));
        }
      };

      const [assets, setAssets] = useState(() => {
        if (typeof window === 'undefined') return baseAssets;
        try {
          const saved = localStorage.getItem(storageKeys.assets);
          if (saved) {
            return sanitizeAssets(JSON.parse(saved));
          }
        } catch {}
        return baseAssets;
      });

      const [params, setParams] = useState(() => {
        if (typeof window === 'undefined') return baseParams;
        try {
          const saved = localStorage.getItem(storageKeys.params);
          if (saved) {
            return sanitizeParams(JSON.parse(saved));
          }
        } catch {}
        return baseParams;
      });

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem('spm_platform', platformId); } catch {}
      }, [platformId]);

      useEffect(() => {
        setAssets(() => {
          if (typeof window === 'undefined') return baseAssets;
          try {
            const saved = localStorage.getItem(storageKeys.assets);
            if (saved) {
              return sanitizeAssets(JSON.parse(saved));
            }
          } catch {}
          return baseAssets;
        });
      }, [storageKeys.assets, baseAssets]);

      useEffect(() => {
        setParams(() => {
          if (typeof window === 'undefined') return baseParams;
          try {
            const saved = localStorage.getItem(storageKeys.params);
            if (saved) {
              return sanitizeParams(JSON.parse(saved));
            }
          } catch {}
          return baseParams;
        });
      }, [storageKeys.params, baseParams]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem(storageKeys.assets, JSON.stringify(assets)); } catch {}
      }, [assets, storageKeys.assets]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem(storageKeys.params, JSON.stringify(params)); } catch {}
      }, [params, storageKeys.params]);

      const [loanAmount, setLoanAmount] = useState(0);
      const [repayDate, setRepayDate] = useState(() => {
        const d = new Date(); d.setDate(d.getDate() + 60); return d.toISOString().slice(0, 10);
      });
      const [selectedCurrency, setSelectedCurrency] = useState(() => {
        if (previewSnapshot?.currency) return previewSnapshot.currency;
        if (typeof previewSnapshot?.showArs === 'boolean') {
          return previewSnapshot.showArs ? 'ARS' : 'USD';
        }
        return 'USD';
      });
      const [lastPriceTs, setLastPriceTs] = useState(null);
      const [liveError, setLiveError] = useState(null);

      const currency = selectedCurrency;
      const rate = params.exchangeRates?.[currency] ?? 1;
      const pct = (x) => (x == null ? "—" : (x * 100).toFixed(1) + "%");

      const tickerToId = (ticker) => {
        const key = sanitizeTicker(ticker);
        return coingeckoIds[key] ?? GLOBAL_COINGECKO_IDS[key];
      };

      const tickersKey = useMemo(() => assets.filter(a=>a.priceAuto!==false).map(a=>sanitizeTicker(a.ticker)).sort().join(','), [assets]);

      const inFlight = useRef(false);
      async function fetchLivePricesNow() {
        try {
          if (inFlight.current) return; inFlight.current = true;
          setLiveError(null);
          if (!params.liveQuotes) { inFlight.current = false; return; }
          const ids = Array.from(new Set(assets.filter(a => a.priceAuto !== false).map(a => tickerToId(a.ticker)).filter(Boolean)));
          if (!ids.length) { setLastPriceTs(Date.now()); inFlight.current = false; return; }
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
        finally { inFlight.current = false; }
      }

      async function fetchPricesForTickers(tickers = []) {
        try {
          if (!params.liveQuotes) return;
          const ids = Array.from(new Set(tickers.map(tickerToId).filter(Boolean)));
          if (!ids.length) return;
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
      }

      useEffect(() => {
        if (!params.liveQuotes) return;
        fetchLivePricesNow();
        const sec = Math.max(LIVE_REFRESH_SECONDS, Number(params.refreshSec || LIVE_REFRESH_SECONDS));
        const t = setInterval(fetchLivePricesNow, sec * 1000);
        return () => clearInterval(t);
      }, [params.liveQuotes, params.refreshSec, tickersKey]);

      const loyaltyTicker = loyalty?.tokenTicker ? sanitizeTicker(loyalty.tokenTicker) : null;

      const totals = useMemo(() => {
        const withValue = assets.map((a, idx) => {
          const ticker = sanitizeTicker(a.ticker);
          const qty = toNumber(a.qty);
          const price = toNumber(a.price);
          const value = qty * price;
          const ltv = ltvByTicker[ticker] ?? a.ltv ?? defaultLtv;
          return { ...a, ticker, qty, price, value, ltv, useAsCollateral: a.useAsCollateral !== false };
        });
        const total = withValue.reduce((acc, a) => acc + a.value, 0);
        const totalLoyalty = loyaltyTicker ? withValue.filter(a => a.ticker === loyaltyTicker).reduce((acc, a) => acc + a.value, 0) : 0;
        const rest = total - totalLoyalty;
        const ratioVsRest = rest > 0 ? (totalLoyalty / rest) : (totalLoyalty > 0 ? Number.POSITIVE_INFINITY : 0);
        const ratioVsTotal = total > 0 ? (totalLoyalty / total) : 0;
        const collaterals = withValue.filter(a => a.useAsCollateral);
        const totalCollateralValue = collaterals.reduce((acc, a) => acc + a.value, 0);
        const maxBorrow = collaterals.reduce((acc, a) => acc + a.value * ((ltvByTicker[a.ticker] ?? a.ltv ?? defaultLtv) || 0), 0);
        return { withValue, total, totalLoyalty, rest, ratioVsRest, ratioVsTotal, totalCollateralValue, maxBorrow };
      }, [assets, loyaltyTicker, ltvByTicker, defaultLtv]);

      const loyaltyModelActive = params.loyaltyModel ?? loyaltyModelFallback;

      const loyaltyTier = useMemo(() => {
        if (!loyalty) return aprConfig.baseTier ?? loyalty?.baseLabel ?? "—";
        if (totals.total < minBalancePerks) return loyalty.belowMinimumLabel ?? loyalty.baseLabel ?? "Sin perks";
        const ratioUsed = loyaltyModelActive === "vsTotal" ? totals.ratioVsTotal : totals.ratioVsRest;
        for (const tier of loyalty.tierThresholds ?? []) {
          if (ratioUsed >= tier.minRatio) return tier.label;
        }
        return loyalty.baseLabel ?? (aprConfig.baseTier ?? "Base");
      }, [loyalty, totals.total, minBalancePerks, loyaltyModelActive, totals.ratioVsTotal, totals.ratioVsRest, aprConfig.baseTier]);

      const aprStandardTable = aprConfig.standard ?? {};
      const aprDiscountTable = aprConfig.discounted ?? aprStandardTable;
      const aprBaseTier = aprConfig.baseTier ?? (loyalty?.baseLabel ?? "Base");
      const aprBase = aprConfig.base ?? aprStandardTable[aprBaseTier] ?? aprStandardTable[loyalty?.baseLabel] ?? 0.20;
      const lowCostEligibleTiers = aprConfig.lowCostEligibleTiers ?? loyalty?.lowCostEligibleTiers ?? [];
      const earlyRuleDays = aprConfig.earlyRuleDays ?? 45;
      const earlyAPR = aprConfig.earlyAPR ?? aprBase;

      const recommendedLoanAtTarget = useMemo(() => targetLtv * totals.totalCollateralValue, [targetLtv, totals.totalCollateralValue]);
      const capLowCost = useMemo(() => Math.min(recommendedLoanAtTarget, totals.maxBorrow), [recommendedLoanAtTarget, totals.maxBorrow]);
      const lowCostHeadroom = useMemo(() => Math.max(0, capLowCost - loanAmount), [capLowCost, loanAmount]);

      const chosenAPR = useMemo(() => {
        const table = loanAmount <= recommendedLoanAtTarget ? aprDiscountTable : aprStandardTable;
        const aprFromTier = table?.[loyaltyTier];
        if (typeof aprFromTier === 'number') return aprFromTier;
        if (aprBaseTier && typeof table?.[aprBaseTier] === 'number') return table[aprBaseTier];
        if (loyalty?.baseLabel && typeof table?.[loyalty.baseLabel] === 'number') return table[loyalty.baseLabel];
        return aprBase;
      }, [loanAmount, recommendedLoanAtTarget, aprDiscountTable, aprStandardTable, loyaltyTier, aprBaseTier, aprBase, loyalty?.baseLabel]);

      const daysUntilRepay = useMemo(() => {
        const a = new Date(); const b = new Date(repayDate);
        const diffMs = Math.max(0, b.getTime() - a.getTime());
        return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      }, [repayDate]);

      const interestCalc = useMemo(() => {
        const P = loanAmount; const d = daysUntilRepay; const r = chosenAPR;
        const earlyDays = Math.max(0, earlyRuleDays - d);
        const main = P * (Math.pow(1 + r / 365, d) - 1);
        const early = d < earlyRuleDays ? P * (Math.pow(1 + earlyAPR / 365, earlyDays) - 1) : 0;
        const total = main + early; return { main, early, total, repayTotal: P + total };
      }, [loanAmount, daysUntilRepay, chosenAPR, earlyRuleDays, earlyAPR]);

      const monthlyLoanCost = useMemo(() => loanAmount * (Math.pow(1 + chosenAPR / 365, 30) - 1), [loanAmount, chosenAPR]);

      const earnEligible = totals.total >= minBalancePerks && params.earnOptIn;
      const earnMonthly = useMemo(() => {
        if (!earnEligible) return 0;
        const days = 30;
        return totals.withValue.reduce((acc, a) => {
          if (!params.earnOnCollateral && a.useAsCollateral) return acc;
          const apr = earnAprTop[sanitizeTicker(a.ticker)] ?? 0;
          return acc + a.value * (Math.pow(1 + apr/365, days) - 1);
        }, 0);
      }, [earnEligible, params.earnOnCollateral, totals.withValue, earnAprTop]);

      const netMonthly = useMemo(() => earnMonthly - monthlyLoanCost, [earnMonthly, monthlyLoanCost]);

      const timeline = useMemo(() => {
        const totalDays = Math.max(1, daysUntilRepay);
        const steps = Math.max(4, Math.min(12, Math.ceil(totalDays / 20)));
        const arr = [];
        for (let i = 0; i <= steps; i++) {
          const day = (totalDays / steps) * i;
          const interest = loanAmount * (Math.pow(1 + chosenAPR / 365, day) - 1);
          let earn = 0;
          if (earnEligible) {
            earn = totals.withValue.reduce((acc, asset) => {
              if (!params.earnOnCollateral && asset.useAsCollateral) return acc;
              const apr = earnAprTop[sanitizeTicker(asset.ticker)] ?? 0;
              return acc + asset.value * (Math.pow(1 + apr / 365, day) - 1);
            }, 0);
          }
          const balance = Math.max(0, loanAmount + interest - earn);
          arr.push({ day, cost: interest, earn, balance });
        }
        return arr;
      }, [chosenAPR, daysUntilRepay, earnEligible, loanAmount, params.earnOnCollateral, totals.withValue, earnAprTop]);

      const overallLTVIfBorrow = useMemo(() => (totals.totalCollateralValue > 0 ? loanAmount / totals.totalCollateralValue : 0), [loanAmount, totals.totalCollateralValue]);
      const ltvTone = overallLTVIfBorrow <= targetLtv ? "ok" : (overallLTVIfBorrow <= marginCallLtv ? "warn" : "danger");

      const collateralBreakdown = useMemo(() => {
        const totalCollateral = totals.totalCollateralValue || 0;
        if (!(totalCollateral > 0)) return [];
        return totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.value > 0)
          .map((asset) => {
            const ticker = sanitizeTicker(asset.ticker);
            const policyLTV = ltvByTicker[ticker] ?? asset.ltv ?? defaultLtv;
            const maxBorrowForAsset = asset.value * policyLTV;
            const share = asset.value / totalCollateral;
            const allocatedLoan = loanAmount * share;
            const usageVsCap = maxBorrowForAsset > 0 ? allocatedLoan / maxBorrowForAsset : 0;
            let tone = "ok";
            if (usageVsCap > 0.85 || overallLTVIfBorrow >= autoRepayLtv) {
              tone = "danger";
            } else if (usageVsCap > 0.6 || overallLTVIfBorrow >= marginCallLtv) {
              tone = "warn";
            }
            return {
              id: asset.id,
              name: asset.name || ticker || `Activo ${asset.id}`,
              ticker,
              value: asset.value,
              share,
              policyLTV,
              policyPct: policyLTV * 100,
              maxBorrowForAsset,
              allocatedLoan,
              usageVsCap: Math.max(0, usageVsCap),
              tone,
            };
          })
          .sort((a, b) => b.value - a.value);
      }, [autoRepayLtv, loanAmount, marginCallLtv, overallLTVIfBorrow, totals.totalCollateralValue, totals.withValue, ltvByTicker, defaultLtv]);

      const extraCollateralForTarget = useMemo(() => {
        if (targetLtv <= 0) return 0;
        const neededCollateral = loanAmount / targetLtv;
        return Math.max(0, neededCollateral - totals.totalCollateralValue);
      }, [loanAmount, targetLtv, totals.totalCollateralValue]);

      const loyaltyReqs = useMemo(() => {
        if (!loyalty) return null;
        const denom = loyaltyModelActive === "vsTotal" ? totals.total : totals.rest;
        const tiers = (loyalty.tierThresholds ?? []).map((tier) => {
          const required = denom * tier.minRatio;
          const missing = Math.max(0, required - totals.totalLoyalty);
          return { ...tier, required, missing };
        });
        return { denom, tiers };
      }, [loyalty, loyaltyModelActive, totals.total, totals.rest, totals.totalLoyalty]);

      const meetsLowCost = useMemo(() => {
        const withinTarget = loanAmount <= recommendedLoanAtTarget;
        if (lowCostEligibleTiers.length === 0) {
          return totals.total >= minBalancePerks && withinTarget;
        }
        const hasTier = lowCostEligibleTiers.includes(loyaltyTier);
        return totals.total >= minBalancePerks && withinTarget && hasTier;
      }, [loanAmount, recommendedLoanAtTarget, loyaltyTier, totals.total, lowCostEligibleTiers, minBalancePerks]);

      const handleAssetChange = (id, patch) => setAssets(prev => prev.map(a => (a.id === id ? { ...a, ...patch } : a)));

      const addRow = () => {
        const nextId = Math.max(0, ...assets.map(a => a.id)) + 1;
        setAssets(prev => ([...prev, { id: nextId, name: "Nuevo", ticker: "TKN", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: defaultLtv }]));
      };
      const removeRow = (id) => setAssets(prev => prev.filter(a => a.id !== id));

      const loyaltyCardTitle = loyalty ? `Requisitos ${loyalty.tokenTicker ? `${loyalty.tokenTicker.toUpperCase()} & ` : ''}Colateral` : "Colateral & métricas";

      return (
        <div className="min-h-screen w-full text-neutral-900">
          <div className={`${headerClass} text-white`}>
            <div className="mx-auto max-w-7xl px-4 py-6">
              <header className="flex flex-wrap items-end justify-between gap-4">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">Simulador de Préstamos</h1>
                  <p className={`${accentClass}`}>{platformTagline}</p>
                </div>
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-2">
                    <label className="text-sm font-medium">Plataforma</label>
                    <select value={platformId} onChange={(e) => setPlatformId(PLATFORM_IDS.includes(e.target.value) ? e.target.value : initialPlatformId)} className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80">
                      {PLATFORM_IDS.map((pid) => (
                        <option key={pid} value={pid} className="text-neutral-900">{PLATFORM_CONFIGS[pid]?.name ?? pid}</option>
                      ))}
                    </select>
                  </div>
                  <div className="flex items-center gap-2 text-sm font-medium">
                    <label htmlFor="currency-select">Mostrar en</label>
                    <select
                      id="currency-select"
                      value={currency}
                      onChange={(e) => setSelectedCurrency(e.target.value)}
                      className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80"
                    >
                      {SUPPORTED_CURRENCIES.map((option) => (
                        <option
                          key={option.code}
                          value={option.code}
                          className="text-neutral-900"
                          title={option.label}
                        >
                          {option.code}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>
              </header>
            </div>
          </div>

          <div className="mx-auto max-w-7xl px-4 py-6">
            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
              <KPI title="Balance total" value={fmt(totals.total * rate, currency)} variant="button" />
              <KPI title={loyalty ? (loyalty.kpiLabel || "Loyalty Tier") : "Programa"} value={loyalty ? loyaltyTier : "—"} subtle={loyalty && totals.total < minBalancePerks ? "(balance < mínimo)" : undefined} variant="button" />
              <KPI title="APR crédito" value={`${(chosenAPR * 100).toFixed(2)}%`} subtle={meetsLowCost ? "Low-Cost activo" : undefined} variant="button" />
              <KPI title="Cap. Low-Cost (≤20% LTV)" value={fmt(capLowCost * rate, currency)} subtle="potencial" variant="button" />
              <KPI title="Tope por LTVs" value={fmt(totals.maxBorrow * rate, currency)} variant="button" />
              <KPI title="Préstamo recomendado (≤20%)" value={fmt(recommendedLoanAtTarget * rate, currency)} variant="button" />
              <KPI title="Interés hasta repago" value={fmt(interestCalc.total * rate, currency)} subtle={`${useMemo(()=>{const a=new Date(); const b=new Date(repayDate); return Math.ceil(Math.max(0,b-a)/86400000);},[repayDate])} días`} variant="button" />
              <KPI title="Total a devolver" value={fmt(interestCalc.repayTotal * rate, currency)} variant="button" />
              <KPI title="Earn mensual (hasta)" value={fmt(earnMonthly * rate, currency)} subtle={earnEligible ? (minBalancePerks > 0 ? `Savings ≥ $${minBalancePerks}` : undefined) : "no elegible"} variant="button" />
              <KPI title="Neto mensual (Earn − crédito)" value={fmt(netMonthly * rate, currency)} tone={netMonthly>=0?"ok":"danger"} variant="button" />
            </section>

            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
              <Card title="Préstamo & Repago">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 justify-items-center">
                  <Field label={`Monto a pedir (${currency})`} align="center" className="w-full max-w-xs">
                    <input
                      type="number"
                      className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                      value={(loanAmount * rate).toString()}
                      onChange={(e)=> setLoanAmount(Number(e.target.value) / rate)}
                      min={0}
                    />
                  </Field>
                  <Field label="Fecha de repago" align="center" className="w-full max-w-xs">
                    <input
                      type="date"
                      className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                      value={repayDate}
                      min={todayISO()}
                      onChange={(e)=> setRepayDate(e.target.value)}
                    />
                  </Field>
                </div>
                <div className="mt-6 space-y-3">
                  <Pill label="LTV si pides esto" value={`${(overallLTVIfBorrow*100).toFixed(2)}%`} tone={ltvTone} />
                  <Pill label="≤20% LTV (fijo)" value={loanAmount <= recommendedLoanAtTarget ? "Sí" : "No"} tone={loanAmount <= recommendedLoanAtTarget ? "ok" : "warn"} />
                  <Pill label="¿Califica Low-Cost?" value={meetsLowCost ? "Sí" : "No"} tone={meetsLowCost ? "ok" : "warn"} />
                  <Pill label="Margen Low-Cost" value={fmt(lowCostHeadroom * rate, currency)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                </div>
              </Card>

              <Card title="Salud del préstamo">
                <LTVGauge value={overallLTVIfBorrow} target={targetLtv} marginCall={marginCallLtv} autoRepay={autoRepayLtv} />
                <div className="mt-4 space-y-2">
                  <Line label="LTV actual" value={`${(overallLTVIfBorrow*100).toFixed(1)}%`} tone={ltvTone} />
                  <Line label="Objetivo Low-Cost" value={`${(targetLtv*100).toFixed(0)}%`} muted />
                  <Line label="Margin call" value={`${(marginCallLtv*100).toFixed(0)}%`} muted />
                  <Line label="Auto-repay" value={`${(autoRepayLtv*100).toFixed(0)}%`} muted />
                  <Line label="Cap Low-Cost" value={fmt(capLowCost * rate, currency)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                </div>
              </Card>

              <Card title="Parámetros (solo entorno)">
                <div className="grid grid-cols-2 gap-3">
                  {SUPPORTED_CURRENCIES.filter((option) => option.code !== 'USD').map((option) => (
                    <NumberParam
                      key={option.code}
                      label={`USD→${option.code}`}
                      value={params.exchangeRates?.[option.code] ?? baseExchangeRates[option.code] ?? DEFAULT_EXCHANGE_RATES[option.code] ?? 1}
                      onChange={(v) => setParams({
                        ...params,
                        exchangeRates: { ...params.exchangeRates, [option.code]: v },
                      })}
                    />
                  ))}

                  <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 flex flex-wrap items-center gap-3">
                    <div className="flex items-center gap-2 text-sm font-medium">
                      <span className="inline-flex items-center rounded-full bg-emerald-100 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-emerald-700">Activo</span>
                      <span>Precios en tiempo real (CoinGecko)</span>
                    </div>
                    <span className="text-xs text-neutral-500">Actualización en tiempo real cada {LIVE_REFRESH_SECONDS} segundos.</span>
                    <button onClick={fetchLivePricesNow} className="nx-btn text-sm">Actualizar ahora</button>
                    <span className="text-xs text-neutral-500">{lastPriceTs ? `Últ. actualización: ${new Date(lastPriceTs).toLocaleTimeString()}` : '— sin actualizar —'}</span>
                    {liveError && <span className="text-xs text-rose-600">Error: {liveError}</span>}
                  </div>

                  <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 flex flex-wrap items-center gap-3">
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.earnOptIn} onChange={(e)=> setParams({ ...params, earnOptIn: e.target.checked })} />
                      Considerar intereses (Savings) y compounding
                    </label>
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.earnOnCollateral} onChange={(e)=> setParams({ ...params, earnOnCollateral: e.target.checked })} />
                      Incluir colateral en Earn
                    </label>
                    {minBalancePerks > 0 && <span className="text-xs text-neutral-500">* Elegible si balance ≥ ${minBalancePerks}.</span>}
                  </div>

                  <div className="col-span-2 text-xs text-neutral-500">
                    * LTV, APR por nivel y descuentos Low-Cost provienen de la plataforma elegida. Aquí solo ajustás parámetros de entorno (cambio, frecuencia, toggles).
                  </div>
                </div>
              </Card>

              <Card title={loyaltyCardTitle}>
                <div className="grid grid-cols-1 gap-3">
                  {loyalty && loyaltyReqs?.tiers?.length ? (
                    loyaltyReqs.tiers.map((tier) => (
                      <React.Fragment key={tier.label}>
                        <Line label={`Requerido ${tier.label} (${(tier.minRatio * 100).toFixed(1)}% ${loyaltyModelActive === 'vsTotal' ? 'vs total' : 'vs resto'})`} value={fmt(tier.required * rate, currency)} />
                        <Line label={`Faltante ${tier.label}`} value={fmt(tier.missing * rate, currency)} muted={tier.missing <= 0} />
                      </React.Fragment>
                    ))
                  ) : (
                    <p className="text-sm text-neutral-500">Esta plataforma no tiene un programa de niveles ligado a un token específico.</p>
                  )}
                  <div className="h-px bg-neutral-200 my-1" />
                  <Line label={`Colateral extra para ≤${(targetLtv * 100).toFixed(0)}%`} value={fmt(extraCollateralForTarget * rate, currency)} tone={extraCollateralForTarget <= 0 ? "ok" : "warn"} />
                </div>
              </Card>
            </section>

            <section className="mb-8">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-xl font-semibold">Activos y colateral</h2>
                <div className="flex items-center gap-2">
                  <button onClick={addRow} className="nx-btn text-sm">Añadir activo</button>
                  <button onClick={() => { localStorage.removeItem(storageKeys.assets); setAssets(sanitizeAssets(platformDefaultAssets)); }} className="nx-btn nx-btn-ghost text-sm">Reset</button>
                </div>
              </div>

              <div className="overflow-x-auto rounded-2xl nx-card bg-white">
                <table className="min-w-full text-sm">
                  <thead className="bg-neutral-900 text-white sticky top-0 z-10">
                    <tr>
                      <Th>Activo</Th>
                      <Th>Ticker</Th>
                      <Th>Cantidad</Th>
                      <Th>Precio (USD)</Th>
                      <Th>Auto</Th>
                      <Th>Valor</Th>
                      <Th>Colateral</Th>
                      <Th>LTV (fijo)</Th>
                      <Th>APR Earn (flex máx)</Th>
                      <Th></Th>
                    </tr>
                  </thead>
                  <tbody>
                    {totals.withValue.map((a) => (
                      <tr key={a.id} className="border-t border-neutral-100 even:bg-neutral-50 hover:bg-neutral-100/50 transition-colors">
                        <Td align="center">
                          <input value={a.name} onChange={(e) => handleAssetChange(a.id, { name: e.target.value })} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input value={a.ticker} onChange={(e) => { const newT = sanitizeTicker(e.target.value); const newL = ltvByTicker[newT] ?? defaultLtv; handleAssetChange(a.id, { ticker: newT, ltv: newL }); if (a.priceAuto !== false) { fetchPricesForTickers([newT]); } }} className="w-24 rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input type="number" min={0} step="any" value={a.qty} onChange={(e) => { const v = e.target.valueAsNumber; handleAssetChange(a.id, { qty: Number.isFinite(v) ? v : 0 }); }} placeholder="0.00" className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input type="number" min={0} step="any" value={a.price} onChange={(e) => { const v = e.target.valueAsNumber; handleAssetChange(a.id, { price: Number.isFinite(v) ? v : 0 }); }} placeholder="0.00" disabled={a.priceAuto !== false} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center disabled:bg-neutral-50 disabled:text-neutral-400" />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" checked={a.priceAuto !== false} onChange={(e) => { handleAssetChange(a.id, { priceAuto: e.target.checked }); if (e.target.checked) { fetchPricesForTickers([a.ticker]); } }} className="h-5 w-5" />
                        </Td>
                        <Td align="center" className="font-medium">{fmt(a.value * rate, currency)}</Td>
                        <Td align="center">
                          <input type="checkbox" title="Si está activo, este activo cuenta como colateral para LTV y Tope por LTVs" checked={a.useAsCollateral} onChange={(e) => handleAssetChange(a.id, { useAsCollateral: e.target.checked })} className="h-5 w-5" />
                        </Td>
                        <Td align="center" title="Política de LTV fija por plataforma">
                          <span className="inline-block rounded-xl bg-neutral-100 px-3 py-1 font-semibold">{pct(ltvByTicker[sanitizeTicker(a.ticker)] ?? a.ltv ?? 0)}</span>
                        </Td>
                        <Td align="center" title="Flexible Savings – tasa tope mostrada públicamente">
                          <span className="inline-block rounded-xl bg-blue-50 text-blue-700 px-3 py-1 font-semibold">{pct(earnAprTop[sanitizeTicker(a.ticker)] ?? 0)}</span>
                        </Td>
                        <Td align="center">
                          <button onClick={() => removeRow(a.id)} className="nx-btn nx-btn-ghost nx-btn-sm">Borrar</button>
                        </Td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="mb-10 grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
              <Card title="Proyección del préstamo">
                <TrendChart data={timeline} currency={currency} rate={rate} />
              </Card>

              <Card title="Breakdown de colateral & LTV">
                <CollateralBreakdownCard
                  breakdown={collateralBreakdown}
                  currency={currency}
                  rate={rate}
                  totalCollateral={totals.totalCollateralValue}
                  totalMaxBorrow={totals.maxBorrow}
                  overallLTV={overallLTVIfBorrow}
                  target={targetLtv}
                  marginCall={marginCallLtv}
                  autoRepay={autoRepayLtv}
                  capLowCost={capLowCost}
                  lowCostHeadroom={lowCostHeadroom}
                />
              </Card>

              <Card title="Diagnóstico & Sugerencias">
                <ul className="list-disc pl-5 space-y-2 text-sm">
                  {loyalty ? (
                    <li>
                      Tu {loyalty.ratioLabel ?? `ratio ${loyalty.tokenTicker?.toUpperCase() || ''}`} es <b>{(totals.ratioVsRest * 100).toFixed(2)}% vs resto</b> / <b>{(totals.ratioVsTotal * 100).toFixed(2)}% vs total</b>. Modelo activo: <b>{loyaltyModelActive === "vsTotal" ? "vs total" : "vs resto"}</b>. Nivel actual: <b>{loyaltyTier}</b>.
                      {totals.total < minBalancePerks && (<span className="text-neutral-600"> (El balance total no supera el mínimo de perks).</span>)}
                    </li>
                  ) : (
                    <li>Esta plataforma no requiere ratio de token para acceder a mejores tasas: el enfoque es puramente por colateral.</li>
                  )}
                  {loyalty && loyaltyReqs?.tiers?.length ? (
                    <li>
                      {loyaltyReqs.tiers.map((tier, idx) => (
                        <span key={tier.label}>{idx > 0 ? ' · ' : ''}Para <b>{tier.label}</b> faltan {fmt(tier.missing * rate, currency)}</span>
                      ))}
                    </li>
                  ) : null}
                  <li>
                    Con tu colateral actual, el tope por LTVs es {fmt(totals.maxBorrow * rate, currency)}. El cap Low-Cost (≤{(targetLtv * 100).toFixed(0)}%) permite pedir hasta {fmt(capLowCost * rate, currency)} y deja {fmt(lowCostHeadroom * rate, currency)} de margen.
                  </li>
                  <li>
                    Para solicitar {fmt(loanAmount * rate, currency)} y mantener ≤{(targetLtv * 100).toFixed(0)}% LTV se requieren {fmt(extraCollateralForTarget * rate, currency)} adicionales en colateral.
                  </li>
                  <li>
                    APR estimado: <b>{(chosenAPR * 100).toFixed(2)}%</b>. Interés hasta repago ({daysUntilRepay} días): {fmt(interestCalc.total * rate, currency)}.{interestCalc.early > 0 && <span> Incluye interés por "early rule".</span>}
                  </li>
                  <li>
                    Earn (flex) mensual estimado {earnEligible ? (minBalancePerks > 0 ? "(tope)" : "") : (minBalancePerks > 0 ? "(requiere balance mínimo)" : "(no elegible)")}: <b>{fmt(earnMonthly * rate, currency)}</b>. Neto mensual: <b className={netMonthly>=0?"text-emerald-700":"text-rose-700"}>{fmt(netMonthly * rate, currency)}</b>.
                  </li>
                </ul>
              </Card>

              <Card title="Exportar / Plantilla">
                <p className="text-sm text-neutral-700 mb-3">Guardamos tus datos en <code>localStorage</code>. Podés exportar un JSON con todo o resetear la demo.</p>
                <div className="flex flex-wrap gap-3">
                  <button className="nx-btn text-sm" onClick={() => {
                    const blob = new Blob([ JSON.stringify({ assets, params }, null, 2) ], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url; a.download = `${exportPrefix}_${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
                  }}>Exportar JSON</button>

                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Restablecer parámetros por defecto?")) { localStorage.removeItem(storageKeys.params); setParams({ ...baseParams }); } }}>Reset parámetros</button>
                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Restablecer activos por defecto?")) { localStorage.removeItem(storageKeys.assets); setAssets(sanitizeAssets(platformDefaultAssets)); } }}>Reset activos</button>
                </div>
                <div className="mt-4 text-xs text-neutral-500"><p>{disclaimers.finePrint || '* Este simulador es orientativo. Verifica términos/tasas vigentes en la plataforma oficial.'}</p></div>
              </Card>
            </section>

            <footer className="text-xs text-neutral-500">© {new Date().getFullYear()} – Demo técnica. Estilos y métricas se adaptan según la plataforma elegida.</footer>
          </div>
        </div>
      );
    }

    // UI helpers (pocas funciones y tono visual)
    function KPI({ title, value, subtle, tone, variant }) {
      const toneCls = tone === 'ok' ? 'text-emerald-200' : tone === 'danger' ? 'text-rose-200' : '';
      const baseCls = variant === 'button' ? 'nx-kpi-btn' : 'bg-white nx-kpi';
      return (
        <div className={`relative overflow-hidden rounded-2xl p-4 shadow-sm transition-transform duration-200 ${baseCls} cursor-pointer`} role="button" aria-label={title}>
          <div className={`text-xs uppercase tracking-wide text-center ${variant==='button' ? 'text-white/80' : 'text-neutral-500'}`}>{title}</div>
          <div className={`mt-1 text-xl font-bold text-center ${toneCls}`}>{value}</div>
          {subtle && <div className={`text-xs mt-1 text-center ${variant==='button' ? 'text-white/70' : 'text-neutral-500'}`}>{subtle}</div>}
        </div>
      );
    }
    function Card({ title, children }) {
      return (
        <div className="rounded-2xl bg-white p-5 shadow-sm nx-card">
          <div className="mb-3 flex items-center justify-between"><h3 className="text-lg font-semibold">{title}</h3></div>
          {children}
        </div>
      );
    }
    function Field({ label, children, align = "left", className = "" }) {
      const centered = align === "center";
      return (
        <label className={`${centered ? "flex flex-col items-center text-center gap-2 text-sm" : "block text-sm"} ${className}`}>
          <div className={`text-neutral-700 font-medium ${centered ? "text-base" : "mb-1"}`}>{label}</div>
          {children}
        </label>
      );
    }
    function NumberParam({ label, value, onChange, step = 1, ringClass = "focus:ring-blue-700" }) {
      return (
        <Field label={label}>
          <input type="number" value={value} step={step} onChange={(e) => onChange(Number(e.target.value))} className={`w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 ${ringClass} text-right`} />
        </Field>
      );
    }
    function Th({ children }) { return (<th className="px-3 py-2 text-center align-middle text-xs font-semibold">{children}</th>); }
    function Td({ children, align = "left" }) {
      const alignClass = align === "right" ? "text-right" : align === "center" ? "text-center" : "text-left";
      return (<td className={`px-3 py-2 align-middle ${alignClass}`}>{children}</td>);
    }
    function Pill({ label, value, tone = "neutral" }) {
      const tones = {
        ok: "bg-emerald-50 text-emerald-700 border-emerald-200",
        warn: "bg-amber-50 text-amber-700 border-amber-200",
        danger: "bg-rose-50 text-rose-700 border-rose-200",
        neutral: "bg-neutral-50 text-neutral-700 border-neutral-200",
      };
      return (
        <div className={`rounded-2xl border px-4 py-3 flex items-center justify-between gap-4 ${tones[tone]}`}>
          <span className="text-sm font-medium text-neutral-600">{label}</span>
          <span className="text-base font-semibold">{value}</span>
        </div>
      );
    }
    function Line({ label, value, muted = false, tone }) {
      const color = tone === "ok" ? "text-emerald-700" : tone === "warn" ? "text-amber-700" : tone === "danger" ? "text-rose-700" : "";
      return (
        <div className="flex items-center justify-between gap-4">
          <span className={`text-sm ${muted ? "text-neutral-400" : "text-neutral-700"}`}>{label}</span>
          <span className={`text-sm font-medium ${color}`}>{value}</span>
        </div>
      );
    }

    function LTVGauge({ value, target, marginCall, autoRepay }) {
      const clamp = (v) => Math.max(0, Math.min(1, Number.isFinite(v) ? v : 0));
      const size = 300;
      const center = size / 2;
      const radius = center - 18;
      const ring = 34;
      const startAngle = (Math.PI * 5) / 4; // 225°
      const sweepAngle = (Math.PI * 3) / 2; // 270°
      const angleFor = (pct) => startAngle - clamp(pct) * sweepAngle;
      const polarPoint = (pct, r = radius) => {
        const angle = angleFor(pct);
        return {
          angle,
          x: center + r * Math.cos(angle),
          y: center + r * Math.sin(angle),
        };
      };
      const describeArc = (from, to, r = radius) => {
        const start = polarPoint(from, r);
        const end = polarPoint(to, r);
        const delta = (to - from) * sweepAngle;
        const largeArc = Math.abs(delta) > Math.PI ? 1 : 0;
        const sweepFlag = delta <= 0 ? 1 : 0;
        return `M ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${end.x} ${end.y}`;
      };
      const zones = [
        { label: 'Óptimo', max: target, color: '#22c55e', legend: `≤${Math.round(target * 100)}%` },
        { label: 'Estable', max: marginCall, color: '#facc15', legend: `≤${Math.round(marginCall * 100)}%` },
        { label: 'A riesgo', max: autoRepay, color: '#fb923c', legend: `≤${Math.round(autoRepay * 100)}%` },
        { label: 'Crítico', max: 1, color: '#ef4444', legend: '> límite' },
      ];
      const gap = 0.005;
      const segments = zones.reduce((acc, zone) => {
        const prev = acc[acc.length - 1];
        const from = prev ? prev.rawTo : 0;
        const capped = Math.min(zone.max, 1);
        if (capped <= from) return acc;
        const to = Math.max(Math.min(1, capped), from + 0.002);
        acc.push({ from, to, rawTo: capped, color: zone.color, label: zone.label, legend: zone.legend });
        return acc;
      }, []);
      const valuePct = clamp(value);
      const pointerAngle = angleFor(valuePct);
      const pointerTip = polarPoint(valuePct, radius - ring * 0.25);
      const pointerBaseRadius = 22;
      const baseLeft = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle + Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle + Math.PI / 2),
      };
      const baseRight = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle - Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle - Math.PI / 2),
      };
      const pointerPath = `M ${baseLeft.x} ${baseLeft.y} L ${pointerTip.x} ${pointerTip.y} L ${baseRight.x} ${baseRight.y} Z`;
      const status = valuePct <= target
        ? 'Óptimo'
        : valuePct <= marginCall
          ? 'Estable'
          : valuePct <= autoRepay
            ? 'A riesgo'
            : 'Crítico';
      const statusTone = valuePct <= target
        ? { text: 'text-emerald-500', bg: 'bg-emerald-100/70', dot: '#22c55e' }
        : valuePct <= marginCall
          ? { text: 'text-amber-500', bg: 'bg-amber-100/70', dot: '#facc15' }
          : valuePct <= autoRepay
            ? { text: 'text-orange-500', bg: 'bg-orange-100/70', dot: '#fb923c' }
            : { text: 'text-rose-500', bg: 'bg-rose-100/70', dot: '#ef4444' };
      const thresholds = [
        { pct: target, label: `${Math.round(target * 100)}%` },
        { pct: marginCall, label: `${Math.round(marginCall * 100)}%` },
        { pct: autoRepay, label: `${Math.round(autoRepay * 100)}%` },
      ].filter((t, idx, arr) => t.pct > 0 && t.pct <= 1 && arr.findIndex((tt) => tt.pct === t.pct) === idx);
      const tickOuter = radius + 6;
      const tickInner = radius - ring + 4;
      return (
        <div className="flex flex-col items-center">
          <svg viewBox={`0 0 ${size} ${size}`} className="w-full max-w-[340px]">
            <defs>
              <radialGradient id="gaugeDepth" cx="50%" cy="50%" r="60%">
                <stop offset="0%" stopColor="#ffffff" stopOpacity="0.98" />
                <stop offset="100%" stopColor="#e2e8f0" stopOpacity="0.55" />
              </radialGradient>
              <linearGradient id="gaugeRing" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.12)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <filter id="pointerShadow" x="-40%" y="-40%" width="180%" height="180%">
                <feDropShadow dx="0" dy="3" stdDeviation="3" floodColor="rgba(15,23,42,0.35)" />
              </filter>
              <filter id="ringShadow" x="-30%" y="-30%" width="160%" height="160%">
                <feDropShadow dx="0" dy="8" stdDeviation="12" floodColor="rgba(15,23,42,0.18)" floodOpacity="0.5" />
              </filter>
            </defs>
            <g filter="url(#ringShadow)">
              <circle cx={center} cy={center} r={radius + 10} fill="#f8fafc" />
              <circle cx={center} cy={center} r={radius + 6} fill="url(#gaugeRing)" opacity="0.65" />
              <circle cx={center} cy={center} r={radius - ring * 0.15} fill="url(#gaugeDepth)" />
            </g>
            {segments.map((seg, idx) => {
              const isFirst = idx === 0;
              const isLast = idx === segments.length - 1;
              const from = seg.from + (isFirst ? 0 : gap);
              const to = Math.max(from + 0.001, seg.to - (isLast ? 0 : gap));
              return (
                <path
                  key={seg.label}
                  d={describeArc(from, to, radius)}
                  stroke={seg.color}
                  strokeWidth={ring}
                  strokeLinecap="round"
                  fill="none"
                  opacity="0.95"
                />
              );
            })}
            {thresholds.map((t) => {
              const outer = polarPoint(t.pct, tickOuter);
              const inner = polarPoint(t.pct, tickInner);
              const labelAnchor = t.pct < 0.33 ? 'start' : t.pct > 0.67 ? 'end' : 'middle';
              const labelOffset = t.pct > 0.67 ? -10 : t.pct < 0.33 ? 10 : 0;
              const labelY = t.pct < 0.2 ? inner.y + 16 : t.pct > 0.8 ? inner.y + 16 : inner.y - 10;
              return (
                <g key={t.label}>
                  <line x1={outer.x} y1={outer.y} x2={inner.x} y2={inner.y} stroke="#0f172a" strokeOpacity="0.18" strokeWidth="2" strokeLinecap="round" />
                  <text
                    x={inner.x + labelOffset}
                    y={labelY}
                    textAnchor={labelAnchor}
                    className="fill-slate-500"
                    style={{ fontSize: '10px', fontWeight: 600 }}
                  >
                    {t.label}
                  </text>
                </g>
              );
            })}
            <g filter="url(#pointerShadow)">
              <path d={pointerPath} fill="#0f172a" opacity="0.92" />
            </g>
            <circle cx={center} cy={center} r={18} fill="#1e3a8a" stroke="#f8fafc" strokeWidth="5" />
            <circle cx={center} cy={center} r={6} fill="#f1f5f9" />
            <text
              x={center}
              y={center + 6}
              textAnchor="middle"
              className="fill-slate-700"
              style={{ fontWeight: 700, fontSize: '24px' }}
            >
              {`${(valuePct * 100).toFixed(1)}%`}
            </text>
            <text
              x={center}
              y={center + 34}
              textAnchor="middle"
              className="fill-slate-400"
              style={{ fontWeight: 600, fontSize: '11px', letterSpacing: '0.16em' }}
            >
              Salud
            </text>
          </svg>
          <div className={`mt-4 flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold ${statusTone.bg} ${statusTone.text}`}>
            <span className="inline-flex h-2.5 w-2.5 rounded-full" style={{ backgroundColor: statusTone.dot }} />
            {status}
          </div>
          <div className="mt-5 grid grid-cols-2 gap-3 text-[11px] font-semibold text-neutral-600">
            {segments.map((seg) => (
              <div key={seg.label} className="flex items-center gap-2">
                <span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: seg.color }} />
                <span>{seg.legend} {seg.label}</span>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function TrendChart({ data, currency, rate }) {
      if (!data || data.length < 2) {
        return <div className="text-sm text-neutral-500">Configura un monto y una fecha de repago para visualizar la trayectoria.</div>;
      }
      const maxVal = Math.max(...data.flatMap(d => [d.cost, d.earn, d.balance]));
      if (!(maxVal > 0)) {
        return <div className="text-sm text-neutral-500">Agrega colateral o préstamo para generar la proyección.</div>;
      }
      const width = 420;
      const height = 220;
      const paddingX = 36;
      const paddingY = 28;
      const step = data.length > 1 ? (width - paddingX * 2) / (data.length - 1) : 0;
      const baseY = height - paddingY;
      const scaleY = (value) => {
        if (!maxVal) return baseY;
        const ratio = value / maxVal;
        const usableHeight = height - paddingY * 1.6;
        return baseY - ratio * usableHeight;
      };
      const pathFor = (key) => data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point[key]);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPath = data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point.balance);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPathClosed = `${areaPath} L ${paddingX + step * (data.length - 1)} ${baseY} L ${paddingX} ${baseY} Z`;
      const tickIndexes = Array.from(new Set([0, Math.floor(data.length / 2), data.length - 1])).filter(i => i >= 0 && i < data.length);
      const ticks = tickIndexes.map((i) => ({ x: paddingX + i * step, label: `Día ${Math.round(data[i].day)}` }));
      const colors = { balance: '#8b5cf6', cost: '#60a5fa', earn: '#34d399' };
      const lastPoint = data[data.length - 1];
      return (
        <div>
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full">
            <defs>
              <linearGradient id="chartBg" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.08)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <linearGradient id="balanceArea" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#a855f7" stopOpacity="0.35" />
                <stop offset="100%" stopColor="#a855f7" stopOpacity="0.05" />
              </linearGradient>
            </defs>
            <rect x="0" y="0" width={width} height={height} fill="url(#chartBg)" opacity="1" rx="18" />
            <path d={`M ${paddingX} ${baseY} L ${paddingX + step * (data.length - 1)} ${baseY}`} stroke="rgba(148,163,184,0.35)" strokeWidth="1.5" strokeLinecap="round" />
            <path d={areaPathClosed} fill="url(#balanceArea)" opacity="0.6" />
            <path d={pathFor('balance')} stroke={colors.balance} strokeWidth="3" fill="none" strokeLinecap="round" />
            <path d={pathFor('cost')} stroke={colors.cost} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="4 4" />
            <path d={pathFor('earn')} stroke={colors.earn} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="6 4" />
            {ticks.map((tick) => (
              <g key={tick.label} transform={`translate(${tick.x}, ${baseY + 14})`}>
                <circle cx="0" cy="0" r="2" fill="rgba(148,163,184,0.5)" />
                <text textAnchor="middle" dy="12" className="fill-slate-400" style={{ fontSize: '10px', letterSpacing: '0.04em' }}>{tick.label}</text>
              </g>
            ))}
            {data.map((point, index) => {
              const x = paddingX + index * step;
              return (
                <circle key={`dot-${index}`} cx={x} cy={scaleY(point.balance)} r="3.5" fill="#8b5cf6" stroke="#fff" strokeWidth="1.5" />
              );
            })}
          </svg>
          <div className="mt-3 flex flex-wrap gap-4 text-xs font-semibold text-neutral-500">
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.balance }} />Balance neto</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.cost }} />Costo (interés)</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.earn }} />Earn estimado</span>
          </div>
          <div className="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3 text-sm">
            <div className="rounded-xl bg-blue-50/70 px-3 py-2">
              <div className="text-xs uppercase text-blue-600">Interés total</div>
              <div className="font-semibold text-blue-700">{fmt(lastPoint.cost * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-emerald-50/70 px-3 py-2">
              <div className="text-xs uppercase text-emerald-600">Earn acumulado</div>
              <div className="font-semibold text-emerald-700">{fmt(lastPoint.earn * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-violet-50/70 px-3 py-2">
              <div className="text-xs uppercase text-violet-600">Balance estimado</div>
              <div className="font-semibold text-violet-700">{fmt(lastPoint.balance * rate, currency)}</div>
            </div>
          </div>
        </div>
      );
    }

    function CollateralBreakdownCard({ breakdown, currency, rate, totalCollateral, totalMaxBorrow, overallLTV, target, marginCall, autoRepay, capLowCost, lowCostHeadroom }) {
      if (!breakdown || breakdown.length === 0) {
        return <div className="text-sm text-neutral-500">Activa al menos un activo como colateral y asigna un préstamo para visualizar la distribución.</div>;
      }
      const toneColors = { ok: '#34d399', warn: '#facc15', danger: '#fb7185' };
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      let accShare = 0;
      const segments = breakdown.map((item) => {
        const start = accShare;
        accShare += item.share;
        const end = Math.min(1, accShare);
        return { ...item, start, end };
      });
      const gradientStops = segments.map((seg) => `${toneColors[seg.tone]} ${(seg.start * 100).toFixed(2)}% ${(seg.end * 100).toFixed(2)}%`).join(', ');
      const covered = Math.min(1, accShare);
      const gradient = `conic-gradient(${gradientStops}${covered < 1 ? `, rgba(148,163,184,0.2) ${(covered * 100).toFixed(2)}% 100%` : ''})`;
      const overallTone = overallLTV <= target ? 'ok' : overallLTV <= marginCall ? 'warn' : 'danger';
      const overallLabel = overallTone === 'ok' ? 'Sano' : overallTone === 'warn' ? 'Observar' : 'En riesgo';
      const overallToneClass = overallTone === 'ok' ? 'text-emerald-600' : overallTone === 'warn' ? 'text-amber-600' : 'text-rose-600';
      return (
        <div className="flex flex-col gap-5">
          <div className="flex flex-wrap items-center justify-center gap-6">
            <div className="relative h-40 w-40 rounded-full shadow-inner" style={{ background: gradient }}>
              <div className="absolute inset-8 rounded-full bg-white shadow flex flex-col items-center justify-center text-center">
                <span className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">LTV actual</span>
                <span className="text-xl font-bold text-neutral-900">{(overallLTV * 100).toFixed(1)}%</span>
                <span className={`mt-1 text-xs font-semibold ${overallToneClass}`}>{overallLabel}</span>
              </div>
            </div>
            <div className="space-y-2 text-sm text-neutral-600">
              <div><span className="font-semibold text-neutral-800">Colateral</span>: {fmt(totalCollateral * rate, currency)}</div>
              <div><span className="font-semibold text-neutral-800">Tope por LTVs</span>: {fmt(totalMaxBorrow * rate, currency)}</div>
              <div><span className="font-semibold text-neutral-800">Cap Low-Cost</span>: {fmt(capLowCost * rate, currency)} ({lowCostHeadroom > 0 ? `${fmt(lowCostHeadroom * rate, currency)} libres` : 'sin margen'})</div>
              <div className="flex flex-wrap gap-3 text-xs text-neutral-500 pt-1">
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.ok }} />Sano ≤ {Math.round(target * 100)}%</span>
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.warn }} />Observar ≤ {Math.round(marginCall * 100)}%</span>
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.danger }} />Riesgo ≥ {Math.round(autoRepay * 100)}%</span>
              </div>
            </div>
          </div>
          <div className="space-y-3">
            {breakdown.map((item) => {
              const usagePct = Math.max(0, Math.min(100, item.usageVsCap * 100));
              const badgeLabel = item.tone === 'ok' ? 'Sano' : item.tone === 'warn' ? 'Vigilar' : 'Crítico';
              return (
                <div key={item.id} className="rounded-2xl border border-neutral-200 p-3">
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className="text-sm font-semibold text-neutral-800">{item.name}</div>
                      <div className="text-xs text-neutral-500">{item.ticker || '—'} · Colateral {fmt(item.value * rate, currency)} ({(item.share * 100).toFixed(1)}%)</div>
                      <div className="text-xs text-neutral-500">LTV tope {item.policyPct.toFixed(0)}% · Cap {fmt(item.maxBorrowForAsset * rate, currency)}</div>
                    </div>
                    <span className={`rounded-full px-2 py-1 text-xs font-semibold ${toneBadge[item.tone]}`}>{badgeLabel}</span>
                  </div>
                  <div className="mt-3 h-2.5 w-full overflow-hidden rounded-full bg-neutral-200">
                    <div className="h-full" style={{ width: `${usagePct.toFixed(1)}%`, backgroundColor: toneColors[item.tone], transition: 'width .3s ease' }} />
                  </div>
                  <div className="mt-1 flex justify-between text-[11px] text-neutral-500">
                    <span>Uso: {fmt(item.allocatedLoan * rate, currency)}</span>
                    <span>Tope: {fmt(item.maxBorrowForAsset * rate, currency)}</span>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Tests mínimos (no tocar a menos que estén mal) + 2 nuevos
    function approxEq(a, b, eps = 1e-6) { return Math.abs(a - b) <= eps; }
    function runDevTests() {
      try {
        const nexo = PLATFORM_CONFIGS.nexo;
        const binance = PLATFORM_CONFIGS.binance;
        console.assert(approxEq((nexo.policies?.targetLtv ?? 0), 0.20), 'Test1: Target LTV Nexo 20%');
        console.assert(approxEq((nexo.ltvByTicker?.BTC ?? 0), 0.50), 'Test2: LTV BTC Nexo 50%');
        console.assert((binance.earnAprTop?.BNB ?? 0) >= 0.05, 'Test3: Earn BNB Binance ≥5%');
        console.assert(GLOBAL_COINGECKO_IDS.BTC === 'bitcoin', 'Test4: CoinGecko BTC');
        console.assert(PLATFORM_IDS.includes('nexo') && PLATFORM_IDS.includes('binance'), 'Test5: plataformas registradas');
        const lowCostNexo = nexo.apr?.lowCostEligibleTiers || [];
        console.assert(lowCostNexo.includes('Gold') && lowCostNexo.includes('Platinum'), 'Test6: Low-Cost tiers Nexo');
        const defaultTicker = (nexo.defaultAssets?.[0]?.ticker || '').toUpperCase();
        console.assert(defaultTicker === 'BTC', 'Test7: default asset BTC');
        console.log('%cSanity tests OK', 'color:green');
      } catch (e) { console.error('Sanity tests failed', e); }
    }
    if (typeof window !== 'undefined') { try { runDevTests(); } catch (_) {} }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SimuladorPrestamos />);
  </script>
</body>
</html>
