<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Préstamos / Plataforma</title>
  <script>
  /**
   * Shim CORS-aware para GitHub Pages:
   * - Redirige cualquier fetch a rutas relativas /api/binance/* hacia el preset estático.
   * - El preset remoto quedó deshabilitado por completo (sin fallback automático).
   */
  (function () {
    const STATIC_PREFIX = './api/binance/';
    const REMOTE_PREFIX = '/api/binance/';
    const API_PREFIX = (() => {
      try {
        const resolved = new URL(STATIC_PREFIX, window.location.href).pathname;
        return (resolved.endsWith('/') ? resolved : `${resolved}/`).replace(/\/+/g, '/');
      } catch (_) {
        return REMOTE_PREFIX;
      }
    })();
    const MODE_KEY = 'spm_binanceShimMode';
    const ENDPOINT_KEY = 'spm_binanceBaselineEndpoint';

    window.__REMOTE_PRESET_DISABLED__ = true;

    const safeGetItem = (key) => {
      try { return localStorage.getItem(key); }
      catch (_) { return null; }
    };
    const safeSetItem = (key, value) => {
      try { localStorage.setItem(key, value); }
      catch (_) {}
    };
    const safeRemoveItem = (key) => {
      try { localStorage.removeItem(key); }
      catch (_) {}
    };

    const resolveShimMode = () => {
      safeSetItem(MODE_KEY, 'static');
      return 'static';
    };

    resolveShimMode();

    const stripRemoteEndpointParam = () => {
      try {
        const url = new URL(window.location.href);
        if (url.searchParams.has('binanceApiEndpoint')) {
          url.searchParams.delete('binanceApiEndpoint');
          const clean = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState(null, document.title, clean);
        }
      } catch (_) {}
    };
    stripRemoteEndpointParam();

    const resolveBaselineEndpoint = () => {
      safeRemoveItem(ENDPOINT_KEY);
      return new URL(`${STATIC_PREFIX}loans`, window.location.href).toString().replace(/\/$/, '');
    };

    const BASELINE_ENDPOINT = resolveBaselineEndpoint();
    window.__BINANCE_BASELINE_ENDPOINT__ = BASELINE_ENDPOINT;

    console.info('[shim] Binance baseline shim activo → modo estático forzado. Endpoint base:', BASELINE_ENDPOINT);

    const _fetch = window.fetch.bind(window);

    const toRequestUrl = (input) => {
      if (typeof input === 'string') {
        try { return new URL(input, window.location.href); }
        catch (_) { return null; }
      }
      if (input && typeof input === 'object' && typeof input.url === 'string') {
        try { return new URL(input.url, window.location.href); }
        catch (_) { return null; }
      }
      return null;
    };

    const mapToStatic = (pathname, search) => {
      const suffix = pathname.slice(API_PREFIX.length).replace(/^\/+/, '');
      const base = new URL(STATIC_PREFIX, window.location.href);
      const target = new URL(suffix || '.', base);
      if (!/\.json$/i.test(target.pathname)) {
        target.pathname = target.pathname.replace(/\/$/, '') + '.json';
      }
      if (search) target.search = search;
      return target.toString();
    };

    const cloneInit = (input, init) => {
      if (!input || typeof input !== 'object') return init;
      return {
        method: input.method,
        headers: input.headers,
        body: input.body,
        mode: input.mode,
        credentials: input.credentials,
        cache: input.cache,
        redirect: input.redirect,
        referrer: input.referrer,
        referrerPolicy: input.referrerPolicy,
        integrity: input.integrity,
        keepalive: input.keepalive,
        signal: input.signal,
        ...init,
      };
    };

    window.fetch = (input, init) => {
      try {
        const requestUrl = toRequestUrl(input);
        if (requestUrl && requestUrl.pathname.startsWith(API_PREFIX)) {
          const staticUrl = mapToStatic(requestUrl.pathname, requestUrl.search);
          return typeof input === 'string'
            ? _fetch(staticUrl, init)
            : _fetch(staticUrl, cloneInit(input, init));
        }
      } catch (_) {}
      return _fetch(input, init);
    };
  })();
  </script>
  <script>
  (function () {
    const LOG_PREFIX = '[nexo-sim]';
    const NAMESPACE = '__nexoSim';
    const DEFAULT_CONFIG = {
      forceOn: true,
      refreshMs: 5 * 60 * 1000,
      timeoutMs: 12000,
      aprFundingAlpha: 0.35,
      loanAprClamp: { min: 0.015, max: 0.28 },
      netApr: {
        useVip: true,
        ltvDivisor: 'current',
        aprClamp: { min: -0.25, max: 0.32 },
        nonNegative: true,
      },
      baseAPR: {
        USDT: 0.059,
        USDC: 0.057,
        BUSD: 0.058,
        FDUSD: 0.056,
        BTC: 0.072,
        ETH: 0.068,
        BNB: 0.065,
      },
      loanCoins: ['USDT', 'USDC', 'BUSD', 'FDUSD', 'BTC', 'ETH', 'BNB'],
      fundingSymbols: ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'AVAXUSDT'],
      collateralYield: {
        BTC: { apr: 0.02 },
        ETH: { apr: 0.022 },
        BNB: { apr: 0.025 },
        SOL: { apr: 0.02 },
        XRP: { apr: 0.012 },
        ADA: { apr: 0.00038 },
        ALGO: { apr: 0.00047 },
        AVAX: { apr: 0.018 },
        DOGE: { apr: 0.006 },
        MATIC: { apr: 0.014 },
        LINK: { apr: 0.015 },
        ARB: { apr: 0.016 },
        OP: { apr: 0.016 },
      },
      assetOverrides: {
        BNB: { liqBias: -0.05 },
        SOL: { liqBias: 0.05 },
        DOGE: { liqBias: 0.08 },
        ADA: { initialLtv: 0.4756, marginCallLtv: 0.8, liquidationLtv: 0.85 },
        ALGO: { initialLtv: 0.1024, marginCallLtv: 0.8, liquidationLtv: 0.85 },
      },
      skipAssets: ['USDT', 'USDC', 'BUSD', 'TUSD', 'FDUSD'],
      universe: {
        maxAssets: 12,
        fallback: ['BTC', 'ETH', 'BNB', 'SOL', 'XRP', 'ADA', 'AVAX', 'DOGE', 'MATIC', 'LINK', 'ARB', 'OP'],
      },
      ltvModel: {
        initMin: 0.35,
        initMax: 0.75,
        sigmaK: 2.6,
        sigmaFallback: 0.015,
        sigmaFloor: 0.005,
        mcStep: 0.1,
        liqStep: 0.07,
        liqCap: 0.9,
        epsilon: 0.01,
      },
      vip: {
        level: 3,
        discounts: {
          0: 0,
          1: 0.003,
          2: 0.006,
          3: 0.01,
          4: 0.0125,
          5: 0.015,
        },
        fallbackDiscount: 0.01,
      },
    };

    const clone = (value) => {
      if (Array.isArray(value)) return value.map(clone);
      if (value && typeof value === 'object') {
        const out = {};
        Object.keys(value).forEach((key) => {
          out[key] = clone(value[key]);
        });
        return out;
      }
      return value;
    };

    const mergeDeep = (target, source) => {
      if (!source || typeof source !== 'object') return target;
      Object.keys(source).forEach((key) => {
        const incoming = source[key];
        if (incoming && typeof incoming === 'object' && !Array.isArray(incoming)) {
          target[key] = mergeDeep(target[key] && typeof target[key] === 'object' ? target[key] : {}, incoming);
        } else {
          target[key] = clone(incoming);
        }
      });
      return target;
    };

    const existingNamespace = window[NAMESPACE] && typeof window[NAMESPACE] === 'object' ? window[NAMESPACE] : null;
    const runtimeConfig = clone(DEFAULT_CONFIG);
    if (existingNamespace && existingNamespace.config) {
      mergeDeep(runtimeConfig, existingNamespace.config);
    }
    if (window.__nexoSimConfig && typeof window.__nexoSimConfig === 'object') {
      mergeDeep(runtimeConfig, window.__nexoSimConfig);
    }

    const activationParam = (() => {
      try {
        const url = new URL(window.location.href);
        return url.searchParams.get('sim');
      } catch (error) {
        console.warn(LOG_PREFIX, 'No se pudo leer los parámetros de la URL.', error);
        return null;
      }
    })();

    if (!(runtimeConfig.forceOn || activationParam === '1')) {
      return;
    }

    const upstreamFetch = window.fetch ? window.fetch.bind(window) : null;
    if (!upstreamFetch) {
      console.warn(LOG_PREFIX, 'fetch no está disponible, abortando shim dinámico.');
      return;
    }

    console.info(LOG_PREFIX, 'Shim dinámico activo (modelo: dynamic_model).');

    const state = {
      snapshot: existingNamespace && existingNamespace.snapshot ? existingNamespace.snapshot : null,
      lastTs: 0,
      inflight: null,
    };

    const toNumber = (value, fallback = 0) => {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    };

    const clamp = (value, range) => {
      const min = Array.isArray(range) ? toNumber(range[0], -Infinity) : -Infinity;
      const max = Array.isArray(range) ? toNumber(range[1], Infinity) : Infinity;
      const num = toNumber(value, min);
      return Math.min(max, Math.max(min, num));
    };

    const uniqPush = (list, value) => {
      const upper = (value || '').toUpperCase();
      if (!upper) return;
      if (!list.set.has(upper)) {
        list.set.add(upper);
        list.values.push(upper);
      }
    };

    const createJsonResponse = (payload, init) => new Response(JSON.stringify(payload, null, 2), {
      status: (init && init.status) || 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-store',
        ...(init && init.headers ? init.headers : {}),
      },
    });

    const withTimeout = async (promise, timeoutMs, label) => {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        return await promise(controller.signal);
      } catch (error) {
        if (error && error.name === 'AbortError') {
          throw new Error(label ? `${label}: timeout tras ${timeoutMs}ms` : `timeout tras ${timeoutMs}ms`);
        }
        throw error;
      } finally {
        clearTimeout(timer);
      }
    };

    const jget = async (url) => withTimeout(async (signal) => {
      const response = await upstreamFetch(url, { cache: 'no-store', signal });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} al consultar ${url}`);
      }
      return response.json();
    }, runtimeConfig.timeoutMs, `GET ${url}`);

    const SUFFIX_BLACKLIST = ['UP', 'DOWN', 'BULL', 'BEAR'];
    const buildSkipSet = () => {
      const fromUniverse = runtimeConfig.universe && Array.isArray(runtimeConfig.universe.skipAssets)
        ? runtimeConfig.universe.skipAssets
        : [];
      const combined = [...(runtimeConfig.skipAssets || []), ...fromUniverse];
      return new Set(combined.map((item) => (item || '').toUpperCase()));
    };
    const loadUniverseAuto = async (maxN, skipSet) => {
      const fallback = Array.isArray(runtimeConfig.universe && runtimeConfig.universe.fallback)
        ? runtimeConfig.universe.fallback.map((item) => (item || '').toUpperCase())
        : [];
      try {
        const raw = await jget('https://api.binance.com/api/v3/ticker/24hr');
        if (!Array.isArray(raw)) throw new Error('Respuesta inesperada.');
        const ranking = raw
          .filter((entry) => {
            if (!entry || typeof entry.symbol !== 'string') return false;
            if (!/USDT$/i.test(entry.symbol)) return false;
            const base = entry.symbol.replace(/USDT$/i, '').toUpperCase();
            if (!base) return false;
            if (skipSet.has(base)) return false;
            if (SUFFIX_BLACKLIST.some((suffix) => base.endsWith(suffix))) return false;
            return true;
          })
          .map((entry) => ({
            base: entry.symbol.replace(/USDT$/i, '').toUpperCase(),
            quoteVolume: toNumber(entry.quoteVolume),
          }))
          .sort((a, b) => (b.quoteVolume || 0) - (a.quoteVolume || 0));
        const collector = { values: [], set: new Set() };
        for (const item of ranking) {
          if (collector.values.length >= maxN) break;
          uniqPush(collector, item.base);
        }
        if (collector.values.length === 0 && fallback.length) {
          fallback.forEach((asset) => uniqPush(collector, asset));
        }
        return collector.values.slice(0, maxN);
      } catch (error) {
        console.warn(LOG_PREFIX, 'Fallo loadUniverseAuto, usando fallback.', error);
        return fallback.slice(0, maxN);
      }
    };

    const computeFundingAnnualized = async () => {
      const symbols = Array.isArray(runtimeConfig.fundingSymbols) ? runtimeConfig.fundingSymbols : [];
      const results = {};
      await Promise.all(symbols.map(async (symbol) => {
        try {
          const data = await jget(`https://fapi.binance.com/fapi/v1/fundingRate?limit=24&symbol=${encodeURIComponent(symbol)}`);
          if (Array.isArray(data) && data.length) {
            const rates = data
              .map((entry) => toNumber(entry.fundingRate))
              .filter((value) => Number.isFinite(value));
            if (rates.length) {
              const meanAbs = rates.reduce((acc, value) => acc + Math.abs(value), 0) / rates.length;
              results[symbol] = meanAbs * 3 * 365;
            }
          }
        } catch (error) {
          console.warn(LOG_PREFIX, `No se pudo cargar fundingRate para ${symbol}:`, error);
        }
      }));
      const values = Object.values(results).filter((value) => Number.isFinite(value));
      const marketFundingAnnual = values.length
        ? values.reduce((acc, value) => acc + value, 0) / values.length
        : 0;
      return { perSymbol: results, marketFundingAnnual };
    };

    const computeSigmaForAsset = async (asset) => {
      const symbol = `${asset}USDT`;
      try {
        const data = await jget(`https://api.binance.com/api/v3/klines?interval=1h&limit=25&symbol=${encodeURIComponent(symbol)}`);
        if (!Array.isArray(data) || data.length < 2) throw new Error('Datos insuficientes');
        const closes = data
          .map((entry) => Array.isArray(entry) ? toNumber(entry[4]) : NaN)
          .filter((value) => Number.isFinite(value));
        if (closes.length < 2) throw new Error('Cierres insuficientes');
        const returns = [];
        for (let i = 1; i < closes.length; i += 1) {
          const prev = closes[i - 1];
          const current = closes[i];
          if (prev > 0 && current > 0) {
            returns.push((current - prev) / prev);
          }
        }
        if (!returns.length) throw new Error('Sin variaciones');
        const mean = returns.reduce((acc, value) => acc + value, 0) / returns.length;
        const variance = returns.reduce((acc, value) => acc + Math.pow(value - mean, 2), 0) / returns.length;
        const sigma = Math.sqrt(Math.max(variance, 0));
        return sigma;
      } catch (error) {
        console.warn(LOG_PREFIX, `Fallo sigma para ${asset}:`, error);
        return runtimeConfig.ltvModel.sigmaFallback;
      }
    };

    const ensureLtvOrdering = (init, mc, liq, liqCap, epsilon) => {
      let initial = init;
      let margin = mc;
      let liquidation = liq;
      if (!(margin > initial)) {
        margin = Math.min(liqCap, initial + epsilon);
      }
      if (!(liquidation > margin)) {
        liquidation = Math.min(liqCap, margin + epsilon);
      }
      return { initial, margin, liquidation };
    };

    const buildCollateralEntry = (asset, sigma) => {
      const model = runtimeConfig.ltvModel;
      const overrides = runtimeConfig.assetOverrides && runtimeConfig.assetOverrides[asset] ? runtimeConfig.assetOverrides[asset] : {};
      const safeSigma = Math.max(model.sigmaFloor, Number.isFinite(sigma) ? sigma : model.sigmaFallback);
      let init = clamp(model.initMax - model.sigmaK * safeSigma, [model.initMin, model.initMax]);
      if (typeof overrides.initialLtv === 'number') {
        init = clamp(overrides.initialLtv, [model.initMin, model.initMax]);
      }
      let mc = clamp(init + model.mcStep, [init, model.liqCap]);
      if (typeof overrides.marginCallLtv === 'number') {
        mc = clamp(overrides.marginCallLtv, [init, model.liqCap]);
      }
      let liq = clamp(mc + model.liqStep, [mc, model.liqCap]);
      if (typeof overrides.liquidationLtv === 'number') {
        liq = clamp(overrides.liquidationLtv, [mc, model.liqCap]);
      }
      if (typeof overrides.liqBias === 'number') {
        liq = clamp(liq * (1 + overrides.liqBias), [mc, model.liqCap]);
      }
      const ordered = ensureLtvOrdering(init, mc, liq, model.liqCap, model.epsilon);
      return {
        asset,
        sigma: safeSigma,
        initialLtv: ordered.initial,
        marginCallLtv: ordered.margin,
        liquidationLtv: ordered.liquidation,
      };
    };

    const deriveLoanUniverse = (autoUniverse, skip) => {
      const result = { values: [], set: new Set() };
      autoUniverse.forEach((asset) => {
        const upper = (asset || '').toUpperCase();
        if (!upper || skip.has(upper)) return;
        uniqPush(result, upper);
      });
      const fallback = Array.isArray(runtimeConfig.universe && runtimeConfig.universe.fallback)
        ? runtimeConfig.universe.fallback
        : [];
      fallback.forEach((asset) => {
        const upper = (asset || '').toUpperCase();
        if (!upper || skip.has(upper)) return;
        if (result.values.length >= runtimeConfig.universe.maxAssets) return;
        uniqPush(result, upper);
      });
      return result.values.slice(0, runtimeConfig.universe.maxAssets);
    };

    const computeSnapshot = async () => {
      const skipSet = buildSkipSet();
      const autoUniverse = await loadUniverseAuto(runtimeConfig.universe.maxAssets, skipSet);
      const collateralUniverse = deriveLoanUniverse(autoUniverse, skipSet);
      const funding = await computeFundingAnnualized();
      const sigmaEntries = await Promise.all(collateralUniverse.map(async (asset) => [asset, await computeSigmaForAsset(asset)]));
      const sigmaByAsset = sigmaEntries.reduce((acc, [asset, sigma]) => {
        acc[asset] = sigma;
        return acc;
      }, {});
      const collateralEntries = collateralUniverse.map((asset) => buildCollateralEntry(asset, sigmaByAsset[asset]));
      const ltvByTicker = collateralEntries.reduce((acc, entry) => {
        acc[entry.asset] = entry.initialLtv;
        return acc;
      }, {});
      const collateralLedger = collateralEntries.reduce((acc, entry) => {
        acc[entry.asset] = {
          initialLtv: entry.initialLtv,
          marginCallLtv: entry.marginCallLtv,
          liquidationLtv: entry.liquidationLtv,
        };
        return acc;
      }, {});

      const loanCoins = Array.isArray(runtimeConfig.loanCoins) && runtimeConfig.loanCoins.length
        ? runtimeConfig.loanCoins
        : Object.keys(runtimeConfig.baseAPR || {});
      const borrowRates = {};
      const loanLedger = {};
      const vipLevel = runtimeConfig.vip && typeof runtimeConfig.vip.level === 'number' ? runtimeConfig.vip.level : 0;
      const discountTable = (runtimeConfig.vip && runtimeConfig.vip.discounts) || {};
      const vipDiscount = typeof discountTable[vipLevel] === 'number'
        ? discountTable[vipLevel]
        : runtimeConfig.vip && typeof runtimeConfig.vip.fallbackDiscount === 'number'
          ? runtimeConfig.vip.fallbackDiscount
          : 0;
      const aprClampBounds = runtimeConfig.loanAprClamp || { min: 0, max: 1 };

      loanCoins.forEach((coin) => {
        const upper = (coin || '').toUpperCase();
        const baseApr = toNumber(runtimeConfig.baseAPR && runtimeConfig.baseAPR[upper], 0.04);
        const annualRaw = clamp(baseApr + runtimeConfig.aprFundingAlpha * funding.marketFundingAnnual, [aprClampBounds.min, aprClampBounds.max]);
        const vipAnnual = clamp(annualRaw - vipDiscount, [aprClampBounds.min, aprClampBounds.max]);
        const hourly = annualRaw / (365 * 24);
        borrowRates[upper] = {
          annual: annualRaw,
          hourly,
          vipAnnual,
          netAnnual: vipAnnual,
          loanAsset: upper,
          label: `${upper} · Simulado`,
          source: 'dynamic_model',
        };
        loanLedger[upper] = {
          referenceYearlyRate: annualRaw,
          referenceDailyRate: annualRaw / 365,
        };
      });

      const fetchedAt = new Date().toISOString();
      const snapshot = {
        source: 'dynamic_model',
        fetchedAt,
        serverTime: Date.now(),
        config: {
          ltvByTicker,
          borrowRates,
          loanLedger,
          collateralLedger,
        },
        metadata: {
          model: 'dynamic_model',
          computedAt: fetchedAt,
          refreshMs: runtimeConfig.refreshMs,
          aprFundingAlpha: runtimeConfig.aprFundingAlpha,
          funding,
          sigmaByAsset,
          collateralYield: runtimeConfig.collateralYield,
          vipLevel,
          aprClamp: runtimeConfig.netApr && runtimeConfig.netApr.aprClamp ? runtimeConfig.netApr.aprClamp : null,
          autoUniverse,
          collateralUniverse,
        },
        rowCount: {
          loanable: Object.keys(borrowRates).length,
          collateral: collateralEntries.length,
        },
      };

      state.snapshot = snapshot;
      state.lastTs = Date.now();

      window[NAMESPACE] = window[NAMESPACE] && typeof window[NAMESPACE] === 'object' ? window[NAMESPACE] : {};
      window[NAMESPACE].snapshot = snapshot;
      window[NAMESPACE].config = runtimeConfig;

      console.info(LOG_PREFIX, 'Snapshot dynamic_model actualizado.', {
        loanable: snapshot.rowCount.loanable,
        collateral: snapshot.rowCount.collateral,
      });

      return snapshot;
    };

    const ensureSnapshot = async (force) => {
      const now = Date.now();
      if (!force && state.snapshot && state.lastTs && (now - state.lastTs) < runtimeConfig.refreshMs) {
        return state.snapshot;
      }
      if (state.inflight) {
        return state.inflight;
      }
      state.inflight = computeSnapshot().catch((error) => {
        console.warn(LOG_PREFIX, 'No se pudo actualizar snapshot:', error);
        state.inflight = null;
        if (state.snapshot) return state.snapshot;
        throw error;
      }).then((snapshot) => {
        state.inflight = null;
        return snapshot;
      });
      return state.inflight;
    };

    const respondLoans = async () => {
      const snapshot = await ensureSnapshot();
      const ageMs = state.lastTs ? Math.max(0, Date.now() - state.lastTs) : null;
      return createJsonResponse({
        ...snapshot,
        ageMs,
        cached: true,
        stale: false,
      });
    };

    const respondAdminState = () => {
      const hasCache = !!state.snapshot;
      const cacheTs = state.lastTs || null;
      const ageMs = cacheTs ? Math.max(0, Date.now() - cacheTs) : null;
      return createJsonResponse({
        hasCache,
        cacheTs,
        ageMs,
        cacheSource: 'dynamic',
      });
    };

    const respondLoanable = async (url) => {
      const snapshot = await ensureSnapshot();
      const query = url.searchParams.get('loanCoin');
      const rows = Object.entries(snapshot.config.borrowRates).map(([loanCoin, info]) => ({
        loanCoin,
        yearlyInterestRate: info.annual,
        hourlyInterestRate: info.hourly,
        vipYearlyInterestRate: info.vipAnnual,
      })).filter((row) => !query || row.loanCoin === query.toUpperCase());
      return createJsonResponse({
        total: rows.length,
        rows,
        source: 'dynamic_model',
      });
    };

    const respondCollateral = async (url) => {
      const snapshot = await ensureSnapshot();
      const query = url.searchParams.get('collateralCoin');
      const rows = Object.entries(snapshot.config.collateralLedger).map(([collateralCoin, info]) => ({
        collateralCoin,
        initialLTV: info.initialLtv,
        marginCallLTV: info.marginCallLtv,
        liquidationLTV: info.liquidationLtv,
      })).filter((row) => !query || row.collateralCoin === query.toUpperCase());
      return createJsonResponse({
        total: rows.length,
        rows,
        source: 'dynamic_model',
      });
    };

    const computePairNetAPR = ({ loanCoin, collateralCoin, ltvCurrent }) => {
      const snapshot = state.snapshot;
      if (!snapshot) {
        console.warn(LOG_PREFIX, 'Snapshot no disponible para computePairNetAPR.');
        return null;
      }
      const netConfig = runtimeConfig.netApr || {};
      const loanKey = (loanCoin || '').toUpperCase();
      const collateralKey = (collateralCoin || '').toUpperCase();
      const loanInfo = snapshot.config && snapshot.config.borrowRates ? snapshot.config.borrowRates[loanKey] : null;
      if (!loanInfo) return null;
      const collateralYieldEntry = runtimeConfig.collateralYield && runtimeConfig.collateralYield[collateralKey];
      const collateralAPR = collateralYieldEntry && typeof collateralYieldEntry.apr === 'number' ? collateralYieldEntry.apr : 0;
      const initialLtv = snapshot.config && snapshot.config.collateralLedger && snapshot.config.collateralLedger[collateralKey]
        ? snapshot.config.collateralLedger[collateralKey].initialLtv
        : null;
      const loanAPR = netConfig.useVip ? toNumber(loanInfo.vipAnnual, loanInfo.annual) : toNumber(loanInfo.annual);
      const divisorMode = (netConfig.ltvDivisor || 'current').toLowerCase();
      const divisor = divisorMode === 'current' ? toNumber(ltvCurrent, initialLtv || 0) : toNumber(initialLtv, ltvCurrent || 0);
      const clampConfig = netConfig.aprClamp || {};
      const applyClamp = (value) => {
        let next = value;
        if (typeof clampConfig.min === 'number') next = Math.max(clampConfig.min, next);
        if (typeof clampConfig.max === 'number') next = Math.min(clampConfig.max, next);
        if (netConfig.nonNegative) next = Math.max(0, next);
        return next;
      };
      if (!(collateralAPR > 0) || !(divisor > 0)) {
        return applyClamp(loanAPR);
      }
      const net = loanAPR - (collateralAPR / divisor);
      return applyClamp(net);
    };

    const getDynamicStatus = () => {
      const snapshot = state.snapshot || null;
      const cacheTs = state.lastTs || null;
      const ageMs = cacheTs ? Math.max(0, Date.now() - cacheTs) : null;
      return {
        hasCache: !!snapshot,
        cacheTs,
        ageMs,
        snapshot,
        source: snapshot?.source || 'dynamic_model',
        metadata: snapshot?.metadata || null,
      };
    };

    window[NAMESPACE] = window[NAMESPACE] && typeof window[NAMESPACE] === 'object' ? window[NAMESPACE] : {};
    window[NAMESPACE].config = runtimeConfig;
    window[NAMESPACE].computePairNetAPR = computePairNetAPR;
    window[NAMESPACE].getStatus = getDynamicStatus;
    window[NAMESPACE].remotePresetDisabled = true;

    ensureSnapshot().catch((error) => {
      console.warn(LOG_PREFIX, 'Error inicial al preparar snapshot dinámico:', error);
    });

    window.fetch = async function dynamicModelFetch(input, init) {
      try {
        const requestInit = init || {};
        const method = ((requestInit.method) || (typeof input === 'object' && input && input.method) || 'GET').toUpperCase();
        if (method !== 'GET') {
          return upstreamFetch(input, init);
        }
        const url = (() => {
          try {
            if (typeof input === 'string') return new URL(input, window.location.href);
            if (input && typeof input.url === 'string') return new URL(input.url, window.location.href);
          } catch (error) {
            console.warn(LOG_PREFIX, 'No se pudo parsear URL para fetch interceptado.', error);
          }
          return null;
        })();
        if (!url || url.origin !== window.location.origin) {
          return upstreamFetch(input, init);
        }
        const pathname = url.pathname.replace(/\/+$/, '') || url.pathname;
        if (pathname === '/api/binance/loans' || pathname === '/api/binance/snapshot') {
          return respondLoans();
        }
        if (pathname === '/api/admin/state') {
          return respondAdminState();
        }
        if (pathname === '/api/binance/loanable') {
          return respondLoanable(url);
        }
        if (pathname === '/api/binance/collateral') {
          return respondCollateral(url);
        }
      } catch (error) {
        console.warn(LOG_PREFIX, 'Error en interceptación de fetch:', error);
      }
      return upstreamFetch(input, init);
    };
  })();
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script type="application/json" id="sim-model-config">
  {
    "forceOn": true,
    "refreshMs": 60000,
    "timeoutMs": 8000,

    "loanCoins": ["USDT","USDC","FDUSD","DAI","BUSD","TUSD","USDP"],

    "collateralUniverseMode": "auto",
    "universeMaxAssets": 180,
    "skipAssets": ["USD","USDT","USDC","FDUSD","BUSD","DAI","TUSD","USDP","USDD"],

    "baseAPR": { "USDT":0.08, "USDC":0.075, "FDUSD":0.09, "DAI":0.07, "BUSD":0.08, "TUSD":0.08, "USDP":0.075 },
    "aprClamp": { "min": 0.02, "max": 0.30 },
    "aprFundingAlpha": 0.55,
    "fundingSymbols": ["BTCUSDT","ETHUSDT","BNBUSDT"],

    "vip": { "level": 0, "discountBpsByLevel": { "0":0, "1":20, "2":40, "3":60, "4":80, "5":100, "6":110, "7":115, "8":120, "9":125 } },

    "ltv": { "initClamp": { "min": 0.50, "max": 0.80 }, "mcStep": 0.07, "liqStep": 0.06, "liqCap": 0.93, "sigmaWindowH": 24, "sigmaK": 2.0 },

    "netApr": { "ltvDivisor": "current", "nonNegative": true, "useVip": false },

    "collateralYield": {
      "ADA":  { "apr": 0.00038, "source": "manual" },
      "ALGO": { "apr": 0.00047, "source": "manual" },
      "WBETH":{ "apr": 0.032, "source": "manual" }
    },

    "assetOverrides": {
      "ADA":  { "initialLtv": 0.4756, "marginCallLtv": 0.8, "liquidationLtv": 0.85 },
      "ALGO": { "initialLtv": 0.1024, "marginCallLtv": 0.8, "liquidationLtv": 0.85 }
    }
  }
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    body{
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--theme-surface-soft, linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%));
      transition:background .3s ease;
    }
    /* Paleta y estilos base */
    .nx-gradient{background:linear-gradient(135deg,#0b1e4b 0%,#1b44a6 50%,#2052c1 100%)}
    .bn-gradient{background:linear-gradient(135deg,#1f2937 0%,#f59e0b 45%,#f97316 100%)}
    .yh-gradient{background:linear-gradient(135deg,#0ea5e9 0%,#2563eb 55%,#38bdf8 100%)}
    .ld-gradient{background:linear-gradient(135deg,#0f766e 0%,#14b8a6 55%,#2dd4bf 100%)}
    .nx-card{
      position:relative;
      border:1px solid var(--theme-card-border);
      box-shadow:var(--theme-card-shadow);
      border-radius:1.5rem;
      background:var(--theme-card-bg);
      transition:box-shadow .3s ease,border-color .3s ease,background .3s ease;
      backdrop-filter:blur(10px);
    }
    .nx-card::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:var(--theme-card-overlay,linear-gradient(180deg,rgba(255,255,255,0.55) 0%,rgba(255,255,255,0.12) 100%));
      pointer-events:none;
    }
    .nx-card > *{
      position:relative;
      z-index:1;
    }
    .nx-card-secondary{
      position:relative;
      border-radius:1.5rem;
      border:1px solid var(--theme-card-border-secondary,var(--theme-card-border));
      background:var(--theme-card-bg-secondary,var(--theme-card-bg));
      box-shadow:var(--theme-card-shadow-secondary,var(--theme-card-shadow));
      backdrop-filter:blur(8px);
      transition:box-shadow .3s ease,border-color .3s ease,background .3s ease;
    }
    .nx-card-secondary::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:var(--theme-card-overlay,linear-gradient(180deg,rgba(255,255,255,0.45) 0%,rgba(255,255,255,0.08) 100%));
      pointer-events:none;
    }
    .nx-card-secondary > *{
      position:relative;
      z-index:1;
    }
    .nx-card-tertiary{
      position:relative;
      border-radius:1.1rem;
      border:1px solid var(--theme-card-border-secondary,var(--theme-card-border));
      background:var(--theme-card-bg-tertiary,var(--theme-card-bg-secondary,var(--theme-card-bg)));
      box-shadow:var(--theme-card-shadow-tertiary,var(--theme-card-shadow-secondary,var(--theme-card-shadow)));
      backdrop-filter:blur(6px);
      transition:box-shadow .3s ease,border-color .3s ease,background .3s ease;
    }
    .nx-card-tertiary::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:var(--theme-card-overlay,linear-gradient(180deg,rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.08) 100%));
      pointer-events:none;
    }
    .nx-card-tertiary > *{
      position:relative;
      z-index:1;
    }
    .nx-kpi{border:1px solid var(--theme-kpi-border); transition:border-color .3s ease;}
    .nx-kpi-btn{
      position:relative;
      border-radius:1.25rem;
      background:var(--theme-kpi-bg);
      color:#fff;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-shadow);
      transition:transform .25s ease, box-shadow .25s ease, filter .25s ease;
    }
    .nx-kpi-btn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 -18px 30px rgba(0,0,0,0.18);
      pointer-events:none;
    }
    .nx-kpi-btn:hover{
      transform:translateY(-3px);
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-hover-shadow);
    }
    .nx-kpi-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-kpi-active-shadow);
    }
    .nx-btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:.4rem;
      background:var(--theme-btn-bg);
      color:var(--theme-btn-text);
      border-radius:1rem;
      padding:.55rem 1.35rem;
      font-weight:600;
      border:1px solid var(--theme-btn-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn:hover{
      transform:translateY(-2px);
      filter:brightness(1.03);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-hover-shadow);
    }
    .nx-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),var(--theme-btn-active-shadow);
    }
    .nx-btn-ghost{
      background:var(--theme-ghost-bg);
      color:var(--theme-ghost-text);
      border:1px solid var(--theme-ghost-border);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-shadow);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn-ghost:hover{
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),var(--theme-ghost-hover-shadow);
    }
    .nx-btn-ghost:active{
      transform:translateY(1px);
    }
    .nx-btn-sm{padding:.35rem .95rem; font-size:.8rem; border-radius:.9rem;}
    .nx-tab{
      border-radius:1.25rem;
      background:var(--theme-tab-bg,linear-gradient(150deg,rgba(255,255,255,0.94) 0%,rgba(219,232,255,0.9) 100%));
      border:1px solid var(--theme-tab-border,rgba(51,104,240,0.18));
      box-shadow:var(--theme-tab-shadow,0 8px 18px rgba(32,82,193,0.1));
      transition:transform .22s ease,box-shadow .22s ease,border-color .22s ease;
    }
    .nx-tab:hover{
      transform:translateY(-2px);
      box-shadow:var(--theme-tab-hover-shadow,0 12px 24px rgba(32,82,193,0.16));
      border-color:var(--theme-tab-border-hover,var(--theme-tab-border,rgba(51,104,240,0.18)));
    }
    .nx-tab:active{
      transform:translateY(1px);
      box-shadow:var(--theme-tab-active-shadow,0 6px 12px rgba(32,82,193,0.14));
    }
  </style>
</head>
<body data-theme="nexo">
  <div id="root"></div>

  <!-- React 18 UMD fijas -->
  <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

  <!-- (si usás JSX en el navegador) Babel Standalone fijo -->
  <script src="https://unpkg.com/@babel/standalone@7.23.9/babel.min.js"></script>

  <script type="text/babel" data-presets="env,react">
    // Simulador de Préstamos – HTML portable (sin build, con CDN)
    const DEFAULT_EXCHANGE_RATES = {
      USD: 1,
      USDT: 1,
      ARS: 1000,
      EUR: 0.92,
      GBP: 0.79,
      CAD: 1.36,
      AUD: 1.53,
      CHF: 0.89,
      JPY: 157,
      BRL: 5.0,
      MXN: 17.2,
    };

    const DEFAULT_SIMULATION_CONTROLS = Object.freeze({
      aprFundingAlpha: 1,
      aprClamp: null,
      sigmaK: 1,
      ltv: { initClamp: null },
    });

    const THEME_TOKENS = Object.freeze({
      nexo: {
        '--theme-surface-soft': 'linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%)',
        '--theme-card-border': '#dfe6ff',
        '--theme-card-shadow': '0 12px 30px rgba(16,35,90,.08)',
        '--theme-card-bg': 'linear-gradient(160deg, rgba(244,248,255,0.96) 0%, rgba(225,236,255,0.92) 100%)',
        '--theme-card-border-secondary': 'rgba(99,132,241,0.45)',
        '--theme-card-bg-secondary': 'linear-gradient(160deg, rgba(236,244,255,0.92) 0%, rgba(210,226,255,0.88) 100%)',
        '--theme-card-shadow-secondary': '0 16px 32px rgba(32,82,193,0.18)',
        '--theme-kpi-border': '#e6eaf5',
        '--theme-kpi-bg': 'linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(8,20,66,0.35)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(12,28,84,0.42)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(10,24,70,0.3)',
        '--theme-btn-bg': 'linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%)',
        '--theme-btn-text': '#fff',
        '--theme-btn-border': 'rgba(255,255,255,0.22)',
        '--theme-btn-shadow': '0 14px 28px rgba(15,33,90,0.32)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(12,30,88,0.4)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(10,26,70,0.25)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%)',
        '--theme-ghost-text': '#1e2f67',
        '--theme-ghost-border': 'rgba(30,64,175,0.16)',
        '--theme-ghost-shadow': '0 10px 22px rgba(15,30,70,0.12)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(15,30,70,0.18)',
        '--theme-tab-bg': 'linear-gradient(150deg,#f2f6ff 0%,#dce7ff 100%)',
        '--theme-tab-border': 'rgba(67,104,214,0.28)',
        '--theme-tab-border-hover': 'rgba(51,94,201,0.42)',
        '--theme-tab-shadow': '0 10px 20px rgba(32,82,193,0.12)',
        '--theme-tab-hover-shadow': '0 16px 30px rgba(32,82,193,0.16)',
        '--theme-tab-active-shadow': '0 6px 14px rgba(32,82,193,0.14)',
      },
      binance: {
        '--theme-surface-soft': 'linear-gradient(180deg,#fff6e6 0%,#ffedcc 100%)',
        '--theme-card-border': 'rgba(251,191,36,0.35)',
        '--theme-card-shadow': '0 12px 30px rgba(146,64,14,0.15)',
        '--theme-card-bg': 'linear-gradient(160deg, rgba(255,247,230,0.95) 0%, rgba(255,233,194,0.9) 100%)',
        '--theme-card-border-secondary': 'rgba(234,179,8,0.5)',
        '--theme-card-bg-secondary': 'linear-gradient(160deg, rgba(255,241,207,0.92) 0%, rgba(255,226,176,0.88) 100%)',
        '--theme-card-shadow-secondary': '0 16px 32px rgba(146,64,14,0.18)',
        '--theme-kpi-border': 'rgba(253,224,71,0.45)',
        '--theme-kpi-bg': 'linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(146,64,14,0.32)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(124,45,18,0.42)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(124,45,18,0.3)',
        '--theme-btn-bg': 'linear-gradient(155deg,#d97706 0%,#f59e0b 45%,#fbbf24 100%)',
        '--theme-btn-text': '#fff7db',
        '--theme-btn-border': 'rgba(255,255,255,0.24)',
        '--theme-btn-shadow': '0 14px 28px rgba(146,64,14,0.28)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(124,45,18,0.35)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(124,45,18,0.25)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#fff7e6 100%)',
        '--theme-ghost-text': '#7c2d12',
        '--theme-ghost-border': 'rgba(217,119,6,0.3)',
        '--theme-ghost-shadow': '0 10px 22px rgba(146,64,14,0.16)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(124,45,18,0.22)',
        '--theme-tab-bg': 'linear-gradient(150deg,#fff9eb 0%,#ffe3b8 100%)',
        '--theme-tab-border': 'rgba(217,119,6,0.35)',
        '--theme-tab-border-hover': 'rgba(194,92,6,0.45)',
        '--theme-tab-shadow': '0 10px 20px rgba(217,119,6,0.14)',
        '--theme-tab-hover-shadow': '0 16px 30px rgba(217,119,6,0.20)',
        '--theme-tab-active-shadow': '0 6px 14px rgba(217,119,6,0.15)',
      },
      youhodler: {
        '--theme-surface-soft': 'linear-gradient(180deg,#e0f2ff 0%,#f5fbff 100%)',
        '--theme-card-border': 'rgba(59,130,246,0.25)',
        '--theme-card-shadow': '0 12px 30px rgba(30,64,175,0.12)',
        '--theme-card-bg': 'linear-gradient(160deg, rgba(224,242,255,0.94) 0%, rgba(210,233,255,0.9) 100%)',
        '--theme-card-border-secondary': 'rgba(59,130,246,0.38)',
        '--theme-card-bg-secondary': 'linear-gradient(160deg, rgba(213,236,255,0.9) 0%, rgba(193,226,255,0.86) 100%)',
        '--theme-card-shadow-secondary': '0 16px 32px rgba(37,99,235,0.16)',
        '--theme-kpi-border': 'rgba(125,211,252,0.6)',
        '--theme-kpi-bg': 'linear-gradient(155deg,#0ea5e9 0%,#2563eb 45%,#3b82f6 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(14,165,233,0.28)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(14,116,233,0.34)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(14,116,233,0.24)',
        '--theme-btn-bg': 'linear-gradient(155deg,#0284c7 0%,#2563eb 50%,#38bdf8 100%)',
        '--theme-btn-text': '#f0f9ff',
        '--theme-btn-border': 'rgba(255,255,255,0.3)',
        '--theme-btn-shadow': '0 14px 28px rgba(14,116,233,0.28)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(14,116,233,0.35)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(14,116,233,0.25)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#e0f2ff 100%)',
        '--theme-ghost-text': '#0f172a',
        '--theme-ghost-border': 'rgba(59,130,246,0.22)',
        '--theme-ghost-shadow': '0 10px 22px rgba(37,99,235,0.12)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(37,99,235,0.18)',
        '--theme-tab-bg': 'linear-gradient(150deg,#f3f9ff 0%,#d8ecff 100%)',
        '--theme-tab-border': 'rgba(37,99,235,0.24)',
        '--theme-tab-border-hover': 'rgba(30,80,210,0.35)',
        '--theme-tab-shadow': '0 10px 20px rgba(37,99,235,0.14)',
        '--theme-tab-hover-shadow': '0 16px 30px rgba(37,99,235,0.18)',
        '--theme-tab-active-shadow': '0 6px 14px rgba(37,99,235,0.14)',
      },
      ledn: {
        '--theme-surface-soft': 'linear-gradient(180deg,#f3f4f6 0%,#ffffff 100%)',
        '--theme-card-border': 'rgba(15,118,110,0.22)',
        '--theme-card-shadow': '0 12px 30px rgba(15,118,110,0.12)',
        '--theme-card-bg': 'linear-gradient(160deg, rgba(230,252,247,0.94) 0%, rgba(210,245,236,0.9) 100%)',
        '--theme-card-border-secondary': 'rgba(20,184,166,0.38)',
        '--theme-card-bg-secondary': 'linear-gradient(160deg, rgba(214,245,236,0.9) 0%, rgba(193,237,225,0.86) 100%)',
        '--theme-card-shadow-secondary': '0 16px 32px rgba(13,148,136,0.18)',
        '--theme-kpi-border': 'rgba(45,212,191,0.45)',
        '--theme-kpi-bg': 'linear-gradient(155deg,#0f766e 0%,#14b8a6 45%,#2dd4bf 100%)',
        '--theme-kpi-shadow': '0 16px 30px rgba(15,118,110,0.26)',
        '--theme-kpi-hover-shadow': '0 22px 36px rgba(13,148,136,0.32)',
        '--theme-kpi-active-shadow': '0 10px 18px rgba(15,118,110,0.22)',
        '--theme-btn-bg': 'linear-gradient(155deg,#0f766e 0%,#14b8a6 50%,#2dd4bf 100%)',
        '--theme-btn-text': '#ecfeff',
        '--theme-btn-border': 'rgba(255,255,255,0.28)',
        '--theme-btn-shadow': '0 14px 28px rgba(13,148,136,0.25)',
        '--theme-btn-hover-shadow': '0 20px 34px rgba(13,148,136,0.32)',
        '--theme-btn-active-shadow': '0 10px 20px rgba(13,148,136,0.24)',
        '--theme-ghost-bg': 'linear-gradient(150deg,#ffffff 0%,#ecfdf5 100%)',
        '--theme-ghost-text': '#0f172a',
        '--theme-ghost-border': 'rgba(45,212,191,0.22)',
        '--theme-ghost-shadow': '0 10px 22px rgba(15,118,110,0.12)',
        '--theme-ghost-hover-shadow': '0 16px 26px rgba(15,118,110,0.18)',
        '--theme-tab-bg': 'linear-gradient(150deg,#f2fdf9 0%,#d9f3ee 100%)',
        '--theme-tab-border': 'rgba(20,184,166,0.26)',
        '--theme-tab-border-hover': 'rgba(15,158,143,0.36)',
        '--theme-tab-shadow': '0 10px 20px rgba(14,148,136,0.14)',
        '--theme-tab-hover-shadow': '0 16px 30px rgba(14,148,136,0.18)',
        '--theme-tab-active-shadow': '0 6px 14px rgba(14,148,136,0.14)',
      },
    });

    const DEFAULT_THEME = 'nexo';

    const SIM_MODEL_CONFIG_DOM_ID = 'sim-model-config';
    const createDefaultSimModelConfig = () => ({
      version: 1,
      updatedAt: null,
      liquidationBias: {},
    });

    const clampValue = (value, min, max) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return 0;
      if (num < min) return min;
      if (num > max) return max;
      return num;
    };

    const readSimModelConfigFromDom = () => {
      const base = createDefaultSimModelConfig();
      if (typeof document === 'undefined') return base;
      const el = document.getElementById(SIM_MODEL_CONFIG_DOM_ID);
      if (!el) return base;
      const text = (el.textContent || el.innerText || '').trim();
      if (!text) return base;
      try {
        const parsed = JSON.parse(text);
        const bias = parsed && typeof parsed === 'object' && parsed.liquidationBias && typeof parsed.liquidationBias === 'object'
          ? parsed.liquidationBias
          : {};
        return {
          ...base,
          ...parsed,
          liquidationBias: { ...bias },
        };
      } catch (err) {
        console.warn('[sim-model-config] JSON inválido, usando default', err);
        return base;
      }
    };

    const ensureSimModelConfigElement = () => {
      if (typeof document === 'undefined') return null;
      let el = document.getElementById(SIM_MODEL_CONFIG_DOM_ID);
      if (!el) {
        el = document.createElement('script');
        el.type = 'application/json';
        el.id = SIM_MODEL_CONFIG_DOM_ID;
        el.textContent = JSON.stringify(createDefaultSimModelConfig(), null, 2);
        (document.body || document.head || document.documentElement).appendChild(el);
      }
      return el;
    };

    const writeSimModelConfigToDom = (config) => {
      if (typeof document === 'undefined') return;
      const el = ensureSimModelConfigElement();
      if (!el) return;
      try {
        el.textContent = JSON.stringify(config, null, 2);
      } catch (err) {
        console.warn('[sim-model-config] no se pudo escribir en el DOM', err);
      }
    };

    const ACCENT_SURFACES = Object.freeze({
      vivid: 'radial-gradient(130% 130% at 14% 0%, rgba(79,70,229,0.24) 0%, rgba(59,130,246,0.18) 42%, rgba(14,165,233,0.14) 100%)',
      soft: 'linear-gradient(140deg, rgba(226,232,255,0.94) 0%, rgba(191,219,254,0.9) 52%, rgba(219,234,254,0.86) 100%)',
      halo: 'radial-gradient(120% 120% at 50% 35%, rgba(59,130,246,0.22) 0%, rgba(191,219,254,0.18) 45%, rgba(248,250,252,0.92) 100%)',
    });

    const ensureThemeStyles = () => {
      if (typeof document === 'undefined') return;
      if (document.getElementById('simulator-theme-styles')) return;

      const makeRule = (selector, tokens) => {
        const body = Object.entries(tokens)
          .map(([name, value]) => `  ${name}: ${value};`)
          .join('\n');
        return `${selector} {\n${body}\n}`;
      };

      const styleTag = document.createElement('style');
      styleTag.id = 'simulator-theme-styles';

      const defaultTokens = THEME_TOKENS[DEFAULT_THEME] || {};
      const themeRules = Object.entries(THEME_TOKENS)
        .map(([themeKey, tokens]) => makeRule(`html[data-theme="${themeKey}"], body[data-theme="${themeKey}"]`, tokens))
        .join('\n\n');

      styleTag.textContent = [makeRule(':root', defaultTokens), themeRules]
        .filter(Boolean)
        .join('\n\n');
      document.head.appendChild(styleTag);
    };

    const applyTheme = (themeName = DEFAULT_THEME) => {
      if (typeof document === 'undefined') return DEFAULT_THEME;
      ensureThemeStyles();
      const resolved = THEME_TOKENS[themeName] ? themeName : DEFAULT_THEME;
      document.body.setAttribute('data-theme', resolved);
      document.documentElement.setAttribute('data-theme', resolved);
      return resolved;
    };

    ensureThemeStyles();
    applyTheme(DEFAULT_THEME);

    const SUPPORTED_CURRENCIES = [
      { code: "USD", label: "USD — Dólar estadounidense" },
      { code: "USDT", label: "USDT — Tether" },
      { code: "ARS", label: "ARS — Peso argentino" },
      { code: "EUR", label: "EUR — Euro" },
      { code: "GBP", label: "GBP — Libra esterlina" },
      { code: "CAD", label: "CAD — Dólar canadiense" },
      { code: "AUD", label: "AUD — Dólar australiano" },
      { code: "CHF", label: "CHF — Franco suizo" },
      { code: "JPY", label: "JPY — Yen japonés" },
      { code: "BRL", label: "BRL — Real brasileño" },
      { code: "MXN", label: "MXN — Peso mexicano" },
    ];
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    const ALERT_TONE_STYLES = Object.freeze({
      info: { border: 'border-sky-200', bg: 'bg-sky-50', text: 'text-sky-700' },
      warn: { border: 'border-amber-200', bg: 'bg-amber-50', text: 'text-amber-700' },
      danger: { border: 'border-rose-200', bg: 'bg-rose-50', text: 'text-rose-700' },
    });

    const normalizeAlertItems = (alerts) => {
      if (!Array.isArray(alerts)) return [];
      return alerts
        .map((item, idx) => {
          if (!item) return null;
          if (typeof item === 'string') {
            return { id: `alert-${idx}`, tone: 'info', message: item };
          }
          if (typeof item === 'object') {
            const rawMessage = item.message;
            const message = typeof rawMessage === 'string'
              ? rawMessage
              : rawMessage != null
                ? String(rawMessage)
                : '';
            if (!message) return null;
            return {
              id: item.id || `alert-${idx}`,
              tone: item.tone || 'info',
              message,
            };
          }
          return null;
        })
        .filter(Boolean);
    };

    const LIVE_REFRESH_SECONDS = 5;
    const FX_REFRESH_MINUTES = 30;
    const BINANCE_INTEREST_REFRESH_MS = 60 * 1000;
    const BINANCE_API_BASE = 'https://api.binance.com';
    const BINANCE_FAPI_BASE = 'https://fapi.binance.com';
    const BINANCE_SIGNED_RECV_WINDOW = 5000;
    const BINANCE_SYNC_TIMEOUT_MS = 15000;
    const readDynamicModelStatus = () => {
      if (typeof window === 'undefined') {
        return { hasCache: false, ageMs: null, cacheTs: null, source: 'dynamic_model', snapshot: null };
      }
      try {
        const namespace = window.__nexoSim || {};
        if (typeof namespace.getStatus === 'function') {
          return namespace.getStatus() || { hasCache: false, ageMs: null, cacheTs: null, source: 'dynamic_model', snapshot: null };
        }
        const snapshot = namespace.snapshot || null;
        const cacheTs = snapshot?.serverTime || null;
        const ageMs = cacheTs ? Math.max(0, Date.now() - cacheTs) : null;
        return {
          hasCache: !!snapshot,
          ageMs,
          cacheTs,
          snapshot,
          source: snapshot?.source || 'dynamic_model',
          metadata: snapshot?.metadata || null,
        };
      } catch (error) {
        console.warn('No se pudo leer el estado del modelo dinámico:', error);
        return { hasCache: false, ageMs: null, cacheTs: null, source: 'dynamic_model', snapshot: null };
      }
    };
    const adaptDynamicStatusToMeta = (status) => ({
      status: 'dynamic',
      dynamicStatus: status,
      lastUpdated: status?.snapshot?.fetchedAt || status?.cacheTs || null,
      metadata: status?.metadata || null,
      source: status?.source || 'dynamic_model',
      error: null,
    });
    let didWarnPairApr = false;
    const computeNetAprForPair = (loanCoin, collateralCoin, ltvCurrent) => {
      const loanKey = typeof loanCoin === 'string' ? loanCoin.trim().toUpperCase() : '';
      const collateralKey = typeof collateralCoin === 'string' ? collateralCoin.trim().toUpperCase() : '';
      const ltvValue = Number(ltvCurrent);
      if (!loanKey || !collateralKey || !Number.isFinite(ltvValue) || ltvValue <= 0) {
        return null;
      }
      const globalSim = (typeof window !== 'undefined' ? window.__nexoSim : (typeof globalThis !== 'undefined' ? globalThis.__nexoSim : null)) || null;
      const computeFn = globalSim && typeof globalSim.computePairNetAPR === 'function' ? globalSim.computePairNetAPR : null;
      if (!computeFn) return null;
      try {
        const result = computeFn({ loanCoin: loanKey, collateralCoin: collateralKey, ltvCurrent: ltvValue });
        const value = Number(result);
        return Number.isFinite(value) ? value : null;
      } catch (error) {
        if (!didWarnPairApr) {
          console.warn('No se pudo calcular computePairNetAPR:', error);
          didWarnPairApr = true;
        }
        return null;
      }
    };
    const fetchWithTimeout = async (url, options = {}, timeoutMs = BINANCE_SYNC_TIMEOUT_MS) => {
      const { signal, ...rest } = options || {};
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      if (signal) {
        if (signal.aborted) {
          controller.abort();
        } else {
          signal.addEventListener('abort', () => controller.abort(), { once: true });
        }
      }
      try {
        const response = await fetch(url, { ...rest, signal: controller.signal });
        return response;
      } catch (error) {
        if (error?.name === 'AbortError') {
          throw new Error('Tiempo de espera agotado al conectar con Binance.');
        }
        throw error;
      } finally {
        clearTimeout(timeoutId);
      }
    };

    const DEFAULT_LOCALE = 'es-AR';

    const normalizeTicker = (value) => (typeof value === 'string' ? value.trim().toUpperCase() : '');

    const MS_IN_HOUR = 60 * 60 * 1000;
    const HOURS_IN_YEAR = 365 * 24;
    const annualToHourly = (apr) => {
      const normalized = Number(apr);
      if (!Number.isFinite(normalized)) return 0;
      if (normalized <= -0.9999) return 0;
      if (normalized === 0) return 0;
      return Math.pow(1 + normalized, 1 / HOURS_IN_YEAR) - 1;
    };

    const coerceDateValue = (value) => {
      if (!value) return null;
      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value;
      }
      if (typeof value === 'number') {
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return null;
        const date = new Date(trimmed);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      return null;
    };
    
    function computeCashflowProjections(plan = {}, ctx = {}) {
      const payments = Array.isArray(plan?.payments) ? plan.payments : [];
      const earns = Array.isArray(plan?.earns) ? plan.earns : [];
      const manual = Array.isArray(plan?.manual) ? plan.manual : [];

      const loanAmount = Math.max(0, Number(ctx?.loanAmount) || 0);
      const baseCollateral = Math.max(0, Number(ctx?.totalCollateralValue) || 0);
      const controls = ctx && typeof ctx === 'object' && ctx.controls && typeof ctx.controls === 'object'
        ? ctx.controls
        : DEFAULT_SIMULATION_CONTROLS;

      const loanByTickerRaw = ctx?.loanByTicker || {};
      const loanByTicker = Object.entries(loanByTickerRaw).reduce((acc, [ticker, amount]) => {
        const key = normalizeTicker(ticker);
        const value = Math.max(0, Number(amount) || 0);
        if (!key || !(value > 0)) return acc;
        acc[key] = (acc[key] || 0) + value;
        return acc;
      }, {});
      const hasLoanByTicker = Object.keys(loanByTicker).length > 0;

      const sumMap = (map) => Object.values(map).reduce((acc, value) => {
        const num = Number(value);
        return acc + (Number.isFinite(num) && num > 0 ? num : 0);
      }, 0);

      const applyProportionalReduction = (map, amount) => {
        if (!(amount > 0)) return 0;
        const keys = Object.keys(map);
        if (!keys.length) return 0;
        const totalBefore = sumMap(map);
        if (!(totalBefore > 0)) return 0;
        let applied = 0;
        keys.forEach((key) => {
          const current = Math.max(0, Number(map[key]) || 0);
          if (!(current > 0)) return;
          const share = current / totalBefore;
          const delta = Math.min(current, amount * share);
          if (delta > 0) {
            map[key] = current - delta;
            applied += delta;
          }
        });
        return applied;
      };

      const applyProportionalReductionWithBreakdown = (map, amount) => {
        if (!(amount > 0)) return {};
        const snapshot = Object.keys(map).reduce((acc, key) => {
          acc[key] = Math.max(0, Number(map[key]) || 0);
          return acc;
        }, {});
        const applied = applyProportionalReduction(map, amount);
        if (!(applied > 0)) return {};
        return Object.keys(snapshot).reduce((acc, key) => {
          const before = snapshot[key];
          const after = Math.max(0, Number(map[key]) || 0);
          const delta = Math.max(0, before - after);
          if (delta > 0) acc[key] = delta;
          return acc;
        }, {});
      };

      const getPaymentAmount = (payment) => {
        const raw = payment?.amount ?? payment?.principal;
        const value = Number(raw);
        return Number.isFinite(value) && value > 0 ? value : 0;
      };

      const sumPositive = (items, prop) => items.reduce((acc, item) => {
        const raw = Number(item?.[prop]);
        return acc + (Number.isFinite(raw) && raw > 0 ? raw : 0);
      }, 0);

      const detailed = computeCashflowProjectionsDetailed(plan, { ...ctx, controls });

      const scheduledPayments = payments.reduce((acc, payment) => acc + getPaymentAmount(payment), 0);
      const scheduledPrincipalTarget = Math.max(0, Number(detailed?.scheduledPrincipal) || scheduledPayments);
      const scheduledInterest = Math.max(0, Number(detailed?.scheduledInterest) || 0);
      const accruedInterestAfterPlan = Math.max(0, Number(detailed?.accruedInterestAfterPlan) || 0);
      const plannedEarns = sumPositive(earns, 'amount');
      let earnApplied = 0;

      let scheduledPrincipal = 0;
      let outstandingAfterPlan = 0;
      let outstandingByTickerResult;
      let scheduledPrincipalByTicker;

      if (hasLoanByTicker) {
        const outstandingByTicker = Object.keys(loanByTicker).reduce((acc, key) => {
          acc[key] = Math.max(0, Number(loanByTicker[key]) || 0);
          return acc;
        }, {});
        const requestsByTicker = {};
        let generalRequest = 0;
        payments.forEach((payment) => {
          const principal = getPaymentAmount(payment);
          if (!(principal > 0)) return;
          const key = normalizeTicker(payment?.ticker);
          if (key && outstandingByTicker[key] != null) {
            requestsByTicker[key] = (requestsByTicker[key] || 0) + principal;
          } else {
            generalRequest += principal;
          }
        });

        const totalRequested = Object.values(requestsByTicker).reduce((acc, value) => acc + value, 0) + generalRequest;
        const scaledByTicker = {};
        let scaledGeneral = 0;
        if (totalRequested > 0 && scheduledPrincipalTarget > 0) {
          const scale = Math.min(1, scheduledPrincipalTarget / totalRequested);
          Object.entries(requestsByTicker).forEach(([key, amount]) => {
            scaledByTicker[key] = amount * scale;
          });
          scaledGeneral = generalRequest * scale;
          const allocated = Object.values(scaledByTicker).reduce((acc, value) => acc + value, 0) + scaledGeneral;
          const remainder = Math.max(0, scheduledPrincipalTarget - allocated);
          scaledGeneral += remainder;
        } else if (scheduledPrincipalTarget > 0 && totalRequested === 0) {
          scaledGeneral = scheduledPrincipalTarget;
        }

        const principalBreakdown = {};
        let residual = scaledGeneral;
        Object.entries(scaledByTicker).forEach(([key, amount]) => {
          const current = Math.max(0, Number(outstandingByTicker[key]) || 0);
          if (!(current > 0)) {
            residual += amount;
            return;
          }
          const applied = Math.min(current, amount);
          if (applied > 0) {
            outstandingByTicker[key] = current - applied;
            principalBreakdown[key] = (principalBreakdown[key] || 0) + applied;
          }
          if (amount > applied) {
            residual += amount - applied;
          }
        });

        if (residual > 0) {
          const residualBreakdown = applyProportionalReductionWithBreakdown(outstandingByTicker, residual);
          Object.entries(residualBreakdown).forEach(([key, value]) => {
            if (!(value > 0)) return;
            principalBreakdown[key] = (principalBreakdown[key] || 0) + value;
          });
        }

        const outstandingAfterPayments = Math.max(0, sumMap(outstandingByTicker));
        scheduledPrincipal = Math.min(Math.max(0, sumMap(loanByTicker) - outstandingAfterPayments), scheduledPrincipalTarget || Infinity);
        scheduledPrincipalByTicker = Object.keys(principalBreakdown).reduce((acc, key) => {
          const value = Math.max(0, Number(principalBreakdown[key]) || 0);
          if (value > 0) acc[key] = value;
          return acc;
        }, {});

        if (plannedEarns > 0) {
          earnApplied = applyProportionalReduction(outstandingByTicker, plannedEarns);
        }

        outstandingAfterPlan = Math.max(0, sumMap(outstandingByTicker));
        outstandingByTickerResult = Object.keys(outstandingByTicker).reduce((acc, key) => {
          const value = Math.max(0, Number(outstandingByTicker[key]) || 0);
          if (value > 0) acc[key] = value;
          return acc;
        }, {});
      } else {
        scheduledPrincipal = Math.min(loanAmount, scheduledPrincipalTarget);
        const outstandingBeforeEarn = Math.max(0, loanAmount - scheduledPrincipal);
        if (plannedEarns > 0 && outstandingBeforeEarn > 0) {
          earnApplied = Math.min(outstandingBeforeEarn, plannedEarns);
        }
        outstandingAfterPlan = Math.max(0, outstandingBeforeEarn - earnApplied);
      }

      const netOutstandingAfterPlan = Math.max(0, outstandingAfterPlan + accruedInterestAfterPlan);
      const projectedFinalPayoff = Math.max(0, Number(detailed?.projectedFinalPayoff) || netOutstandingAfterPlan);
      const totalCost = Math.max(0, Number(detailed?.totalCost) || (scheduledPayments + projectedFinalPayoff));

      const collateralDeltaFromManual = manual.reduce((acc, item) => {
        const amount = Number(item?.amount);
        if (!Number.isFinite(amount) || amount <= 0) return acc;
        if (item?.collateralImpact === 'increase') return acc + amount;
        if (item?.collateralImpact === 'decrease') return acc - amount;
        return acc;
      }, 0);

      const collateralDeltaPlanned = Number.isFinite(detailed?.collateralDeltaPlanned)
        ? detailed.collateralDeltaPlanned
        : collateralDeltaFromManual;
      const collateralAfterPlan = Number.isFinite(detailed?.collateralAfterPlan)
        ? Math.max(0, detailed.collateralAfterPlan)
        : Math.max(0, baseCollateral + collateralDeltaPlanned);

      const denominator = collateralAfterPlan > 0 ? collateralAfterPlan : baseCollateral;
      const fallbackLtv = denominator > 0
        ? netOutstandingAfterPlan / denominator
        : (netOutstandingAfterPlan > 0 ? 1 : 0);
      const ltvForGauge = Number.isFinite(detailed?.ltvForGauge)
        ? Math.max(0, detailed.ltvForGauge)
        : Math.max(0, fallbackLtv);

      const scenarioLabel = typeof detailed?.scenarioLabel === 'string'
        ? detailed.scenarioLabel
        : (typeof plan?.activeScenario === 'string' ? plan.activeScenario : 'base');

      const thresholds = {
        target: Number(ctx?.targetLtv),
        margin: Number(ctx?.marginCallLtv),
        auto: Number(ctx?.autoRepayLtv),
      };

      const fallbackAlerts = [];
      if (Number.isFinite(thresholds.auto) && thresholds.auto > 0 && ltvForGauge >= thresholds.auto) {
        fallbackAlerts.push({
          id: 'auto-liquidation',
          tone: 'danger',
          message: 'El plan proyectado supera el LTV de auto-liquidación.',
        });
      } else if (Number.isFinite(thresholds.margin) && thresholds.margin > 0 && ltvForGauge >= thresholds.margin) {
        fallbackAlerts.push({
          id: 'margin-call',
          tone: 'warn',
          message: 'El plan proyectado alcanza el LTV de margin call.',
        });
      } else if (Number.isFinite(thresholds.target) && thresholds.target > 0 && ltvForGauge > thresholds.target) {
        fallbackAlerts.push({
          id: 'target',
          tone: 'info',
          message: 'El plan queda por encima del LTV objetivo.',
        });
      }

      const alerts = Array.isArray(detailed?.alerts) && detailed.alerts.length > 0 ? detailed.alerts : fallbackAlerts;
      const netBalanceFinal = Number.isFinite(detailed?.netBalanceFinal)
        ? Math.max(0, detailed.netBalanceFinal)
        : Math.max(0, netOutstandingAfterPlan - Math.max(0, plannedEarns - earnApplied));

      return {
        scheduledPrincipal,
        scheduledInterest,
        projectedFinalPayoff,
        totalCost,
        outstandingAfterPlan,
        netOutstandingAfterPlan,
        outstandingByTicker: hasLoanByTicker ? outstandingByTickerResult : undefined,
        collateralDeltaPlanned,
        collateralAfterPlan,
        ltvForGauge,
        scenarioLabel,
        alerts,
        netBalanceFinal,
        loanByTicker: hasLoanByTicker ? loanByTicker : undefined,
        scheduledPrincipalByTicker: scheduledPrincipalByTicker && Object.keys(scheduledPrincipalByTicker).length > 0
          ? scheduledPrincipalByTicker
          : undefined,
        accruedInterestAfterPlan,
      };
    }

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null };
        this.handleRetry = this.handleRetry.bind(this);
      }

      static getDerivedStateFromError(error) {
        return { error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('Error al renderizar la app', error, errorInfo);
      }

      handleRetry() {
        this.setState({ error: null });
      }

      render() {
        if (this.state.error) {
          return (
            <div className="min-h-screen w-full bg-neutral-100 flex items-center justify-center px-6 py-12">
              <div className="max-w-lg w-full rounded-3xl bg-white shadow-xl border border-red-100 p-8 text-center space-y-4">
                <div className="text-2xl font-semibold text-red-600">Algo salió mal</div>
                <p className="text-sm text-neutral-600">
                  No pudimos renderizar el simulador. Revisa la consola para más detalles o intenta recargar la página.
                </p>
                <pre className="text-xs text-left whitespace-pre-wrap bg-red-50 text-red-700 rounded-2xl p-4 overflow-auto max-h-48">
                  {String(this.state.error?.message || this.state.error)}
                </pre>
                <button onClick={this.handleRetry} className="nx-btn">Reintentar</button>
              </div>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const formatDecimal = (value, {
      minimumFractionDigits = 2,
      maximumFractionDigits = 2,
    } = {}) => {
      if (!Number.isFinite(value)) return '—';
      return new Intl.NumberFormat(DEFAULT_LOCALE, {
        minimumFractionDigits,
        maximumFractionDigits,
      }).format(value);
    };

    const formatCurrency = (value, currency = 'USDT') => {
      if (!Number.isFinite(value)) return '—';
      try {
        return new Intl.NumberFormat(DEFAULT_LOCALE, {
          style: 'currency',
          currency,
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(value);
      } catch (error) {
        const formatted = new Intl.NumberFormat(DEFAULT_LOCALE, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(value);
        return `${currency} ${formatted}`;
      }
    };

    const formatPercent = (value, {
      minimumFractionDigits = 2,
      maximumFractionDigits = 2,
    } = {}) => {
      if (!Number.isFinite(value)) return '—';
      const formatted = new Intl.NumberFormat(DEFAULT_LOCALE, {
        style: 'percent',
        minimumFractionDigits,
        maximumFractionDigits,
      }).format(value);
      return formatted.replace(/\s*%/, '%');
    };

    const parseTimestamp = (value) => {
      if (value == null) return null;
      if (typeof value === 'number' && Number.isFinite(value)) return value;
      if (value instanceof Date && Number.isFinite(value.getTime())) return value.getTime();
      if (typeof value === 'string' && value.trim()) {
        const parsed = Date.parse(value);
        if (Number.isFinite(parsed)) return parsed;
      }
      return null;
    };

    const formatRelativeTime = (value, { now = Date.now(), fallback = null } = {}) => {
      const timestamp = parseTimestamp(value);
      if (!Number.isFinite(now) || timestamp == null) return fallback;
      const diffMs = Math.max(0, now - timestamp);
      if (diffMs < 1000) return '<1s';
      const totalSeconds = Math.floor(diffMs / 1000);
      if (totalSeconds < 60) return `${totalSeconds}s`;
      const totalMinutes = Math.floor(totalSeconds / 60);
      if (totalMinutes < 60) return `${totalMinutes}m`;
      const totalHours = Math.floor(totalMinutes / 60);
      if (totalHours < 24) {
        const remainingMinutes = totalMinutes % 60;
        return remainingMinutes > 0 ? `${totalHours}h ${remainingMinutes}m` : `${totalHours}h`;
      }
      const totalDays = Math.floor(totalHours / 24);
      const remainingHours = totalHours % 24;
      return remainingHours > 0 ? `${totalDays}d ${remainingHours}h` : `${totalDays}d`;
    };

    const parseLocaleNumber = (value) => {
      if (value == null) return NaN;
      if (typeof value === 'number') return value;
      let str = `${value}`.trim();
      if (!str) return NaN;
      let sign = 1;
      if (str.startsWith('+') || str.startsWith('-')) {
        sign = str.startsWith('-') ? -1 : 1;
        str = str.slice(1);
      }
      const cleaned = str.replace(/[^0-9.,]/g, '');
      if (!cleaned) return NaN;
      const lastSep = Math.max(cleaned.lastIndexOf(','), cleaned.lastIndexOf('.'));
      let integerPart = cleaned;
      let fractionPart = '';
      if (lastSep >= 0) {
        integerPart = cleaned.slice(0, lastSep);
        fractionPart = cleaned.slice(lastSep + 1);
      }
      const intDigits = integerPart.replace(/[^0-9]/g, '');
      const fracDigits = fractionPart.replace(/[^0-9]/g, '');
      const normalized = intDigits + (fracDigits ? `.${fracDigits}` : '');
      if (!normalized) return NaN;
      const num = Number(normalized);
      return Number.isFinite(num) ? num * sign : NaN;
    };

    const inferFractionDigits = (step, fallback = 2) => {
      if (step === 'any' || step == null) return Math.max(2, fallback);
      const numeric = typeof step === 'number' ? step : Number(step);
      if (!Number.isFinite(numeric) || numeric <= 0) return Math.max(2, fallback);
      const str = numeric.toString();
      if (str.includes('e-')) {
        const match = str.match(/e-(\d+)/i);
        if (match) return Math.max(Number.parseInt(match[1], 10) || fallback, 2);
      }
      const decimals = str.includes('.') ? str.split('.')[1].length : 0;
      return Math.max(decimals, 2, fallback);
    };

    const formatNumberForInput = (value, decimals = 2) => {
      if (!Number.isFinite(value)) return '';
      const safeDecimals = Math.max(decimals, 2);
      return formatDecimal(value, {
        minimumFractionDigits: Math.min(2, safeDecimals),
        maximumFractionDigits: safeDecimals,
      });
    };
    const FX_SYMBOLS = SUPPORTED_CURRENCIES
      .filter((c) => c.code !== 'USDT')
      .map((c) => c.code);

    const PLATFORM_BASE_CONFIGS = {
      nexo: {
        id: "nexo",
        name: "Nexo",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        theme: "nexo",
        classes: {
          header: "nx-gradient",
          accent: "text-blue-100/90",
          focusRing: "focus:ring-blue-700",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          NEXO: "nexo",
          USDT: "tether",
          USDC: "usd-coin",
          ADA: "cardano",
          ALGO: "algorand",
          XRP: "ripple",
          BNB: "binancecoin",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.50,
          ETH: 0.50,
          NEXO: 0.15,
          XRP: 0.30,
          BNB: 0.30,
          USDC: 0.50,
          USDT: 0.50,
          ADA: 0.50,
          ALGO: 0.30,
          SOL: 0.30,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.07,
          USDC: 0.12,
          USDT: 0.12,
          NEXO: 0.04,
          XRP: 0.07,
          BNB: 0.07,
          SOL: 0.07,
          ADA: 0.02,
          ALGO: 0.02,
        },
        policies: {
          targetLtv: 0.20,
          marginCallLtv: 0.70,
          autoRepayLtv: 0.8333333333,
          minBalancePerks: 5000,
          defaultLtv: 0.25,
        },
        apr: {
          base: 0.189,
          standard: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.139,
            Platinum: 0.109,
          },
          discounted: {
            Base: 0.189,
            Silver: 0.179,
            Gold: 0.059,
            Platinum: 0.029,
          },
          earlyRuleDays: 45,
          earlyAPR: 0.189,
          lowCostEligibleTiers: ["Gold", "Platinum"],
          baseTier: "Base",
        },
        loyalty: {
          tokenTicker: "NEXO",
          baseLabel: "Base",
          belowMinimumLabel: "Sin perks",
          tierThresholds: [
            { label: "Platinum", minRatio: 0.10 },
            { label: "Gold", minRatio: 0.05 },
            { label: "Silver", minRatio: 0.01 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (oficial)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Loyalty Tier",
          ratioLabel: "ratio NEXO",
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 7, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 15000,
          repayInDays: 120,
          currency: "USDT",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 8, price: 2100, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 25000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 6000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "USD Coin", ticker: "USDC", qty: 4000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 5000, price: 0.38, priceAuto: false, useAsCollateral: false },
            { id: 7, name: "Algorand", ticker: "ALGO", qty: 8000, price: 0.15, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "nexo_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Nexo.",
        },
      },
      binance: {
        id: "binance",
        name: "Binance",
        tagline: "Datos en vivo y cálculos de Earn (flexible) y crédito.",
        theme: "binance",
        classes: {
          header: "bn-gradient",
          accent: "text-amber-100/90",
          focusRing: "focus:ring-amber-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          BNB: "binancecoin",
          USDT: "tether",
          USDC: "usd-coin",
          BUSD: "binance-usd",
          ADA: "cardano",
          ALGO: "algorand",
          XRP: "ripple",
          SOL: "solana",
        },
        ltvByTicker: {
          BTC: 0.65,
          ETH: 0.60,
          BNB: 0.65,
          USDT: 0.80,
          USDC: 0.80,
          BUSD: 0.85,
          ADA: 0.4756,
          ALGO: 0.1024,
          XRP: 0.50,
          SOL: 0.50,
        },
        earnAprTop: {
          BTC: 0.03,
          ETH: 0.03,
          BNB: 0.05,
          USDT: 0.06,
          USDC: 0.06,
          BUSD: 0.06,
          ADA: 0.02,
          ALGO: 0.02,
          XRP: 0.02,
          SOL: 0.03,
        },
        collateralYield: {
          BTC: { apr: 0.03, source: 'manual preset' },
          ETH: { apr: 0.03, source: 'manual preset' },
          BNB: { apr: 0.05, source: 'manual preset' },
          USDT: { apr: 0.06, source: 'manual preset' },
          USDC: { apr: 0.06, source: 'manual preset' },
          BUSD: { apr: 0.06, source: 'manual preset' },
          ADA: { apr: 0.00038, source: 'binance-calibrated' },
          ALGO: { apr: 0.00047, source: 'binance-calibrated' },
          XRP: { apr: 0.02, source: 'manual preset' },
          SOL: { apr: 0.03, source: 'manual preset' },
        },
        borrowRates: {
          ADA: {
            label: "Cardano (ADA)",
            annual: 0.0482,
            hourly: annualToHourly(0.0482),
            netAnnual: 0.0474,
            adjustmentAnnual: 0.0008,
            loanAsset: "ADA",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          ALGO: {
            label: "Algorand (ALGO)",
            annual: 0.0482,
            hourly: annualToHourly(0.0482),
            netAnnual: 0.0436,
            adjustmentAnnual: 0.0046,
            loanAsset: "ALGO",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          BNB: {
            label: "BNB (BNB)",
            annual: 0.0612,
            hourly: annualToHourly(0.0612),
            loanAsset: "BNB",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          BTC: {
            label: "Bitcoin (BTC)",
            annual: 0.0725,
            hourly: annualToHourly(0.0725),
            loanAsset: "BTC",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          ETH: {
            label: "Ethereum (ETH)",
            annual: 0.0684,
            hourly: annualToHourly(0.0684),
            loanAsset: "ETH",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          USDT: {
            label: "Tether (USDT)",
            annual: 0.0595,
            hourly: annualToHourly(0.0595),
            loanAsset: "USDT",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          USDC: {
            label: "USD Coin (USDC)",
            annual: 0.0589,
            hourly: annualToHourly(0.0589),
            loanAsset: "USDC",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          BUSD: {
            label: "Binance USD (BUSD)",
            annual: 0.055,
            hourly: annualToHourly(0.055),
            loanAsset: "BUSD",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          XRP: {
            label: "XRP (XRP)",
            annual: 0.063,
            hourly: annualToHourly(0.063),
            loanAsset: "XRP",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
          SOL: {
            label: "Solana (SOL)",
            annual: 0.071,
            hourly: annualToHourly(0.071),
            loanAsset: "SOL",
            limitNote: "Depende del colateral y nivel VIP (ver tabla oficial)",
          },
        },
        diagnosticSources: {
          bip: [
            {
              code: "BIP-0007",
              title: "Ajustes dinámicos de tasa según oferta y demanda",
              url: "https://www.binance.com/es/support/faq/2c6d3b9ebf964d8d9d9f1f5f0cbe0f91",
            },
            {
              code: "BIP-0014",
              title: "Descuentos por nivel VIP y uso de BNB como colateral",
              url: "https://www.binance.com/es/support/faq/765dc83a4a65426aa4c0f0bd274b614e",
            },
            {
              code: "BIP-0021",
              title: "Política de liquidación y rangos de LTV para Binance Loans",
              url: "https://www.binance.com/es/support/faq/b46c1bb43d1e4b08a9a1811f667ac90a",
            },
          ],
        },
        policies: {
          targetLtv: 0.75,
          marginCallLtv: 0.85,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.0507,
          standard: {
            "Estándar": 0.0507,
            "VIP 1": 0.045,
            "VIP 2": 0.04,
            "VIP 3": 0.035,
          },
          discounted: {
            "Estándar": 0.0507,
            "VIP 1": 0.042,
            "VIP 2": 0.037,
            "VIP 3": 0.032,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.0507,
          lowCostEligibleTiers: ["VIP 2", "VIP 3"],
          baseTier: "Estándar",
        },
        ltvHealth: {
          zones: [
            { label: "Saludable", max: 0.75, color: "#22c55e", legend: "0-75%", tone: "ok" },
            { label: "Riesgo medio", max: 0.85, color: "#f97316", legend: "75-85%", tone: "warn" },
            { label: "Alto riesgo", max: 1, color: "#ef4444", legend: "≥85%", tone: "danger" },
          ],
          markers: [
            { pct: 0.85, label: "Margin call" },
            { pct: 0.90, label: "Auto-liquidación" },
          ],
        },
        loanLedger: {
          ADA: {
            originalPrincipal: 10300,
            outstanding: 10425.77,
            interestAccrued: 125.73,
            annualRate: 0.0499,
            netAnnualRate: 0.0474,
            liquidationLtv: 0.85,
            liquidationPriceHint: 0.35021,
            initialLtv: 0.4756,
            currentLtv: 0.4756,
            collateralAmount: 35175.5669,
            collateralIndexPrice: 0.625901,
            collateralUsd: 22016.4214,
            initialCollateralValue: 22016.4214,
            borrowIndexPrice: 1,
          },
          ALGO: {
            originalPrincipal: 7026,
            outstanding: 1203.81,
            interestAccrued: 68.77,
            annualRate: 0.0499,
            netAnnualRate: 0.0436,
            liquidationLtv: 0.85,
            liquidationPriceHint: 0.02152,
            initialLtv: 0.1024,
            currentLtv: 0.1024,
            collateralAmount: 65699.7595,
            collateralIndexPrice: 0.1786328,
            collateralUsd: 11736.1328,
            initialCollateralValue: 11736.1328,
            borrowIndexPrice: 1,
            payments: [
              { id: "algo-payment-1", amount: 5890.97, date: "2024-03-12", note: "Pago capital" },
              { id: "algo-payment-2", amount: 2.77, date: "2024-03-12", note: "Pago interés" },
            ],
          },
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "BNB", ticker: "BNB", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "BUSD", ticker: "BUSD", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 8, name: "XRP", ticker: "XRP", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
          { id: 9, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
          binanceBorrowTicker: "ADA",
          loanRequests: [
            { id: "loan-bin-ada", ticker: "ADA", amount: 10425.77 },
            { id: "loan-bin-algo", ticker: "ALGO", amount: 1203.81 },
          ],
        },
        previewSnapshot: {
          loanAmount: 11629.53,
          repayInDays: 90,
          currency: "USDT",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, ARS: 1050 },
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
            binanceBorrowTicker: "ADA",
            loanRequests: [
              { id: "loan-preview-ada", ticker: "ADA", amount: 10425.77 },
              { id: "loan-preview-algo", ticker: "ALGO", amount: 1203.81 },
            ],
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.5, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 4, price: 2050, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "BNB", ticker: "BNB", qty: 120, price: 230, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 1500, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "BUSD", ticker: "BUSD", qty: 800, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Cardano", ticker: "ADA", qty: 35175.57, price: 0.625901, priceAuto: false, useAsCollateral: true },
            { id: 7, name: "XRP", ticker: "XRP", qty: 3000, price: 0.52, priceAuto: false, useAsCollateral: false },
            { id: 8, name: "Algorand", ticker: "ALGO", qty: 65699.76, price: 0.178633, priceAuto: false, useAsCollateral: true },
          ],
        },
        exportPrefix: "binance_dashboard",
        disclaimers: {
          finePrint: "* Este simulador es orientativo. Verifica términos/tasas vigentes en Binance (Loans Flexible).",
        },
      },
      youhodler: {
        id: "youhodler",
        name: "YouHodler",
        tagline: "Multi-colateral y planes de tasas basados en stablecoins.",
        theme: "youhodler",
        classes: {
          header: "yh-gradient",
          accent: "text-sky-100/90",
          focusRing: "focus:ring-sky-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          LTC: "litecoin",
          SOL: "solana",
          ADA: "cardano",
          USDT: "tether",
          USDC: "usd-coin",
        },
        ltvByTicker: {
          BTC: 0.90,
          ETH: 0.90,
          LTC: 0.85,
          SOL: 0.80,
          ADA: 0.75,
          USDT: 0.90,
          USDC: 0.90,
        },
        earnAprTop: {
          BTC: 0.05,
          ETH: 0.05,
          LTC: 0.04,
          SOL: 0.05,
          ADA: 0.03,
          USDT: 0.12,
          USDC: 0.12,
        },
        policies: {
          targetLtv: 0.70,
          marginCallLtv: 0.85,
          autoRepayLtv: 0.90,
          minBalancePerks: 0,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.12,
          standard: {
            "Classic": 0.12,
            "Premium": 0.10,
            "VIP": 0.08,
          },
          discounted: {
            "Classic": 0.11,
            "Premium": 0.09,
            "VIP": 0.07,
          },
          earlyRuleDays: 30,
          earlyAPR: 0.12,
          lowCostEligibleTiers: ["Premium", "VIP"],
          baseTier: "Classic",
        },
        loyalty: {
          tokenTicker: "USDT",
          baseLabel: "Classic",
          belowMinimumLabel: "Classic",
          tierThresholds: [
            { label: "VIP", minRatio: 0.50 },
            { label: "Premium", minRatio: 0.25 },
          ],
          models: [
            { id: "vsTotal", label: "vs total (stablecoins)" },
          ],
          kpiLabel: "Plan activo",
          ratioLabel: "ratio stablecoins",
        },
        ltvHealth: {
          zones: [
            { label: "Seguro", max: 0.7, color: "#38bdf8", legend: "≤70%", tone: "ok" },
            { label: "Vigilar", max: 0.85, color: "#f97316", legend: "70-85%", tone: "warn" },
            { label: "Crítico", max: 1, color: "#ef4444", legend: "≥85%", tone: "danger" },
          ],
          markers: [
            { pct: 0.70, label: "Nivel óptimo" },
            { pct: 0.85, label: "Margin call" },
            { pct: 0.9, label: "Auto-liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "Litecoin", ticker: "LTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Solana", ticker: "SOL", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 7, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsTotal",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 18000,
          repayInDays: 75,
          currency: "USDT",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, EUR: 0.94 },
            loyaltyModel: "vsTotal",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0.9, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Ethereum", ticker: "ETH", qty: 10, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "Tether", ticker: "USDT", qty: 20000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "USD Coin", ticker: "USDC", qty: 15000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "Litecoin", ticker: "LTC", qty: 300, price: 65, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Solana", ticker: "SOL", qty: 400, price: 55, priceAuto: false, useAsCollateral: true },
            { id: 7, name: "Cardano", ticker: "ADA", qty: 6000, price: 0.38, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "youhodler_dashboard",
        disclaimers: {
          finePrint: "* Tasas aproximadas según planes Classic/Premium/VIP publicados por YouHodler (referencial).",
        },
      },
      ledn: {
        id: "ledn",
        name: "Ledn",
        tagline: "Créditos sobre BTC/USDC con métricas conservadoras y B2B.",
        theme: "ledn",
        classes: {
          header: "ld-gradient",
          accent: "text-teal-100/90",
          focusRing: "focus:ring-teal-500",
        },
        coingeckoIds: {
          BTC: "bitcoin",
          ETH: "ethereum",
          WBTC: "wrapped-bitcoin",
          USDC: "usd-coin",
          USDT: "tether",
          LTC: "litecoin",
        },
        ltvByTicker: {
          BTC: 0.70,
          ETH: 0.65,
          WBTC: 0.70,
          USDC: 0.90,
          USDT: 0.85,
          LTC: 0.60,
        },
        earnAprTop: {
          BTC: 0.06,
          ETH: 0.06,
          USDC: 0.07,
          USDT: 0.07,
          WBTC: 0.06,
          LTC: 0.04,
        },
        policies: {
          targetLtv: 0.55,
          marginCallLtv: 0.75,
          autoRepayLtv: 0.85,
          minBalancePerks: 1000,
          defaultLtv: 0.30,
        },
        apr: {
          base: 0.119,
          standard: {
            "Standard": 0.119,
            "Silver": 0.109,
            "Gold": 0.089,
          },
          discounted: {
            "Standard": 0.109,
            "Silver": 0.099,
            "Gold": 0.079,
          },
          earlyRuleDays: 60,
          earlyAPR: 0.119,
          lowCostEligibleTiers: ["Gold"],
          baseTier: "Standard",
        },
        loyalty: {
          tokenTicker: "BTC",
          baseLabel: "Standard",
          belowMinimumLabel: "Standard",
          tierThresholds: [
            { label: "Gold", minRatio: 0.50 },
            { label: "Silver", minRatio: 0.30 },
          ],
          models: [
            { id: "vsRest", label: "vs resto (BTC dominante)" },
            { id: "vsTotal", label: "vs total" },
          ],
          kpiLabel: "Plan de tasa",
          ratioLabel: "ratio BTC",
        },
        ltvHealth: {
          zones: [
            { label: "Conservador", max: 0.55, color: "#2dd4bf", legend: "≤55%", tone: "ok" },
            { label: "Observación", max: 0.75, color: "#fbbf24", legend: "55-75%", tone: "warn" },
            { label: "Crítico", max: 1, color: "#ef4444", legend: "≥75%", tone: "danger" },
          ],
          markers: [
            { pct: 0.55, label: "Zona Ledn" },
            { pct: 0.75, label: "Margin call" },
            { pct: 0.85, label: "Liquidación" },
          ],
        },
        defaultAssets: [
          { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 3, name: "Wrapped BTC", ticker: "WBTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true },
          { id: 4, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 5, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true },
          { id: 6, name: "Litecoin", ticker: "LTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: false },
        ],
        defaultParams: {
          exchangeRates: { ...DEFAULT_EXCHANGE_RATES },
          loyaltyModel: "vsRest",
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
        },
        previewSnapshot: {
          loanAmount: 9000,
          repayInDays: 150,
          currency: "USDT",
          params: {
            exchangeRates: { ...DEFAULT_EXCHANGE_RATES, CAD: 1.34 },
            loyaltyModel: "vsRest",
            liveQuotes: true,
            earnOptIn: true,
            earnOnCollateral: true,
            refreshSec: LIVE_REFRESH_SECONDS,
          },
          assets: [
            { id: 1, name: "Bitcoin", ticker: "BTC", qty: 1.2, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 2, name: "Wrapped BTC", ticker: "WBTC", qty: 0.6, price: 42000, priceAuto: false, useAsCollateral: true },
            { id: 3, name: "USD Coin", ticker: "USDC", qty: 15000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 4, name: "Tether", ticker: "USDT", qty: 5000, price: 1, priceAuto: false, useAsCollateral: true },
            { id: 5, name: "Ethereum", ticker: "ETH", qty: 4, price: 2000, priceAuto: false, useAsCollateral: true },
            { id: 6, name: "Litecoin", ticker: "LTC", qty: 600, price: 65, priceAuto: false, useAsCollateral: false },
          ],
        },
        exportPrefix: "ledn_dashboard",
        disclaimers: {
          finePrint: "* Tasas Ledn orientativas basadas en publicaciones públicas (pueden cambiar sin previo aviso).",
        },
      },
    };

    const FEATURE_IMPROVEMENT_TASKS = {
      common: [
        {
          id: "scenario-engine",
          title: "Motor de escenarios de estrés",
          description: "Permitir shocks de precio (%) o volatilidad intradía y graficar cómo evolucionan LTV, margen y liquidaciones.",
        },
        {
          id: "alerting",
          title: "Alertas multi-canal",
          description: "Configurar umbrales de LTV/ratio que disparen alertas por email, Telegram o webhook para reaccionar antes de margin call.",
        },
        {
          id: "benchmarking",
          title: "Benchmark CeFi vs DeFi",
          description: "Comparar automáticamente las tasas del simulador con protocolos DeFi (Aave, Spark) para detectar oportunidades de arbitraje.",
        },
        {
          id: "cashflow-planning",
          title: "Planificador de cashflow",
          description: "Agregar calendario de pagos parciales, rollovers y cálculo de costo efectivo mensual (CEM) por escenario.",
        },
      ],
      byPlatform: {
        nexo: [
          {
            id: "nexo-booster",
            title: "Simular Booster & convert",
            description: "Incluir loops de crédito + compra automática de cripto para ver impacto de Booster y conversión instantánea.",
          },
          {
            id: "nexo-insurance",
            title: "Visor de seguro Nexo",
            description: "Agregar panel que estime cobertura de seguro y auditorías (Armanino) frente a colateral disponible.",
          },
        ],
        binance: [
          {
            id: "binance-vip",
            title: "Modelo VIP dinámico",
            description: "Calcular automáticamente upgrade de nivel VIP considerando volumen spot/futuros y mostrar APR objetivo.",
          },
          {
            id: "binance-crossmargin",
            title: "Cruce con Cross-Margin",
            description: "Permitir importar posiciones de margin/futuros para medir riesgo agregado y requirements de colateral.",
          },
        ],
        youhodler: [
          {
            id: "yh-turbo",
            title: "Turbocharge loops",
            description: "Simular iteraciones Turbocharge (auto-loop) para ver cuántas rondas maximizan el capital sin liquidar.",
          },
          {
            id: "yh-stable-buckets",
            title: "Buckets de stablecoins",
            description: "Segregar stablecoins por plan (Classic/Premium/VIP) y optimizar qué cantidad conviene bloquear para subir de nivel.",
          },
        ],
        ledn: [
          {
            id: "ledn-b2b",
            title: "Modo institución",
            description: "Añadir campos de reporting (auditorías, segregación de cuentas) y métricas de reservas para clientes corporativos.",
          },
          {
            id: "ledn-proof",
            title: "Prueba de reservas",
            description: "Integrar feed de pruebas de reservas trimestrales y alertar si cambian los índices de cobertura BTC/USDC.",
          },
        ],
      },
    };

    const PLATFORM_IDS = Object.keys(PLATFORM_BASE_CONFIGS);
    const BASE_GLOBAL_COINGECKO_IDS = Object.values(PLATFORM_BASE_CONFIGS).reduce((acc, cfg) => ({ ...acc, ...(cfg.coingeckoIds || {}) }), {});

    const fmt = (value, currency = "USDT", showCurrency = true) => {
      if (!Number.isFinite(value)) return showCurrency ? '—' : '0';
      return showCurrency ? formatCurrency(value, currency) : formatDecimal(value);
    };

    const todayISO = () => new Date().toISOString().slice(0, 10);

    function SimuladorPrestamos() {
      const initialPlatformId = PLATFORM_IDS[0];
      const [platformId, setPlatformId] = useState(() => {
        if (typeof window === 'undefined') return initialPlatformId;
        try {
          const stored = localStorage.getItem('spm_platform');
          return PLATFORM_IDS.includes(stored) ? stored : initialPlatformId;
        } catch {
          return initialPlatformId;
        }
      });

      const [platformConfigs, setPlatformConfigs] = useState(PLATFORM_BASE_CONFIGS);
      const globalCoingeckoIds = useMemo(() => {
        return Object.values(platformConfigs || {}).reduce((acc, cfg) => ({
          ...acc,
          ...(cfg?.coingeckoIds || {}),
        }), {});
      }, [platformConfigs]);
      const platform = platformConfigs[platformId] ?? platformConfigs[initialPlatformId];
      const {
        id,
        name: platformName,
        tagline,
        theme: platformTheme,
        classes = {},
        coingeckoIds = {},
        ltvByTicker: ltvByTickerConfig = {},
        earnAprTop: earnAprTopConfig = {},
        collateralYield: collateralYieldConfig = {},
        policies = {},
        apr: aprConfig = {},
        borrowRates: borrowRatesConfig = {},
        loanLedger: platformLoanLedgerConfig = {},
        loyalty,
        ltvHealth,
        previewSnapshot,
        defaultAssets: platformDefaultAssets = [],
        defaultParams: platformDefaultParams = {},
        exportPrefix = "simulador_prestamos",
        disclaimers = {},
        diagnosticSources = {},
      } = platform;

      const [simModelConfig, setSimModelConfig] = useState(() => readSimModelConfigFromDom());

      const themeName = THEME_TOKENS[platformTheme] ? platformTheme : DEFAULT_THEME;
      const focusRingClass = classes.focusRing || "focus:ring-blue-700";
      const headerClass = classes.header || "nx-gradient";
      const accentClass = classes.accent || "text-blue-100/90";
      const platformTagline = tagline || "Datos en vivo y cálculos de Earn (flexible) y crédito.";
      const targetLtv = policies.targetLtv ?? 0.20;
      const marginCallLtv = policies.marginCallLtv ?? 0.70;
      const autoRepayLtv = policies.autoRepayLtv ?? 0.85;
      const minBalancePerks = policies.minBalancePerks ?? 0;
      const defaultLtv = policies.defaultLtv ?? 0.25;
      const improvementIdeas = useMemo(() => {
        const base = FEATURE_IMPROVEMENT_TASKS.common || [];
        const extras = (FEATURE_IMPROVEMENT_TASKS.byPlatform || {})[platformId] || [];
        const implementedIds = new Set(["benchmarking", "cashflow-planning"]);
        return [...base, ...extras].filter((idea) => !implementedIds.has(idea.id));
      }, [platformId]);
      const runtimeFlags = useMemo(() => {
        if (typeof window === 'undefined') {
          return { forceOn: false, simMode: false };
        }
        try {
          const params = new URLSearchParams(window.location.search || '');
          const simParam = (params.get('sim') || params.get('simulation') || '').toLowerCase();
          const simMode = simParam === '1' || simParam === 'true' || simParam === 'yes';
          const forceParamRaw = params.get('forceOn');
          const forceParam = typeof forceParamRaw === 'string' ? forceParamRaw.toLowerCase() : '';
          const forceFromParam = ['1', 'true', 'yes', 'on'].includes(forceParam);
          const globalForce = typeof window.__SIMULATOR_FORCE_ON__ === 'boolean'
            ? window.__SIMULATOR_FORCE_ON__
            : (typeof window.__SIM_FORCE_ON__ === 'boolean'
              ? window.__SIM_FORCE_ON__
              : (forceFromParam || simMode));
          return { forceOn: !!globalForce, simMode };
        } catch (error) {
          console.warn('No se pudo leer los flags de simulación de la URL:', error);
          return { forceOn: false, simMode: false };
        }
      }, []);
      const forceOn = runtimeFlags.forceOn;
      const simMode = runtimeFlags.simMode;
      const loyaltyModels = loyalty?.models ?? [];
      const loyaltyModelFallback = platformDefaultParams?.loyaltyModel ?? loyaltyModels[0]?.id ?? "vsRest";
      const isBinance = id === "binance";
      const [nowTs, setNowTs] = useState(() => Date.now());
      useEffect(() => {
        writeSimModelConfigToDom(simModelConfig);
      }, [simModelConfig]);
      const clamp01 = (v) => Math.max(0, Math.min(1, Number(v) || 0));
      const toPct = (value, digits = 0) => formatPercent(Number(value), {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits,
      });
      const ltvGaugeZones = React.useMemo(() => {
        if (ltvHealth?.zones?.length) {
          return ltvHealth.zones
            .map((zone, idx) => ({
              label: zone.label ?? `Zona ${idx + 1}`,
              max: clamp01(zone.max),
              color: zone.color ?? (idx === 0 ? "#22c55e" : idx === 1 ? "#facc15" : "#ef4444"),
              legend: zone.legend ?? `≤${Math.round(clamp01(zone.max) * 100)}%`,
              tone: zone.tone ?? (idx === 0 ? "ok" : idx === (ltvHealth.zones.length - 1) ? "danger" : "warn"),
            }))
            .filter((zone, idx, arr) => zone.max > 0 && idx === arr.findIndex((z) => z.max === zone.max))
            .sort((a, b) => a.max - b.max);
        }
        return [
          { label: "Muy saludable", max: clamp01(0.20), color: "#064e3b", legend: "0-20%", tone: "ok" },
          { label: "Saludable", max: clamp01(0.50), color: "#22c55e", legend: "20-50%", tone: "ok" },
          { label: "Vigilancia", max: clamp01(0.70), color: "#facc15", legend: "50-70%", tone: "warn" },
          { label: "Tensión", max: clamp01(0.83), color: "#fb923c", legend: "70-83%", tone: "warn" },
          { label: "Crítico", max: 1, color: "#ef4444", legend: ">83%", tone: "danger" },
        ];
      }, [ltvHealth, targetLtv, marginCallLtv, autoRepayLtv]);
      const ltvHealthyThreshold = clamp01(ltvGaugeZones[0]?.max ?? targetLtv);
      const ltvWarnThreshold = clamp01((ltvGaugeZones[1]?.max ?? marginCallLtv) || ltvHealthyThreshold);
      const ltvGaugeMarkers = React.useMemo(() => {
        const markersSource = ltvHealth?.markers?.length ? ltvHealth.markers : [
          { pct: targetLtv, label: `Objetivo ${Math.round(clamp01(targetLtv) * 100)}%` },
          { pct: marginCallLtv, label: `Margin call ${Math.round(clamp01(marginCallLtv) * 100)}%` },
          { pct: autoRepayLtv, label: `Auto-repay ${Math.round(clamp01(autoRepayLtv) * 100)}%` },
        ];
        return markersSource
          .map((marker, idx) => ({ pct: clamp01(marker.pct), label: marker.label ?? `Nivel ${idx + 1}` }))
          .filter((marker, idx, arr) => marker.pct > 0 && idx === arr.findIndex((m) => m.pct === marker.pct));
      }, [ltvHealth, targetLtv, marginCallLtv, autoRepayLtv]);

      const sanitizeTicker = useCallback((t) => {
        if (typeof t === "string") {
          return t.trim().toUpperCase();
        }
        return "";
      }, []);

      const collateralYieldAprMap = useMemo(() => {
        if (!collateralYieldConfig || typeof collateralYieldConfig !== 'object') {
          return {};
        }
        const parseApr = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? n : null;
        };
        return Object.entries(collateralYieldConfig).reduce((acc, [key, rawValue]) => {
          const ticker = sanitizeTicker(key);
          if (!ticker) return acc;
          const baseEntry = rawValue && typeof rawValue === 'object' ? { ...rawValue } : {};
          const aprCandidate =
            (rawValue && typeof rawValue === 'object'
              ? parseApr(rawValue.apr) ?? parseApr(rawValue.apy) ?? parseApr(rawValue.rate) ?? parseApr(rawValue.annual) ?? parseApr(rawValue.annualRate)
              : parseApr(rawValue));
          const apr = Number.isFinite(aprCandidate) ? aprCandidate : 0;
          acc[ticker] = {
            ...baseEntry,
            apr,
          };
          return acc;
        }, {});
      }, [collateralYieldConfig, sanitizeTicker]);

      const liqBiasByTicker = useMemo(() => {
        if (!simModelConfig || typeof simModelConfig !== 'object') return {};
        const source = simModelConfig.liquidationBias || {};
        return Object.entries(source).reduce((acc, [key, value]) => {
          const ticker = sanitizeTicker(key);
          if (!ticker) return acc;
          const raw = Number(value);
          if (!Number.isFinite(raw)) return acc;
          acc[ticker] = clampValue(raw, -0.1, 0.1);
          return acc;
        }, {});
      }, [simModelConfig, sanitizeTicker]);

      const binanceTimerRef = useRef(null);
      const binanceHmacKeyRef = useRef({ secret: null, key: null });
      const binanceCancelRef = useRef(false);

      const [binanceLive, setBinanceLive] = useState({
        borrowApr: {},
        collateralApr: {},
        collateralParams: {},
        indexPrices: {},
        positions: [],
        loanLedger: {},
        aggregate: null,
        serverTime: null,
        clockSkew: 0,
      });
      const [binanceLiveMeta, setBinanceLiveMeta] = useState({
        loading: false,
        error: null,
        lastUpdated: null,
        lastAttempt: null,
        status: 'idle',
      });

      const liveCollateralParams = isBinance ? (binanceLive?.collateralParams || {}) : {};
      const liveCollateralApr = isBinance ? (binanceLive?.collateralApr || {}) : {};
      const liveLoanLedger = isBinance ? (binanceLive?.loanLedger || {}) : {};
      const liveBorrowPositions = isBinance ? (binanceLive?.positions || []) : [];
      const binanceAggregate = isBinance ? (binanceLive?.aggregate || null) : null;

      const ltvByTicker = useMemo(() => {
        if (!isBinance) return ltvByTickerConfig;
        if (!liveCollateralParams || Object.keys(liveCollateralParams).length === 0) {
          return ltvByTickerConfig;
        }
        const merged = { ...ltvByTickerConfig };
        Object.entries(liveCollateralParams).forEach(([ticker, payload]) => {
          const key = typeof ticker === 'string' ? ticker.toUpperCase() : '';
          if (!key) return;
          const initial = Number(
            payload?.initialLTV ?? payload?.initialLtv ?? payload?.initial ?? payload
          );
          if (Number.isFinite(initial) && initial > 0) {
            merged[key] = initial;
          }
        });
        return merged;
      }, [isBinance, ltvByTickerConfig, liveCollateralParams]);

      const earnAprTop = useMemo(() => {
        const merged = { ...(earnAprTopConfig || {}) };
        Object.entries(collateralYieldAprMap).forEach(([ticker, entry]) => {
          const apr = Number(entry?.apr);
          if (Number.isFinite(apr) && apr >= 0) {
            merged[ticker] = apr;
          }
        });
        if (!isBinance) return merged;
        if (!liveCollateralApr || Object.keys(liveCollateralApr).length === 0) {
          return merged;
        }
        Object.entries(liveCollateralApr).forEach(([ticker, payload]) => {
          const key = typeof ticker === 'string' ? ticker.toUpperCase() : '';
          if (!key) return;
          const aprValue = typeof payload === 'object' && payload !== null
            ? Number(payload?.apr ?? payload?.latestAnnualPercentageRate ?? payload?.rate)
            : Number(payload);
          if (Number.isFinite(aprValue) && aprValue >= 0) {
            merged[key] = aprValue;
          }
        });
        return merged;
      }, [isBinance, earnAprTopConfig, liveCollateralApr, collateralYieldAprMap]);

      const liveBorrowRatesByCollateral = useMemo(() => {
        if (!isBinance || !Array.isArray(liveBorrowPositions) || liveBorrowPositions.length === 0) {
          return {};
        }
        return liveBorrowPositions.reduce((acc, position) => {
          const collateralKey = typeof position?.collateralCoin === 'string' ? position.collateralCoin.toUpperCase() : '';
          if (!collateralKey) return acc;
          const loanCoin = typeof position?.loanCoin === 'string' ? position.loanCoin.toUpperCase() : '';
          const annual = Number(position?.borrowApr);
          const netAnnual = Number(position?.netApr);
          const adjustment = Number(position?.aprOffset);
          const hourly = Number(position?.borrowHourly);
          const netHourly = Number(position?.netHourly);
          acc[collateralKey] = {
            label: loanCoin ? `${collateralKey} · préstamo ${loanCoin}` : collateralKey,
            annual: Number.isFinite(annual) && annual >= 0 ? annual : 0,
            netAnnual: Number.isFinite(netAnnual) ? netAnnual : null,
            adjustmentAnnual: Number.isFinite(adjustment) && adjustment >= 0 ? adjustment : Math.max(0, (Number.isFinite(annual) ? annual : 0) - (Number.isFinite(netAnnual) ? netAnnual : 0)),
            hourly: Number.isFinite(hourly) && hourly >= 0 ? hourly : annualToHourly(Number.isFinite(annual) ? annual : 0),
            netHourly: Number.isFinite(netHourly) ? netHourly : annualToHourly(Number.isFinite(netAnnual) ? netAnnual : 0),
            loanAsset: loanCoin || collateralKey,
            collateralApr: Number.isFinite(position?.collateralApr) ? position.collateralApr : null,
            fetchedAt: position?.updatedAt || null,
            source: 'binance-live',
          };
          return acc;
        }, {});
      }, [isBinance, liveBorrowPositions]);

      const borrowRates = useMemo(() => {
        if (!isBinance) return borrowRatesConfig;
        if (Object.keys(liveBorrowRatesByCollateral).length === 0) {
          return borrowRatesConfig;
        }
        return { ...borrowRatesConfig, ...liveBorrowRatesByCollateral };
      }, [isBinance, borrowRatesConfig, liveBorrowRatesByCollateral]);

      const platformLoanLedger = useMemo(() => {
        if (!isBinance) return platformLoanLedgerConfig;
        if (!liveLoanLedger || Object.keys(liveLoanLedger).length === 0) {
          return platformLoanLedgerConfig;
        }
        return { ...platformLoanLedgerConfig, ...liveLoanLedger };
      }, [isBinance, platformLoanLedgerConfig, liveLoanLedger]);

      useEffect(() => {
        if (!isBinance) return undefined;
        const tick = () => setNowTs(Date.now());
        tick();
        const interval = setInterval(tick, BINANCE_INTEREST_REFRESH_MS);
        return () => clearInterval(interval);
      }, [isBinance]);
      const borrowRatesByTicker = useMemo(() => {
        if (!borrowRates || typeof borrowRates !== 'object') return {};
        return Object.entries(borrowRates).reduce((acc, [ticker, info = {}]) => {
          const key = sanitizeTicker(ticker);
          if (!key) return acc;
          const annual = Number(info.annual);
          const safeAnnual = Number.isFinite(annual) ? annual : 0;
          const hourly = Number(info.hourly);
          const safeHourly = Number.isFinite(hourly) ? hourly : annualToHourly(safeAnnual);
          const netAnnualRaw = Number(info.netAnnual);
          const adjustmentRaw = Number(info.adjustmentAnnual);
          const vipAnnualRaw = Number(info.vipAnnual);
          const safeVipAnnual = Number.isFinite(vipAnnualRaw) && vipAnnualRaw >= 0 ? vipAnnualRaw : null;
          const safeAdjustment = Number.isFinite(adjustmentRaw)
            ? adjustmentRaw
            : (Number.isFinite(netAnnualRaw) ? safeAnnual - netAnnualRaw : 0);
          const fallbackNet = safeAnnual - safeAdjustment;
          const safeNetAnnual = Number.isFinite(netAnnualRaw) ? netAnnualRaw : fallbackNet;
          const safeNetHourly = annualToHourly(safeNetAnnual);
          acc[key] = {
            ...info,
            label: info.label || key,
            annual: safeAnnual,
            hourly: safeHourly,
            netAnnual: safeNetAnnual,
            netHourly: safeNetHourly,
            adjustmentAnnual: safeAdjustment,
            vipAnnual: safeVipAnnual,
          };
          return acc;
        }, {});
      }, [borrowRates]);
      const borrowTickerList = useMemo(() => Object.keys(borrowRatesByTicker), [borrowRatesByTicker]);
      const toNumber = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : 0;
      };
      const sanitizeAssets = (list) => {
        return (Array.isArray(list) ? list : []).map((item, idx) => {
          const ticker = sanitizeTicker(item.ticker);
          return {
            id: item.id ?? idx + 1,
            name: item.name ?? `Activo ${idx + 1}`,
            ticker,
            qty: toNumber(item.qty),
            price: toNumber(item.price),
            priceAuto: item.priceAuto === false ? false : true,
            useAsCollateral: item.useAsCollateral === false ? false : true,
            ltv: ltvByTicker[ticker] ?? item.ltv ?? defaultLtv,
            loanAssigned: Math.max(0, toNumber(item.loanAssigned)),
          };
        });
      };
      const sanitizeCashflowPlan = (rawPlan, fallbackRepay = null) => {
        const base = {
          payments: [],
          earns: [],
          manual: [],
          scenarioShocks: { base: 0, bear: -0.25, bull: 0.15 },
          activeScenario: 'base',
        };
        const safe = { ...base, ...(rawPlan || {}) };
        const ensureISO = (value, fallback) => {
          if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
          return fallback;
        };
        const toPos = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? Math.max(0, n) : 0;
        };
        const payments = Array.isArray(safe.payments)
          ? safe.payments.map((item, idx) => {
              const principal = toPos(item.principal);
              const interest = toPos(item.interest);
              const amount = toPos(item.amount);
              const total = amount > 0 ? amount : principal + interest;
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Pago ${idx + 1}`,
                date: ensureISO(item.date, fallbackRepay || todayISO()),
                amount: total,
                ticker: sanitizeTicker(item.ticker) || '',
              };
            })
          : [];
        const earns = Array.isArray(safe.earns)
          ? safe.earns.map((item, idx) => {
              const freq = ['daily', 'weekly', 'monthly'].includes(item.frequency) ? item.frequency : 'monthly';
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Flujo ${idx + 1}`,
                platform: item.platform || '',
                token: item.token || '',
                amount: toPos(item.amount),
                frequency: freq,
                startDate: ensureISO(item.startDate, todayISO()),
                endDate: ensureISO(item.endDate, fallbackRepay || ensureISO(item.startDate, todayISO())),
                defiLlamaId: typeof item.defiLlamaId === 'string' ? item.defiLlamaId : '',
              };
            })
          : [];
        const manual = Array.isArray(safe.manual)
          ? safe.manual.map((item, idx) => {
              const direction = item.direction === 'inflow' ? 'inflow' : 'outflow';
              const collateralImpact = ['increase', 'decrease', 'none'].includes(item.collateralImpact)
                ? item.collateralImpact
                : 'none';
              return {
                id: item.id ?? idx + 1,
                label: item.label || `Evento ${idx + 1}`,
                date: ensureISO(item.date, todayISO()),
                amount: toPos(item.amount),
                direction,
                collateralImpact,
              };
            })
          : [];
        const scenarioKeys = Object.keys(base.scenarioShocks);
        const scenarioShocks = { ...base.scenarioShocks };
        Object.keys(safe.scenarioShocks || {}).forEach((key) => {
          const num = Number(safe.scenarioShocks[key]);
          if (Number.isFinite(num)) {
            scenarioShocks[key] = num;
            if (!scenarioKeys.includes(key)) scenarioKeys.push(key);
          }
        });
        const activeScenario = scenarioKeys.includes(safe.activeScenario) ? safe.activeScenario : 'base';
        return { payments, earns, manual, scenarioShocks, activeScenario };
      };
      const sanitizeBenchmarkConfig = (rawConfig) => {
        const base = {
          rateMatrix: [
            { id: 'loan-default', platform: 'Plataforma CeFi', product: 'Préstamo estándar', type: 'APR', value: 0.12 },
            { id: 'yield-default', platform: 'Rendimiento', product: 'Estrategia base', type: 'APY', value: 0.10 },
          ],
          strategies: [
            {
              id: 'strategy-1',
              label: 'Carry base',
              lenderRateId: 'loan-default',
              yieldRateId: 'yield-default',
              apr: 0.12,
              apy: 0.10,
              feesIn: 0,
              feesOut: 0,
              amountOverride: null,
              riskCeFiLender: true,
              riskDeFiYield: false,
              riskNewProtocol: false,
              defiLlamaId: '',
            },
          ],
        };
        const safe = { ...base, ...(rawConfig || {}) };
        const matrix = Array.isArray(safe.rateMatrix)
          ? safe.rateMatrix.map((item, idx) => ({
              id: item.id ?? `rate-${idx + 1}`,
              platform: item.platform || 'Plataforma',
              product: item.product || 'Producto',
              type: item.type === 'APY' ? 'APY' : 'APR',
              value: Number(item.value) || 0,
            }))
          : base.rateMatrix;
        const strategies = Array.isArray(safe.strategies)
          ? safe.strategies.map((item, idx) => ({
              id: item.id ?? `strategy-${idx + 1}`,
              label: item.label || `Estrategia ${idx + 1}`,
              lenderRateId: item.lenderRateId || matrix[0]?.id || 'loan-default',
              yieldRateId: item.yieldRateId || matrix[1]?.id || 'yield-default',
              apr: Number(item.apr) || 0,
              apy: Number(item.apy) || 0,
              feesIn: Number(item.feesIn) || 0,
              feesOut: Number(item.feesOut) || 0,
              amountOverride: item.amountOverride == null || item.amountOverride === '' ? null : Math.max(0, Number(item.amountOverride) || 0),
              riskCeFiLender: item.riskCeFiLender !== false,
              riskDeFiYield: item.riskDeFiYield === true,
              riskNewProtocol: item.riskNewProtocol === true,
              defiLlamaId: typeof item.defiLlamaId === 'string' ? item.defiLlamaId : '',
            }))
          : base.strategies;
        return { rateMatrix: matrix, strategies };
      };
      const storageKeys = useMemo(() => ({
        assets: `spm_${id}_assets_v1`,
        params: `spm_${id}_params_v2`,
        cashflow: `spm_${id}_cashflow_v1`,
        benchmark: `spm_${id}_benchmark_v1`,
      }), [id]);
      const baseAssets = useMemo(() => sanitizeAssets(platformDefaultAssets), [platformDefaultAssets, ltvByTicker, defaultLtv]);
      const baseExchangeRates = useMemo(() => {
        const merged = { ...DEFAULT_EXCHANGE_RATES, ...(platformDefaultParams?.exchangeRates || {}) };
        merged.USD = 1;
        return merged;
      }, [platformDefaultParams]);
      const sanitizeExchangeRates = useCallback((rawRates, legacyUsdToArs) => {
        const next = { ...baseExchangeRates };
        const source = rawRates && typeof rawRates === 'object' ? rawRates : {};
        const legacy = Number.isFinite(legacyUsdToArs) ? legacyUsdToArs : null;
        for (const { code } of SUPPORTED_CURRENCIES) {
          if (code === 'USD') { next.USD = 1; continue; }
          const candidate = source[code];
          const value = Number(candidate);
          if (Number.isFinite(value) && value > 0) {
            next[code] = value;
          } else if (code === 'ARS' && legacy != null && legacy > 0) {
            next[code] = legacy;
          } else if (!Number.isFinite(Number(next[code])) || next[code] <= 0) {
            next[code] = DEFAULT_EXCHANGE_RATES[code] ?? 1;
          }
        }
        next.USD = 1;
        return next;
      }, [baseExchangeRates]);
      const sanitizeLoanRequests = useCallback((rawRequests) => {
        if (!Array.isArray(rawRequests)) return [];
        return rawRequests
          .map((item, idx) => {
            const amount = Math.max(0, Number(item?.amount) || 0);
            if (!(amount > 0)) return null;
            const ticker = sanitizeTicker(item?.ticker || '');
            const id = typeof item?.id === 'string' && item.id
              ? item.id
              : `loan-${idx + 1}-${ticker || 'GEN'}`;
            return { id, amount, ticker };
          })
          .filter(Boolean);
      }, []);

      const sanitizeLoanLedger = useCallback((rawLedger) => {
        if (!isBinance || !rawLedger || typeof rawLedger !== 'object') return {};
        const fallbackDate = todayISO();
        return Object.entries(rawLedger).reduce((acc, [ticker, entry = {}]) => {
          const key = sanitizeTicker(ticker);
          if (!key) return acc;
          const original = Math.max(0, Number(entry.originalPrincipal) || 0);
          const outstanding = Math.max(0, Number(entry.outstanding) || 0);
          const payments = Array.isArray(entry.payments)
            ? entry.payments
                .map((payment, idx) => {
                  const amount = Math.max(0, Number(payment?.amount) || 0);
                  if (!(amount > 0)) return null;
                  const date = typeof payment?.date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(payment.date)
                    ? payment.date
                    : null;
                  return {
                    id: typeof payment?.id === 'string' && payment.id ? payment.id : `${key}-payment-${idx + 1}`,
                    amount,
                    date,
                    note: typeof payment?.note === 'string' ? payment.note : '',
                  };
                })
                .filter(Boolean)
            : [];
          const paidTotal = payments.reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
          const rawInterest = Number(entry.interestAccrued);
          const computedInterest = Math.max(0, outstanding - Math.max(0, original - paidTotal));
          const interestAccrued = Number.isFinite(rawInterest) && rawInterest >= 0 ? rawInterest : computedInterest;
          const annualRate = Number(entry.annualRate);
          const netAnnualRate = Number(entry.netAnnualRate);
          const liquidationPriceHint = Number(entry.liquidationPriceHint);
          const liquidationLtv = Number(entry.liquidationLtv);
          const marginCallLtv = Number(entry.marginCallLtv);
          const initialLtv = Number(entry.initialLtv);
          const initialCollateralValueRaw = Number(entry.initialCollateralValue ?? entry.initialCollateralUsd ?? entry.initialCollateral);
          const collateralAmountRaw = Number(entry.collateralAmount);
          const borrowIndexPrice = Number(entry.borrowIndexPrice);
          const collateralIndexPrice = Number(entry.collateralIndexPrice);
          const currentLtv = Number(entry.currentLtv);
          const loanCoin = sanitizeTicker(entry.loanCoin || entry.borrowCoin || entry.loanTicker || '');
          const lastUpdatedTs = Number(entry.lastUpdatedTs);
          const borrowDate = typeof entry.borrowDate === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(entry.borrowDate)
            ? entry.borrowDate
            : null;
          const lastUpdated = typeof entry.lastUpdated === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(entry.lastUpdated)
            ? entry.lastUpdated
            : fallbackDate;
          acc[key] = {
            originalPrincipal: original > 0 ? original : Math.max(0, outstanding + paidTotal - interestAccrued),
            outstanding: outstanding > 0 ? outstanding : Math.max(0, original - paidTotal + interestAccrued),
            payments,
            paidTotal,
            interestAccrued,
            annualRate: Number.isFinite(annualRate) && annualRate > 0 ? annualRate : null,
            netAnnualRate: Number.isFinite(netAnnualRate) && netAnnualRate >= 0 ? netAnnualRate : null,
            liquidationPriceHint: Number.isFinite(liquidationPriceHint) && liquidationPriceHint > 0 ? liquidationPriceHint : null,
            liquidationLtv: Number.isFinite(liquidationLtv) && liquidationLtv > 0 ? liquidationLtv : null,
            marginCallLtv: Number.isFinite(marginCallLtv) && marginCallLtv > 0 ? marginCallLtv : null,
            borrowDate,
            lastUpdated,
            lastUpdatedTs: Number.isFinite(lastUpdatedTs) && lastUpdatedTs > 0 ? lastUpdatedTs : null,
            loanCoin: loanCoin || null,
            notes: typeof entry.notes === 'string' ? entry.notes : '',
            initialLtv: Number.isFinite(initialLtv) && initialLtv > 0 ? initialLtv : null,
            initialCollateralValue: Number.isFinite(initialCollateralValueRaw) && initialCollateralValueRaw > 0 ? initialCollateralValueRaw : null,
            collateralAmount: Number.isFinite(collateralAmountRaw) && collateralAmountRaw > 0 ? collateralAmountRaw : null,
            borrowIndexPrice: Number.isFinite(borrowIndexPrice) && borrowIndexPrice > 0 ? borrowIndexPrice : null,
            collateralIndexPrice: Number.isFinite(collateralIndexPrice) && collateralIndexPrice > 0 ? collateralIndexPrice : null,
            currentLtv: Number.isFinite(currentLtv) && currentLtv >= 0 ? currentLtv : null,
          };
          return acc;
        }, {});
      }, [isBinance, sanitizeTicker]);

      const sanitizeControls = useCallback((rawControls) => {
        const base = DEFAULT_SIMULATION_CONTROLS;
        const source = rawControls && typeof rawControls === 'object' ? rawControls : {};
        const alphaCandidate = Number(source.aprFundingAlpha);
        const sigmaCandidate = Number(source.sigmaK);
        const clampCandidate = Number(source.aprClamp);
        const next = {
          aprFundingAlpha: clamp01(Number.isFinite(alphaCandidate) ? alphaCandidate : base.aprFundingAlpha ?? 1),
          aprClamp: Number.isFinite(clampCandidate) ? clampCandidate : (Number.isFinite(base.aprClamp) ? base.aprClamp : null),
          sigmaK: Number.isFinite(sigmaCandidate) ? sigmaCandidate : (Number.isFinite(base.sigmaK) ? base.sigmaK : 1),
          ltv: {},
        };
        const baseInitClamp = Number(base?.ltv?.initClamp);
        const rawInitClamp = Number(source?.ltv?.initClamp);
        const resolvedInitClamp = Number.isFinite(rawInitClamp) && rawInitClamp > 0
          ? rawInitClamp
          : (Number.isFinite(baseInitClamp) && baseInitClamp > 0 ? baseInitClamp : null);
        if (resolvedInitClamp != null) {
          next.ltv.initClamp = resolvedInitClamp;
        }
        return next;
      }, []);

      const baseParams = useMemo(() => {
        const fallback = {
          exchangeRates: { ...baseExchangeRates },
          loyaltyModel: loyaltyModelFallback,
          liveQuotes: true,
          refreshSec: LIVE_REFRESH_SECONDS,
          earnOptIn: true,
          earnOnCollateral: true,
          manualLoanAllocation: false,
          loanRequests: [],
          controls: {
            aprFundingAlpha: DEFAULT_SIMULATION_CONTROLS.aprFundingAlpha,
            aprClamp: DEFAULT_SIMULATION_CONTROLS.aprClamp,
            sigmaK: DEFAULT_SIMULATION_CONTROLS.sigmaK,
            ltv: { ...(DEFAULT_SIMULATION_CONTROLS.ltv || {}) },
          },
        };
        const merged = { ...fallback, ...platformDefaultParams };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.exchangeRates = sanitizeExchangeRates(merged.exchangeRates, merged.usdToArs);
        if (isBinance) {
          const defaultTicker = borrowTickerList[0] || '';
          const candidate = sanitizeTicker(merged.binanceBorrowTicker);
          merged.binanceBorrowTicker = borrowRatesByTicker[candidate] ? candidate : defaultTicker;
        }
        merged.controls = sanitizeControls(merged.controls);
        return merged;
      }, [platformDefaultParams, loyaltyModelFallback, loyaltyModels, baseExchangeRates, isBinance, borrowTickerList, borrowRatesByTicker, sanitizeControls]);
      const baseCashflowPlan = useMemo(
        () => sanitizeCashflowPlan(previewSnapshot?.cashflow, (previewSnapshot?.repayDate || previewSnapshot?.cashflow?.payments?.[0]?.date || todayISO())),
        [previewSnapshot]
      );
      const baseBenchmarkConfig = useMemo(
        () => sanitizeBenchmarkConfig(previewSnapshot?.benchmark),
        [previewSnapshot]
      );
      const baseLoanLedger = useMemo(
        () => sanitizeLoanLedger(platformLoanLedger),
        [sanitizeLoanLedger, platformLoanLedger]
      );
      const calibrationSnapshot = useMemo(() => {
        if (!isBinance) return {};
        const fallbackLiq = autoRepayLtv > 0 ? autoRepayLtv : marginCallLtv;
        const map = {};
        Object.entries(baseLoanLedger).forEach(([ticker, entry = {}]) => {
          const key = sanitizeTicker(ticker);
          if (!key) return;
          const ledgerLiq = Number(entry?.liquidationLtv);
          const baseModel = Number.isFinite(ledgerLiq) && ledgerLiq > 0
            ? ledgerLiq
            : (Number.isFinite(ltvByTicker[key]) && ltvByTicker[key] > 0 ? ltvByTicker[key] : fallbackLiq);
          const loanAsset = sanitizeTicker(entry?.loanCoin || entry?.loanAsset || '');
          map[key] = {
            modelLiq: baseModel > 0 ? baseModel : fallbackLiq,
            loanAsset: loanAsset || 'USDT',
          };
        });
        Object.keys(ltvByTicker).forEach((ticker) => {
          const key = sanitizeTicker(ticker);
          if (!key || map[key]) return;
          const model = Number(ltvByTicker[key]);
          map[key] = {
            modelLiq: Number.isFinite(model) && model > 0 ? model : fallbackLiq,
            loanAsset: 'USDT',
          };
        });
        return map;
      }, [isBinance, baseLoanLedger, autoRepayLtv, marginCallLtv, sanitizeTicker, ltvByTicker]);
      const sanitizeParams = (raw) => {
        const merged = { ...baseParams, ...(raw || {}) };
        if (loyaltyModels.length && !loyaltyModels.some((m) => m.id === merged.loyaltyModel)) {
          merged.loyaltyModel = loyaltyModelFallback;
        }
        merged.manualLoanAllocation = !!merged.manualLoanAllocation;
        merged.loanRequests = sanitizeLoanRequests(merged.loanRequests);
        merged.controls = sanitizeControls(merged.controls);
        if (isBinance) {
          const defaultTicker = borrowTickerList[0] || '';
          const candidate = sanitizeTicker(merged.binanceBorrowTicker);
          merged.binanceBorrowTicker = borrowRatesByTicker[candidate] ? candidate : defaultTicker;
        }
        return merged;
      };

      const applyPreviewSnapshot = () => {
        if (!previewSnapshot) return;
        const {
          assets: previewAssets,
          params: previewParams,
          loanAmount: previewLoanAmount,
          repayDate: previewRepayDate,
          repayInDays,
          currency: previewCurrency,
        } = previewSnapshot;

        if (Array.isArray(previewAssets)) {
          setAssets(sanitizeAssets(previewAssets));
        }

        let sanitizedPreviewParams = null;
        if (previewParams) {
          sanitizedPreviewParams = sanitizeParams(previewParams);
          setParams(sanitizedPreviewParams);
        }

        if (previewSnapshot?.cashflow) {
          setCashflowPlan(sanitizeCashflowPlan(previewSnapshot.cashflow, previewSnapshot.repayDate || previewSnapshot.cashflow?.payments?.[0]?.date || repayDate));
        }

        if (previewSnapshot?.benchmark) {
          setBenchmarkConfig(sanitizeBenchmarkConfig(previewSnapshot.benchmark));
        }

        if (Number.isFinite(previewLoanAmount)) {
          const amount = Math.max(0, Number(previewLoanAmount) || 0);
          setLoanDraftAmount(amount);
          setParams((prev) => {
            const baseParams = sanitizedPreviewParams || prev;
            const defaultTicker = isBinance
              ? (sanitizeTicker(baseParams?.binanceBorrowTicker) || borrowTickerList[0] || '')
              : '';
            const nextRequests = amount > 0
              ? sanitizeLoanRequests([{ id: `loan-preview-${Date.now()}`, amount, ticker: defaultTicker }])
              : [];
            return { ...prev, loanRequests: nextRequests };
          });
        }

        if (typeof previewCurrency === 'string' && previewCurrency) {
          setSelectedCurrency(previewCurrency);
        } else if (typeof previewSnapshot?.showArs === 'boolean') {
          setSelectedCurrency(previewSnapshot.showArs ? 'ARS' : 'USD');
        }

        if (previewRepayDate) {
          setRepayDate(previewRepayDate);
        } else if (Number.isFinite(repayInDays)) {
          const d = new Date();
          d.setDate(d.getDate() + Math.max(0, Math.round(repayInDays)));
          setRepayDate(d.toISOString().slice(0, 10));
        }
      };

      useEffect(() => {
        if (!simMode) return;
        applyPreviewSnapshot();
      }, [simMode]);

      const [assets, setAssets] = useState(() => {
        if (typeof window === 'undefined') return baseAssets;
        try {
          const saved = localStorage.getItem(storageKeys.assets);
          if (saved) {
            return sanitizeAssets(JSON.parse(saved));
          }
        } catch {}
        return baseAssets;
      });
      const [assetsOriginKey, setAssetsOriginKey] = useState(storageKeys.assets);

      const [params, setParams] = useState(() => {
        if (typeof window === 'undefined') return baseParams;
        try {
          const saved = localStorage.getItem(storageKeys.params);
          if (saved) {
            return sanitizeParams(JSON.parse(saved));
          }
        } catch {}
        return baseParams;
      });
      const [paramsOriginKey, setParamsOriginKey] = useState(storageKeys.params);
      const loanRequests = useMemo(
        () => sanitizeLoanRequests(params.loanRequests),
        [params.loanRequests, sanitizeLoanRequests]
      );

      const controls = params?.controls && typeof params.controls === 'object'
        ? params.controls
        : DEFAULT_SIMULATION_CONTROLS;
      const aprFundingAlpha = clamp01(Number(controls?.aprFundingAlpha ?? DEFAULT_SIMULATION_CONTROLS.aprFundingAlpha));
      const aprClampValueRaw = Number(controls?.aprClamp);
      const aprClampValue = Number.isFinite(aprClampValueRaw) ? aprClampValueRaw : null;
      const ltvInitClampRaw = Number(controls?.ltv?.initClamp);
      const ltvInitClampValue = Number.isFinite(ltvInitClampRaw) && ltvInitClampRaw > 0
        ? ltvInitClampRaw
        : (Number.isFinite(DEFAULT_SIMULATION_CONTROLS?.ltv?.initClamp) && DEFAULT_SIMULATION_CONTROLS.ltv.initClamp > 0
          ? DEFAULT_SIMULATION_CONTROLS.ltv.initClamp
          : null);

      const resetBinanceTimer = useCallback(() => {
        if (binanceTimerRef.current) {
          clearTimeout(binanceTimerRef.current);
          binanceTimerRef.current = null;
        }
      }, []);

      useEffect(() => {
        binanceHmacKeyRef.current = { secret: null, key: null };
      }, [params.binanceApiSecret]);

      const triggerBinanceFetch = useCallback(async (origin = 'auto') => {
        if (!isBinance) return null;
        const apiKey = (params.binanceApiKey || '').trim();
        const apiSecret = (params.binanceApiSecret || '').trim();
        if (!apiKey || !apiSecret) {
          resetBinanceTimer();
          setBinanceLiveMeta((prev) => ({
            ...prev,
            loading: false,
            error: null,
            status: apiKey || apiSecret ? 'incomplete' : 'missing',
          }));
          return null;
        }
        const cryptoObj = (typeof window !== 'undefined' && window.crypto)
          ? window.crypto
          : (typeof self !== 'undefined' ? self.crypto : null);
        if (!cryptoObj || !cryptoObj.subtle) {
          const now = Date.now();
          setBinanceLiveMeta((prev) => ({
            ...prev,
            loading: false,
            error: 'Crypto API no disponible para firmar solicitudes.',
            status: 'error',
            lastAttempt: now,
          }));
          return null;
        }
        const markBinanceCancelled = () => {
          if (!binanceCancelRef.current) return false;
          setBinanceLiveMeta((prev) => {
            const prevStatus = prev.status || 'idle';
            const isSyncing = prevStatus === 'syncing' || prevStatus === 'syncing-manual';
            if (!isSyncing && prev.loading === false) {
              return prev;
            }
            return {
              ...prev,
              loading: false,
              status: isSyncing ? 'idle' : prevStatus,
            };
          });
          return true;
        };
        const signPayload = async (payload) => {
          const cached = binanceHmacKeyRef.current;
          if (!cached.key || cached.secret !== apiSecret) {
            const encoder = new TextEncoder();
            const material = encoder.encode(apiSecret);
            const key = await cryptoObj.subtle.importKey('raw', material, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
            binanceHmacKeyRef.current = { secret: apiSecret, key };
          }
          const encoder = new TextEncoder();
          const data = encoder.encode(payload);
          const signature = await cryptoObj.subtle.sign('HMAC', binanceHmacKeyRef.current.key, data);
          return Array.from(new Uint8Array(signature)).map((b) => b.toString(16).padStart(2, '0')).join('');
        };
        const parseNumber = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? n : 0;
        };
        const parseNullable = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? n : null;
        };
        const now = Date.now();
        setBinanceLiveMeta((prev) => ({
          ...prev,
          loading: true,
          error: null,
          status: origin === 'manual' ? 'syncing-manual' : 'syncing',
          lastAttempt: now,
        }));
        try {
          const serverRes = await fetchWithTimeout(`${BINANCE_API_BASE}/api/v3/time`);
          if (!serverRes.ok) throw new Error(`HTTP ${serverRes.status}`);
          const serverData = await serverRes.json();
          const serverTime = Number(serverData?.serverTime);
          if (!Number.isFinite(serverTime)) throw new Error('Server time inválido.');
          const clockSkew = serverTime - Date.now();
          const signedFetch = async (path, query = {}, options = {}) => {
            const { method = 'GET', recvWindow = BINANCE_SIGNED_RECV_WINDOW, timeoutMs = BINANCE_SYNC_TIMEOUT_MS } = options || {};
            const search = new URLSearchParams();
            Object.entries(query).forEach(([key, value]) => {
              if (value === undefined || value === null || value === '') return;
              search.append(key, value);
            });
            const timestamp = Date.now() + clockSkew;
            search.append('timestamp', String(Math.floor(timestamp)));
            if (recvWindow) search.append('recvWindow', String(recvWindow));
            const signature = await signPayload(search.toString());
            search.append('signature', signature);
            const url = `${BINANCE_API_BASE}${path}?${search.toString()}`;
            const res = await fetchWithTimeout(url, {
              method,
              headers: { 'X-MBX-APIKEY': apiKey },
            }, timeoutMs);
            if (!res.ok) {
              let message = '';
              try {
                const payload = await res.json();
                message = payload?.msg || payload?.message || JSON.stringify(payload);
              } catch {
                message = await res.text();
              }
              throw new Error(message || `HTTP ${res.status}`);
            }
            return res.json();
          };
          const collateralCandidates = new Set();
          const loanCandidates = new Set();
          assets.forEach((asset) => {
            if (asset?.useAsCollateral === false) return;
            const ticker = sanitizeTicker(asset?.ticker);
            if (ticker) collateralCandidates.add(ticker);
          });
          loanRequests.forEach((req) => {
            const ticker = sanitizeTicker(req?.ticker);
            if (ticker) loanCandidates.add(ticker);
          });
          const defaultLoanTicker = sanitizeTicker(params.binanceBorrowTicker);
          if (defaultLoanTicker) loanCandidates.add(defaultLoanTicker);
          const ordersPayload = await signedFetch('/sapi/v2/loan/flexible/ongoing/orders', { limit: 200 });
          const orderRows = Array.isArray(ordersPayload?.rows) ? ordersPayload.rows : [];
          orderRows.forEach((row) => {
            const loanCoin = sanitizeTicker(row?.loanCoin);
            const collateralCoin = sanitizeTicker(row?.collateralCoin);
            if (loanCoin) loanCandidates.add(loanCoin);
            if (collateralCoin) collateralCandidates.add(collateralCoin);
          });
          if (loanCandidates.size === 0 && collateralCandidates.size === 0 && Array.isArray(liveBorrowPositions)) {
            liveBorrowPositions.forEach((pos) => {
              const loanCoin = sanitizeTicker(pos?.loanCoin);
              const collateralCoin = sanitizeTicker(pos?.collateralCoin);
              if (loanCoin) loanCandidates.add(loanCoin);
              if (collateralCoin) collateralCandidates.add(collateralCoin);
            });
          }
          const loanCoinsArray = Array.from(loanCandidates);
          const collateralCoinsArray = Array.from(collateralCandidates);
          const borrowAprByLoan = {};
          if (loanCoinsArray.length > 0) {
            const borrowResults = await Promise.allSettled(loanCoinsArray.map((coin) => signedFetch('/sapi/v2/loan/interestRateHistory', { coin, limit: 1 })));
            borrowResults.forEach((result, idx) => {
              const coin = loanCoinsArray[idx];
              if (result.status !== 'fulfilled') {
                console.warn('Binance loan interest falló para', coin, result.reason);
                return;
              }
              const rows = Array.isArray(result.value?.rows) ? result.value.rows : [];
              const latest = rows[0];
              if (!latest) return;
              borrowAprByLoan[coin] = {
                annual: parseNumber(latest.annualizedInterestRate ?? latest.annualRate ?? latest.apr),
                hourly: parseNumber(latest.hourlyRate ?? latest.rate),
                raw: latest,
                fetchedAt: serverTime,
              };
            });
          }
          const collateralAprMap = Object.entries(collateralYieldAprMap).reduce((acc, [key, entry]) => {
            if (!entry) return acc;
            acc[key] = { ...entry, source: entry.source || 'manual' };
            return acc;
          }, {});
          if (collateralCoinsArray.length > 0) {
            const earnResults = await Promise.allSettled(collateralCoinsArray.map((coin) => signedFetch('/sapi/v1/simple-earn/flexible/list', { asset: coin })));
            earnResults.forEach((result, idx) => {
              const coin = collateralCoinsArray[idx];
              if (result.status !== 'fulfilled') {
                console.warn('Binance simple earn falló para', coin, result.reason);
                return;
              }
              const rows = Array.isArray(result.value?.rows) ? result.value.rows : [];
              const match = rows.find((row) => sanitizeTicker(row?.asset) === coin) || rows[0];
              if (!match) return;
              collateralAprMap[coin] = {
                apr: parseNumber(match.latestAnnualPercentageRate ?? match.apr),
                raw: match,
                fetchedAt: serverTime,
              };
            });
          }
          const collateralParamsMap = {};
          if (collateralCoinsArray.length > 0) {
            const paramsResults = await Promise.allSettled(collateralCoinsArray.map((coin) => signedFetch('/sapi/v2/loan/flexible/collateral/data', { collateralCoin: coin })));
            paramsResults.forEach((result, idx) => {
              const coin = collateralCoinsArray[idx];
              if (result.status !== 'fulfilled') {
                console.warn('Binance collateral data falló para', coin, result.reason);
                return;
              }
              const payload = result.value;
              const base = Array.isArray(payload?.rows) ? payload.rows[0] : payload;
              if (!base) return;
              collateralParamsMap[coin] = {
                initialLTV: parseNumber(base.initialLTV ?? base.initialLtv ?? base.initial),
                marginCall: parseNumber(base.marginCall ?? base.marginCallLTV ?? base.marginCallLtv),
                liquidationLTV: parseNumber(base.liquidationLTV ?? base.liquidationLtv ?? base.liquidation),
                raw: base,
              };
            });
          }
          const indexCoins = new Set([...loanCoinsArray, ...collateralCoinsArray]);
          const indexPrices = {};
          if (indexCoins.size > 0) {
            const indexResults = await Promise.allSettled(Array.from(indexCoins).map((coin) => {
              if (coin === 'USDT') {
                return Promise.resolve({ coin, price: 1 });
              }
              const symbol = `${coin}USDT`;
              return fetchWithTimeout(`${BINANCE_FAPI_BASE}/fapi/v1/premiumIndex?symbol=${symbol}`)
                .then((res) => {
                  if (!res.ok) throw new Error(`HTTP ${res.status}`);
                  return res.json();
                })
                .then((data) => ({ coin, price: parseNumber(data?.indexPrice) }))
                .catch((error) => ({ coin, error }));
            }));
            indexResults.forEach((result) => {
              if (result.status === 'fulfilled') {
                const { coin, price, error } = result.value;
                if (error) {
                  console.warn('Binance premiumIndex falló para', coin, error);
                  return;
                }
                if (coin && Number.isFinite(price) && price > 0) {
                  indexPrices[coin] = price;
                }
              } else if (result.reason?.coin) {
                console.warn('Binance premiumIndex falló para', result.reason.coin, result.reason.error || result.reason);
              }
            });
          }
          if (!indexPrices.USDT) indexPrices.USDT = 1;
          const assetPriceMap = assets.reduce((acc, asset) => {
            const ticker = sanitizeTicker(asset?.ticker);
            if (!ticker) return acc;
            const price = parseNumber(asset?.price);
            if (price > 0) acc[ticker] = price;
            return acc;
          }, {});
          const positions = orderRows.map((row) => {
            const loanCoin = sanitizeTicker(row?.loanCoin);
            const collateralCoin = sanitizeTicker(row?.collateralCoin);
            const totalDebt = parseNumber(row?.totalDebt ?? row?.remainingDebt ?? row?.loanAmount ?? 0);
            const borrowPrincipal = parseNumber(row?.loanAmount ?? row?.principal ?? row?.borrowAmount ?? totalDebt);
            const collateralAmount = parseNumber(row?.collateralAmount ?? row?.remainingCollateralAmount ?? row?.collateralAmt ?? 0);
            const interestAccrued = Math.max(0, totalDebt - borrowPrincipal);
            const rowAnnual = parseNullable(row?.borrowerAnnualInterestRate ?? row?.annualInterestRate ?? row?.annualRate ?? row?.apr ?? row?.loanApr);
            const rowHourly = parseNullable(row?.hourlyInterestRate ?? row?.hourlyRate ?? row?.rate);
            const rowNetAnnual = parseNullable(row?.netAnnualInterestRate ?? row?.netAnnualRate ?? row?.netApr ?? row?.netInterestRate);
            const rowNetHourly = parseNullable(row?.netHourlyInterestRate ?? row?.netHourlyRate ?? row?.netRate);
            const rowCollateralApr = parseNullable(row?.collateralApr ?? row?.collateralAPR ?? row?.collateralAnnualRate ?? row?.collateralApy ?? row?.simpleEarnAPR ?? row?.earnApr);
            const liveBorrowEntry = borrowAprByLoan[loanCoin] || {};
            const borrowRateSnapshot = borrowRatesByTicker[loanCoin] || {};
            const borrowApr = Number.isFinite(borrowRateSnapshot.annual) && borrowRateSnapshot.annual >= 0
              ? borrowRateSnapshot.annual
              : (Number.isFinite(rowAnnual)
                ? rowAnnual
                : (Number.isFinite(liveBorrowEntry.annual) ? liveBorrowEntry.annual : null));
            const borrowHourly = Number.isFinite(rowHourly)
              ? rowHourly
              : (Number.isFinite(liveBorrowEntry.hourly)
                ? liveBorrowEntry.hourly
                : (Number.isFinite(borrowApr) ? annualToHourly(borrowApr) : null));
            const vipAnnual = Number.isFinite(borrowRateSnapshot.vipAnnual) ? borrowRateSnapshot.vipAnnual : null;
            const collateralAprEntry = collateralAprMap[collateralCoin] || {};
            const collateralApr = Number.isFinite(rowCollateralApr)
              ? rowCollateralApr
              : (Number.isFinite(collateralAprEntry.apr) ? collateralAprEntry.apr : 0);
            const paramsEntry = collateralParamsMap[collateralCoin] || {};
            const rowInitialLtv = parseNullable(row?.initialLTV ?? row?.initialLtv ?? row?.collateralLTV);
            const initialLtv = Number.isFinite(rowInitialLtv) && rowInitialLtv > 0
              ? rowInitialLtv
              : (Number.isFinite(paramsEntry.initialLTV) && paramsEntry.initialLTV > 0
                ? paramsEntry.initialLTV
                : null);
            const rowMarginCall = parseNullable(row?.marginCallLTV ?? row?.marginCallLtv ?? row?.marginCall);
            const marginCall = Number.isFinite(rowMarginCall) && rowMarginCall > 0
              ? rowMarginCall
              : (Number.isFinite(paramsEntry.marginCall) && paramsEntry.marginCall > 0 ? paramsEntry.marginCall : null);
            const rowLiquidationLtv = parseNullable(row?.liquidationLTV ?? row?.liquidationLtv ?? row?.liquidation);
            const liquidation = Number.isFinite(rowLiquidationLtv) && rowLiquidationLtv > 0
              ? rowLiquidationLtv
              : (Number.isFinite(paramsEntry.liquidationLTV) && paramsEntry.liquidationLTV > 0 ? paramsEntry.liquidationLTV : null);
            const borrowIndexPrice = Number.isFinite(indexPrices[loanCoin]) && indexPrices[loanCoin] > 0 ? indexPrices[loanCoin] : 1;
            const collateralIndexPrice = Number.isFinite(indexPrices[collateralCoin]) && indexPrices[collateralCoin] > 0 ? indexPrices[collateralCoin] : (assetPriceMap[collateralCoin] ?? null);
            const rowCollateralUsd = parseNullable(row?.collateralValue ?? row?.collateralUsd ?? row?.collateralAmountInUSDT ?? row?.collateralInUsd);
            const collateralUsd = Number.isFinite(rowCollateralUsd) && rowCollateralUsd > 0
              ? rowCollateralUsd
              : (collateralIndexPrice != null ? collateralIndexPrice * collateralAmount : null);
            const rowBorrowUsd = parseNullable(row?.loanValue ?? row?.loanAmountInUSDT ?? row?.borrowUsd ?? row?.loanAmountUsd ?? row?.borrowAmountInUsd);
            const borrowUsd = Number.isFinite(rowBorrowUsd) && rowBorrowUsd > 0
              ? rowBorrowUsd
              : (borrowIndexPrice * totalDebt);
            const currentLtvApi = parseNullable(row?.currentLTV ?? row?.currentLtv);
            const ltvComputed = Number.isFinite(currentLtvApi) && currentLtvApi > 0
              ? currentLtvApi
              : (collateralUsd && collateralUsd > 0 ? borrowUsd / collateralUsd : null);
            const ltvCurrent = Number.isFinite(ltvComputed) && ltvComputed > 0
              ? ltvComputed
              : (Number.isFinite(initialLtv) && initialLtv > 0 ? initialLtv : null);
            const netAprSim = computeNetAprForPair(loanCoin, collateralCoin, ltvCurrent);
            const fallbackNetApr = Number.isFinite(borrowApr)
              ? (borrowApr - (Number.isFinite(collateralApr) && Number.isFinite(ltvCurrent) && ltvCurrent > 0 ? (collateralApr / ltvCurrent) : 0))
              : null;
            const netAprRaw = Number.isFinite(rowNetAnnual)
              ? rowNetAnnual
              : (Number.isFinite(borrowRateSnapshot.netAnnual)
                ? borrowRateSnapshot.netAnnual
                : fallbackNetApr);
            const netApr = Number.isFinite(netAprSim) ? netAprSim : (Number.isFinite(netAprRaw) ? netAprRaw : null);
            const aprOffset = Number.isFinite(borrowApr) && Number.isFinite(netApr) ? borrowApr - netApr : null;
            const netHourly = Number.isFinite(rowNetHourly)
              ? rowNetHourly
              : (Number.isFinite(netApr) ? annualToHourly(netApr) : null);
            const collateralQty = collateralAmount > 0 ? collateralAmount : parseNumber(row?.collateralQty);
            const rowLiquidationPrice = parseNullable(row?.liquidationPrice ?? row?.liquidationPriceUsd);
            const liquidationPriceFormula = Number.isFinite(liquidation) && liquidation > 0 && collateralQty > 0 && Number.isFinite(borrowUsd) && borrowUsd > 0
              ? borrowUsd / (collateralQty * liquidation)
              : null;
            const liquidationPrice = Number.isFinite(liquidationPriceFormula)
              ? liquidationPriceFormula
              : (Number.isFinite(rowLiquidationPrice) && rowLiquidationPrice > 0 ? rowLiquidationPrice : null);
            const rowMarginCallPrice = parseNullable(row?.marginCallPrice ?? row?.marginCallPriceUsd);
            const marginCallPriceFormula = Number.isFinite(marginCall) && marginCall > 0 && collateralQty > 0 && Number.isFinite(borrowUsd) && borrowUsd > 0
              ? borrowUsd / (collateralQty * marginCall)
              : null;
            const marginCallPrice = Number.isFinite(marginCallPriceFormula)
              ? marginCallPriceFormula
              : (Number.isFinite(rowMarginCallPrice) && rowMarginCallPrice > 0 ? rowMarginCallPrice : null);
            const collateralPriceForEtb = collateralIndexPrice != null
              ? collateralIndexPrice
              : (collateralAmount > 0 && Number.isFinite(collateralUsd) ? collateralUsd / collateralAmount : null);
            const etb = Number.isFinite(initialLtv) && initialLtv > 0 && collateralQty > 0 && collateralPriceForEtb != null && Number.isFinite(borrowUsd)
              ? Math.max(0, collateralQty * collateralPriceForEtb * initialLtv - borrowUsd)
              : null;
            const borrowAprValue = Number.isFinite(borrowApr) ? borrowApr : null;
            const borrowHourlyValue = Number.isFinite(borrowHourly)
              ? borrowHourly
              : (Number.isFinite(borrowAprValue) ? annualToHourly(borrowAprValue) : null);
            const netAprValue = Number.isFinite(netApr) ? netApr : null;
            const netHourlyValue = Number.isFinite(netHourly)
              ? netHourly
              : (Number.isFinite(netAprValue) ? annualToHourly(netAprValue) : null);
            const createdTime = parseNumber(row?.createdTime ?? row?.createTime ?? row?.loanDate);
            return {
              loanCoin,
              collateralCoin,
              totalDebt,
              borrowPrincipal,
              collateralAmount,
              interestAccrued,
              borrowApr: borrowAprValue,
              borrowHourly: Number.isFinite(borrowHourlyValue) ? borrowHourlyValue : null,
              collateralApr,
              initialLtv,
              marginCallLtv: marginCall,
              liquidationLtv: liquidation,
              indexPrices: { borrow: borrowIndexPrice, collateral: collateralIndexPrice },
              collateralUsd,
              borrowUsd,
              ltvComputed,
              currentLtvApi,
              ltvCurrent,
              vipAnnual,
              netApr: netAprValue,
              aprOffset,
              netHourly: Number.isFinite(netHourlyValue) ? netHourlyValue : null,
              liquidationPrice,
              marginCallPrice,
              etb,
              updatedAt: serverTime,
              createdTime,
            };
          });
          const aggregate = positions.reduce((acc, pos) => {
            const debtUsd = Number.isFinite(pos.borrowUsd) ? pos.borrowUsd : 0;
            const collateralUsd = Number.isFinite(pos.collateralUsd) ? pos.collateralUsd : 0;
            acc.borrowUsd += debtUsd;
            acc.collateralUsd += collateralUsd;
            if (debtUsd > 0 && Number.isFinite(pos.borrowApr)) {
              acc.borrowAprSum += pos.borrowApr * debtUsd;
            }
            if (debtUsd > 0 && Number.isFinite(pos.netApr)) {
              acc.netAprSum += pos.netApr * debtUsd;
            }
            return acc;
          }, { borrowUsd: 0, collateralUsd: 0, borrowAprSum: 0, netAprSum: 0 });
          const aggregateLtv = aggregate.collateralUsd > 0 ? aggregate.borrowUsd / aggregate.collateralUsd : null;
          const aggregateBorrowApr = aggregate.borrowUsd > 0 ? aggregate.borrowAprSum / aggregate.borrowUsd : null;
          const aggregateNetApr = aggregate.borrowUsd > 0 ? aggregate.netAprSum / aggregate.borrowUsd : null;
          const loanLedger = positions.reduce((acc, pos) => {
            const key = pos.collateralCoin;
            if (!key) return acc;
            acc[key] = {
              originalPrincipal: pos.borrowPrincipal,
              outstanding: pos.totalDebt,
              interestAccrued: pos.interestAccrued,
              annualRate: pos.borrowApr,
              netAnnualRate: pos.netApr,
              vipAnnualRate: Number.isFinite(pos.vipAnnual) ? pos.vipAnnual : null,
              liquidationLtv: pos.liquidationLtv,
              marginCallLtv: pos.marginCallLtv,
              liquidationPriceHint: pos.liquidationPrice,
              initialLtv: pos.initialLtv,
              initialCollateralValue: pos.collateralUsd,
              collateralAmount: pos.collateralAmount,
              borrowIndexPrice: pos.indexPrices.borrow,
              collateralIndexPrice: pos.indexPrices.collateral,
              currentLtv: pos.ltvComputed ?? pos.currentLtvApi ?? null,
              ltvCurrent: Number.isFinite(pos.ltvCurrent) ? pos.ltvCurrent : (pos.ltvComputed ?? pos.currentLtvApi ?? null),
              etb: Number.isFinite(pos.etb) ? pos.etb : null,
              loanCoin: pos.loanCoin,
              lastUpdated: new Date(serverTime).toISOString().slice(0, 10),
              lastUpdatedTs: serverTime,
            };
            return acc;
          }, {});
          if (markBinanceCancelled()) {
            return null;
          }
          setBinanceLive({
            borrowApr: borrowAprByLoan,
            collateralApr: collateralAprMap,
            collateralParams: collateralParamsMap,
            indexPrices,
            positions,
            loanLedger,
            aggregate: {
              borrowUsd: aggregate.borrowUsd,
              collateralUsd: aggregate.collateralUsd,
              ltv: aggregateLtv,
              averageBorrowApr: aggregateBorrowApr,
              averageNetApr: aggregateNetApr,
            },
            serverTime,
            clockSkew,
          });
          const updatedAt = Date.now();
          setBinanceLiveMeta({
            loading: false,
            error: null,
            lastUpdated: updatedAt,
            lastAttempt: updatedAt,
            status: 'ok',
          });
          resetBinanceTimer();
          const base = BINANCE_INTEREST_REFRESH_MS;
          let nextServerTarget = Math.ceil(serverTime / base) * base;
          if (nextServerTarget - serverTime < base) {
            nextServerTarget += base;
          }
          const delay = Math.max(base, nextServerTarget - serverTime);
          binanceTimerRef.current = setTimeout(() => {
            triggerBinanceFetch('auto').catch(() => {});
          }, delay);
          return { serverTime, clockSkew };
        } catch (error) {
          if (markBinanceCancelled()) {
            return null;
          }
          let message = error?.message || error || 'Error desconocido al sincronizar Binance.';
          if (typeof message === 'string' && /failed to fetch/i.test(message)) {
            message = 'No se pudo conectar con Binance. Revisa tu conexión o si la API permite solicitudes desde el navegador.';
          }
          setBinanceLiveMeta((prev) => ({
            ...prev,
            loading: false,
            error: message,
            status: 'error',
            lastAttempt: Date.now(),
          }));
          resetBinanceTimer();
          binanceTimerRef.current = setTimeout(() => {
            triggerBinanceFetch('retry').catch(() => {});
          }, BINANCE_INTEREST_REFRESH_MS);
          return null;
        }
      }, [isBinance, params.binanceApiKey, params.binanceApiSecret, params.binanceBorrowTicker, assets, loanRequests, liveBorrowPositions, sanitizeTicker, resetBinanceTimer, borrowRatesByTicker]);

      useEffect(() => {
        if (!isBinance) {
          resetBinanceTimer();
          setBinanceLiveMeta((prev) => ({ ...prev, loading: false, status: 'idle' }));
          return undefined;
        }
        const apiKey = (params.binanceApiKey || '').trim();
        const apiSecret = (params.binanceApiSecret || '').trim();
        if (!apiKey || !apiSecret) {
          resetBinanceTimer();
          setBinanceLiveMeta((prev) => ({ ...prev, loading: false, status: apiKey || apiSecret ? 'incomplete' : 'missing', error: null }));
          return undefined;
        }
        binanceCancelRef.current = false;
        triggerBinanceFetch('init').catch(() => {});
        return () => {
          binanceCancelRef.current = true;
          resetBinanceTimer();
        };
      }, [isBinance, params.binanceApiKey, params.binanceApiSecret, triggerBinanceFetch, resetBinanceTimer]);

      const [fxMeta, setFxMeta] = useState({ loading: false, lastUpdated: null, error: null });

      const fetchOfficialFxRates = useCallback(async () => {
        setFxMeta((prev) => ({ ...prev, loading: true, error: null }));
        try {
          const symbols = FX_SYMBOLS.join(',');
          let ratesPayload = {};
          if (symbols) {
            const res = await fetch(`https://api.exchangerate.host/latest?base=USDT&symbols=${symbols}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            ratesPayload = await res.json();
          }
          const rawRates = ratesPayload?.rates && typeof ratesPayload.rates === 'object' ? ratesPayload.rates : {};
          let usdPerUsdt = Number(rawRates?.USD);
          if (!(Number.isFinite(usdPerUsdt) && usdPerUsdt > 0)) {
            usdPerUsdt = null;
          }
          try {
            const usdtRes = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=tether&vs_currencies=usd');
            if (usdtRes.ok) {
              const usdtData = await usdtRes.json();
              const usdtUsd = Number(usdtData?.tether?.usd);
              if (Number.isFinite(usdtUsd) && usdtUsd > 0) {
                usdPerUsdt = usdtUsd;
              }
            }
          } catch {}
          const normalizedRates = {};
          if (Number.isFinite(usdPerUsdt) && usdPerUsdt > 0) {
            Object.entries(rawRates).forEach(([code, perUsdt]) => {
              if (code === 'USD' || code === 'USDT') return;
              const value = Number(perUsdt);
              if (Number.isFinite(value) && value > 0) {
                normalizedRates[code] = value / usdPerUsdt;
              }
            });
          }
          const nextRates = sanitizeExchangeRates(normalizedRates);
          if (Number.isFinite(usdPerUsdt) && usdPerUsdt > 0) {
            nextRates.USDT = 1 / usdPerUsdt;
          }
          setParams((prev) => ({
            ...prev,
            exchangeRates: nextRates,
          }));
          setFxMeta({ loading: false, lastUpdated: Date.now(), error: null });
        } catch (error) {
          setFxMeta((prev) => ({
            ...prev,
            loading: false,
            error: String(error?.message || error || 'Error desconocido'),
          }));
        }
      }, [sanitizeExchangeRates, setParams]);

      const [cashflowPlan, setCashflowPlan] = useState(() => {
        if (typeof window === 'undefined') return baseCashflowPlan;
        try {
          const saved = localStorage.getItem(storageKeys.cashflow);
          if (saved) {
            return sanitizeCashflowPlan(JSON.parse(saved), previewSnapshot?.repayDate || todayISO());
          }
        } catch {}
        return baseCashflowPlan;
      });
      const [cashflowOriginKey, setCashflowOriginKey] = useState(storageKeys.cashflow);

      const [benchmarkConfig, setBenchmarkConfig] = useState(() => {
        if (typeof window === 'undefined') return baseBenchmarkConfig;
        try {
          const saved = localStorage.getItem(storageKeys.benchmark);
          if (saved) {
            return sanitizeBenchmarkConfig(JSON.parse(saved));
          }
        } catch {}
        return baseBenchmarkConfig;
      });
      const [benchmarkOriginKey, setBenchmarkOriginKey] = useState(storageKeys.benchmark);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        try { localStorage.setItem('spm_platform', platformId); } catch {}
      }, [platformId]);

      useEffect(() => {
        setAssets(() => {
          if (typeof window === 'undefined') {
            setAssetsOriginKey(storageKeys.assets);
            return baseAssets;
          }
          try {
            const saved = localStorage.getItem(storageKeys.assets);
            if (saved) {
              const parsed = sanitizeAssets(JSON.parse(saved));
              setAssetsOriginKey(storageKeys.assets);
              return parsed;
            }
          } catch {}
          setAssetsOriginKey(storageKeys.assets);
          return baseAssets;
        });
      }, [storageKeys.assets, baseAssets]);

      useEffect(() => {
        setParams(() => {
          if (typeof window === 'undefined') {
            setParamsOriginKey(storageKeys.params);
            return baseParams;
          }
          try {
            const saved = localStorage.getItem(storageKeys.params);
            if (saved) {
              const parsed = sanitizeParams(JSON.parse(saved));
              setParamsOriginKey(storageKeys.params);
              return parsed;
            }
          } catch {}
          setParamsOriginKey(storageKeys.params);
          return baseParams;
        });
      }, [storageKeys.params, baseParams, platformId]);

      useEffect(() => {
        fetchOfficialFxRates();
      }, [fetchOfficialFxRates]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (assetsOriginKey !== storageKeys.assets) return;
        try { localStorage.setItem(storageKeys.assets, JSON.stringify(assets)); } catch {}
      }, [assets, storageKeys.assets, assetsOriginKey]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (paramsOriginKey !== storageKeys.params) return;
        try { localStorage.setItem(storageKeys.params, JSON.stringify(params)); } catch {}
      }, [params, storageKeys.params, paramsOriginKey]);

      const [loanDraftAmount, setLoanDraftAmount] = useState(0);
      const [repayDate, setRepayDate] = useState(() => {
        const d = new Date(); d.setDate(d.getDate() + 60); return d.toISOString().slice(0, 10);
      });
      const [selectedCurrency, setSelectedCurrency] = useState(() => {
        if (previewSnapshot?.currency) return previewSnapshot.currency;
        if (typeof previewSnapshot?.showArs === 'boolean') {
          return previewSnapshot.showArs ? 'ARS' : 'USDT';
        }
        return 'USDT';
      });
      const [lastPriceTs, setLastPriceTs] = useState(null);
      const [liveError, setLiveError] = useState(null);
      const buildLoanRequest = useCallback((amount, ticker) => ({
        id: `loan-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        amount: Math.max(0, Number(amount) || 0),
        ticker: sanitizeTicker(ticker || ''),
      }), []);
      const handleAddLoanRequest = useCallback(() => {
        if (!(loanDraftAmount > 0)) return;
        const resolvedTicker = isBinance ? (binanceBorrowTicker || borrowTickerList[0] || '') : '';
        const entry = buildLoanRequest(loanDraftAmount, resolvedTicker);
        setParams((prev) => ({
          ...prev,
          loanRequests: sanitizeLoanRequests([...(prev.loanRequests || []), entry]),
        }));
        setLoanDraftAmount(0);
      }, [loanDraftAmount, isBinance, binanceBorrowTicker, borrowTickerList, buildLoanRequest, setParams, sanitizeLoanRequests, setLoanDraftAmount]);
      const handleRemoveLoanRequest = useCallback((id) => {
        setParams((prev) => ({
          ...prev,
          loanRequests: sanitizeLoanRequests((prev.loanRequests || []).filter((item) => item.id !== id)),
        }));
      }, [setParams, sanitizeLoanRequests]);
      const handleClearLoanRequests = useCallback(() => {
        setParams((prev) => ({ ...prev, loanRequests: [] }));
        setLoanDraftAmount(0);
      }, [setParams, setLoanDraftAmount]);

      const updateCashflowPlan = (updater) => {
        setCashflowPlan((prev) => {
          const base = typeof updater === 'function' ? updater(prev) : { ...prev, ...(updater || {}) };
          return sanitizeCashflowPlan(base, repayDate);
        });
      };

      const updateBenchmarkConfig = (updater) => {
        setBenchmarkConfig((prev) => {
          const base = typeof updater === 'function' ? updater(prev) : { ...prev, ...(updater || {}) };
          return sanitizeBenchmarkConfig(base);
        });
      };

      useEffect(() => {
        setCashflowPlan(() => {
          if (typeof window === 'undefined') {
            setCashflowOriginKey(storageKeys.cashflow);
            return baseCashflowPlan;
          }
          try {
            const saved = localStorage.getItem(storageKeys.cashflow);
            if (saved) {
              const parsed = sanitizeCashflowPlan(JSON.parse(saved), repayDate);
              setCashflowOriginKey(storageKeys.cashflow);
              return parsed;
            }
          } catch {}
          setCashflowOriginKey(storageKeys.cashflow);
          return baseCashflowPlan;
        });
      }, [storageKeys.cashflow, baseCashflowPlan, repayDate]);

      useEffect(() => {
        setBenchmarkConfig(() => {
          if (typeof window === 'undefined') {
            setBenchmarkOriginKey(storageKeys.benchmark);
            return baseBenchmarkConfig;
          }
          try {
            const saved = localStorage.getItem(storageKeys.benchmark);
            if (saved) {
              const parsed = sanitizeBenchmarkConfig(JSON.parse(saved));
              setBenchmarkOriginKey(storageKeys.benchmark);
              return parsed;
            }
          } catch {}
          setBenchmarkOriginKey(storageKeys.benchmark);
          return baseBenchmarkConfig;
        });
      }, [storageKeys.benchmark, baseBenchmarkConfig]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (cashflowOriginKey !== storageKeys.cashflow) return;
        try { localStorage.setItem(storageKeys.cashflow, JSON.stringify(cashflowPlan)); } catch {}
      }, [cashflowPlan, storageKeys.cashflow, cashflowOriginKey]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (benchmarkOriginKey !== storageKeys.benchmark) return;
        try { localStorage.setItem(storageKeys.benchmark, JSON.stringify(benchmarkConfig)); } catch {}
      }, [benchmarkConfig, storageKeys.benchmark, benchmarkOriginKey]);

      const currency = selectedCurrency;
      const usdRate = params.exchangeRates?.[currency] ?? 1;
      const usdtPerUsdRaw = Number(params.exchangeRates?.USDT);
      const usdPerUsdt = Number.isFinite(usdtPerUsdRaw) && usdtPerUsdRaw > 0 ? 1 / usdtPerUsdRaw : 1;
      const loanRate = usdRate * usdPerUsdt;
      const formatUsd = useCallback((value, showCurrency = true) => fmt(value * usdRate, currency, showCurrency), [usdRate, currency]);
      const formatLoan = useCallback((value, showCurrency = true) => fmt(value * loanRate, currency, showCurrency), [loanRate, currency]);
      const simCalibrate = useCallback((points = []) => {
        if (!isBinance) {
          console.warn('[sim-calibrate] Disponible solo para Binance Loans');
          return [];
        }
        const list = Array.isArray(points) ? points : [points];
        if (!list.length) {
          console.warn('[sim-calibrate] No se recibieron puntos para calibrar');
          return [];
        }
        const biasUpdates = {};
        const results = [];
        list.forEach((point, idx) => {
          const ticker = sanitizeTicker(point?.asset);
          if (!ticker) {
            results.push({ index: idx, error: 'asset inválido' });
            return;
          }
          const snapshot = calibrationSnapshot[ticker];
          const modelLiq = snapshot?.modelLiq;
          if (!(Number.isFinite(modelLiq) && modelLiq > 0)) {
            results.push({ ticker, error: 'modelLiq ausente' });
            return;
          }
          const qty = Number(point?.qtyCol);
          const observedPrice = Number(point?.observedPLiq);
          const debtLoan = Number(point?.debtLoan);
          if (!(Number.isFinite(qty) && qty > 0 && Number.isFinite(observedPrice) && observedPrice > 0 && Number.isFinite(debtLoan) && debtLoan > 0)) {
            results.push({ ticker, error: 'datos inválidos' });
            return;
          }
          const loanTicker = sanitizeTicker(point?.loan || snapshot?.loanAsset || 'USDT');
          const exchangeRates = params.exchangeRates || {};
          let usdPerUnit = 1;
          const rate = exchangeRates[loanTicker];
          if (Number.isFinite(rate) && rate > 0) {
            usdPerUnit = 1 / rate;
          } else if (loanTicker === 'USDT') {
            usdPerUnit = usdPerUsdt || 1;
          }
          const debtUsd = debtLoan * usdPerUnit;
          const denom = qty * observedPrice;
          if (!(denom > 0 && debtUsd > 0)) {
            results.push({ ticker, error: 'denominador inválido' });
            return;
          }
          const observedLiqLtv = debtUsd / denom;
          const rawBias = (observedLiqLtv / modelLiq) - 1;
          const bias = clampValue(rawBias, -0.1, 0.1);
          biasUpdates[ticker] = bias;
          results.push({ ticker, bias, observedLiqLtv, modelLiq, debtUsd, qty, observedPrice, loanTicker });
        });
        if (Object.keys(biasUpdates).length === 0) {
          console.warn('[sim-calibrate] Ningún punto válido para calibrar', results);
          return results;
        }
        const updatedAt = new Date().toISOString();
        setSimModelConfig((prev) => {
          const base = prev && typeof prev === 'object' ? { ...prev } : createDefaultSimModelConfig();
          const prevBias = base.liquidationBias && typeof base.liquidationBias === 'object' ? base.liquidationBias : {};
          base.liquidationBias = { ...prevBias, ...biasUpdates };
          base.updatedAt = updatedAt;
          if (!base.version) base.version = 1;
          return base;
        });
        if (typeof console !== 'undefined') {
          const hasGroupCollapsed = typeof console.groupCollapsed === 'function';
          const hasGroup = typeof console.group === 'function';
          if (hasGroupCollapsed) {
            console.groupCollapsed('[sim-calibrate] ajustes aplicados');
          } else if (hasGroup) {
            console.group('[sim-calibrate] ajustes aplicados');
          }
          results.forEach((row) => {
            if (row.error) {
              console.warn(`[${row.ticker || '??'}] ${row.error}`);
            } else {
              console.log(
                `[${row.ticker}] bias=${(row.bias * 100).toFixed(2)}% model=${row.modelLiq.toFixed(4)} observed=${row.observedLiqLtv.toFixed(4)} debtUSD=${row.debtUsd.toFixed(2)}`
              );
            }
          });
          console.log('Actualizado', { updatedAt, biasUpdates });
          if ((hasGroupCollapsed || hasGroup) && typeof console.groupEnd === 'function') {
            console.groupEnd();
          }
        }
        return results;
      }, [isBinance, calibrationSnapshot, params.exchangeRates, usdPerUsdt, sanitizeTicker, setSimModelConfig]);
      useEffect(() => {
        if (typeof window === 'undefined') return undefined;
        window.simCalibrate = simCalibrate;
        console.info('[sim-calibrate] listo: window.simCalibrate(points)');
        return () => {
          if (window.simCalibrate === simCalibrate) {
            delete window.simCalibrate;
          }
        };
      }, [simCalibrate]);
      const loanRequestsTotals = useMemo(() => {
        const totals = {};
        loanRequests.forEach((item) => {
          const ticker = sanitizeTicker(item.ticker || '');
          if (!ticker) return;
          totals[ticker] = (totals[ticker] || 0) + item.amount;
        });
        if (Object.keys(totals).length === 0 && isBinance) {
          Object.entries(baseLoanLedger).forEach(([ticker, entry = {}]) => {
            const amount = Math.max(0, Number(entry.outstanding) || 0);
            if (!(amount > 0)) return;
            totals[ticker] = amount;
          });
        }
        return totals;
      }, [loanRequests, isBinance, baseLoanLedger]);
      const loanAmount = useMemo(
        () => Object.values(loanRequestsTotals).reduce((acc, amount) => acc + (Number(amount) || 0), 0),
        [loanRequestsTotals]
      );
      const loanAmountUsd = loanAmount * usdPerUsdt;
      const binanceLoanLedger = useMemo(() => {
        if (!isBinance) return {};
        const clone = Object.entries(baseLoanLedger).reduce((acc, [ticker, entry]) => {
          acc[ticker] = {
            ...entry,
            payments: Array.isArray(entry?.payments) ? entry.payments.map((p) => ({ ...p })) : [],
          };
          return acc;
        }, {});
        const now = nowTs;
        const tickers = new Set([...Object.keys(clone), ...Object.keys(loanRequestsTotals)]);
        tickers.forEach((ticker) => {
          const key = sanitizeTicker(ticker);
          if (!key) return;
          const requestedOutstanding = Math.max(0, Number(loanRequestsTotals[key]) || 0);
          const current = clone[key] || { payments: [], paidTotal: 0, interestAccrued: 0, originalPrincipal: requestedOutstanding };
          const payments = Array.isArray(current.payments) ? current.payments.map((p) => ({ ...p })) : [];
          const paidFromEntry = Number(current.paidTotal);
          const paidTotal = Number.isFinite(paidFromEntry) && paidFromEntry > 0
            ? paidFromEntry
            : payments.reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
          let recordedOutstanding = Number.isFinite(current.outstanding) && current.outstanding > 0
            ? Math.max(0, Number(current.outstanding))
            : 0;
          if (requestedOutstanding > 0) {
            recordedOutstanding = requestedOutstanding;
          }
          const baseInterestRaw = Number(current.interestAccrued);
          const baseOriginal = current.originalPrincipal > 0
            ? current.originalPrincipal
            : Math.max(0, recordedOutstanding + paidTotal - (Number.isFinite(baseInterestRaw) ? Math.max(0, baseInterestRaw) : 0));
          const principalOutstanding = Math.max(0, baseOriginal - paidTotal);
          if (!(recordedOutstanding > 0) && principalOutstanding > 0) {
            recordedOutstanding = principalOutstanding + Math.max(0, baseInterestRaw || 0);
          }
          const baseInterest = Number.isFinite(baseInterestRaw) && baseInterestRaw >= 0
            ? Math.min(Math.max(0, baseInterestRaw), recordedOutstanding)
            : Math.max(0, recordedOutstanding - principalOutstanding);
          const borrowInfo = borrowRatesByTicker[key] || {};
          const annualRate = Number.isFinite(current.annualRate) && current.annualRate > 0
            ? current.annualRate
            : (Number.isFinite(borrowInfo.annual) && borrowInfo.annual > 0 ? borrowInfo.annual : null);
          const netAnnualRate = Number.isFinite(current.netAnnualRate) && current.netAnnualRate >= 0
            ? current.netAnnualRate
            : (Number.isFinite(borrowInfo.netAnnual) && borrowInfo.netAnnual >= 0
              ? borrowInfo.netAnnual
              : (Number.isFinite(borrowInfo.annual) && borrowInfo.annual > 0 ? borrowInfo.annual : (annualRate ?? 0)));
          const hourlyRate = Number.isFinite(borrowInfo.hourly) && borrowInfo.hourly > 0
            ? borrowInfo.hourly
            : (Number.isFinite(current.hourlyRate) && current.hourlyRate > 0
              ? current.hourlyRate
              : annualToHourly(annualRate || 0));
          const lastUpdatedDate = coerceDateValue(current.lastUpdated) || coerceDateValue(current.borrowDate);
          const hoursElapsed = lastUpdatedDate ? Math.max(0, (now - lastUpdatedDate.getTime()) / MS_IN_HOUR) : 0;
          const incrementalInterest = principalOutstanding > 0 && hourlyRate > 0 && hoursElapsed > 0
            ? principalOutstanding * (Math.pow(1 + hourlyRate, hoursElapsed) - 1)
            : 0;
          const liveInterest = Math.max(0, baseInterest + incrementalInterest);
          const liveOutstanding = principalOutstanding + liveInterest;
          clone[key] = {
            ...current,
            payments,
            paidTotal,
            originalPrincipal: baseOriginal,
            principalOutstanding,
            outstanding: liveOutstanding,
            outstandingRecorded: recordedOutstanding,
            interestAccrued: liveInterest,
            interestAccruedBase: baseInterest,
            interestAccruedRealtime: Math.max(0, liveInterest - baseInterest),
            annualRate,
            netAnnualRate,
            hourlyRate,
            lastAccrualTs: now,
            accrualHoursElapsed: hoursElapsed,
          };
        });

        const planLoanByTicker = cashflowDerived?.loanByTicker;
        const planOutstandingByTicker = cashflowDerived?.outstandingByTicker;
        const scheduledPrincipalPlan = Number.isFinite(Number(cashflowDerived?.scheduledPrincipal))
          ? Math.max(0, Number(cashflowDerived.scheduledPrincipal))
          : 0;
        const scheduledInterestPlan = Number.isFinite(Number(cashflowDerived?.scheduledInterest))
          ? Math.max(0, Number(cashflowDerived.scheduledInterest))
          : 0;

        const plannedPrincipalReductions = {};
        if (planLoanByTicker && typeof planLoanByTicker === 'object' && planOutstandingByTicker && typeof planOutstandingByTicker === 'object') {
          Object.entries(planLoanByTicker).forEach(([ticker, amount]) => {
            const key = sanitizeTicker(ticker);
            if (!key) return;
            const before = Math.max(0, Number(amount) || 0);
            const afterRaw = planOutstandingByTicker[key] ?? planOutstandingByTicker[ticker];
            const after = Math.max(0, Number(afterRaw) || 0);
            const reduction = Math.max(0, before - after);
            if (reduction > 0) {
              plannedPrincipalReductions[key] = reduction;
            }
          });
        }
        const ledgerKeys = Object.keys(clone);
        const ledgerKeySet = new Set(ledgerKeys);
        const effectivePrincipalReductions = {};
        let unmatchedPrincipalPlan = 0;
        Object.entries(plannedPrincipalReductions).forEach(([key, value]) => {
          const safeValue = Math.max(0, Number(value) || 0);
          if (!(safeValue > 0)) return;
          if (ledgerKeySet.has(key)) {
            effectivePrincipalReductions[key] = safeValue;
          } else {
            unmatchedPrincipalPlan += safeValue;
          }
        });
        const targetedPrincipalTotal = Object.values(effectivePrincipalReductions).reduce((sum, value) => sum + value, 0);
        let remainingPrincipalPlan = Math.max(0, scheduledPrincipalPlan - targetedPrincipalTotal) + unmatchedPrincipalPlan;
        const basePrincipalTotals = ledgerKeys.reduce((sum, key) => {
          const principal = Math.max(0, Number(clone[key]?.principalOutstanding) || 0);
          return sum + principal;
        }, 0);
        const fallbackPrincipalReductions = {};
        if (remainingPrincipalPlan > 0 && basePrincipalTotals > 0) {
          ledgerKeys.forEach((key) => {
            const entry = clone[key];
            if (!entry) { fallbackPrincipalReductions[key] = 0; return; }
            const principal = Math.max(0, Number(entry.principalOutstanding) || 0);
            if (!(principal > 0)) { fallbackPrincipalReductions[key] = 0; return; }
            const share = principal / basePrincipalTotals;
            const reduction = Math.min(principal, remainingPrincipalPlan * share);
            fallbackPrincipalReductions[key] = reduction;
          });
        }

        const interestBaseTotals = ledgerKeys.reduce((sum, key) => {
          const interest = Math.max(0, Number(clone[key]?.interestAccrued) || 0);
          return sum + interest;
        }, 0);

        let remainingInterestPlan = scheduledInterestPlan;
        ledgerKeys.forEach((key) => {
          const entry = clone[key];
          if (!entry) return;
          const basePrincipal = Math.max(0, Number(entry.principalOutstanding) || 0);
          const baseInterest = Math.max(0, Number(entry.interestAccrued) || 0);
          const targetedReduction = Math.max(0, Number(effectivePrincipalReductions[key]) || 0);
          const fallbackReduction = Math.max(0, Number(fallbackPrincipalReductions[key]) || 0);
          const totalReduction = Math.min(basePrincipal, targetedReduction + fallbackReduction);
          if (totalReduction > 0) {
            entry.principalOutstanding = Math.max(0, basePrincipal - totalReduction);
            entry.paidTotal = Math.max(0, (Number(entry.paidTotal) || 0) + totalReduction);
          } else {
            entry.principalOutstanding = basePrincipal;
          }

          if (remainingInterestPlan > 0 && baseInterest > 0 && interestBaseTotals > 0) {
            const share = baseInterest / interestBaseTotals;
            const interestReduction = Math.min(baseInterest, remainingInterestPlan * share);
            entry.interestAccrued = Math.max(0, baseInterest - interestReduction);
            remainingInterestPlan -= interestReduction;
          } else {
            entry.interestAccrued = baseInterest;
          }

          entry.outstanding = Math.max(0, entry.principalOutstanding + entry.interestAccrued);
        });

        return clone;
      }, [isBinance, baseLoanLedger, loanRequestsTotals, borrowRatesByTicker, nowTs, cashflowDerived]);
      const binanceLedgerOutstandingTotal = useMemo(() => {
        if (!isBinance) return 0;
        return Object.values(binanceLoanLedger).reduce((acc, entry) => acc + (Math.max(0, Number(entry?.outstanding) || 0)), 0);
      }, [isBinance, binanceLoanLedger]);
      const binanceLedgerTotals = useMemo(() => {
        if (!isBinance) {
          return {
            original: 0,
            outstanding: loanAmount,
            interest: 0,
            paid: 0,
            initialCollateral: 0,
          };
        }
        return Object.entries(binanceLoanLedger).reduce((acc, [ticker, entry]) => {
          const original = Math.max(0, Number(entry?.originalPrincipal) || 0);
          const outstanding = Math.max(0, Number(entry?.outstanding) || 0);
          const interest = Math.max(0, Number(entry?.interestAccrued) || 0);
          const paid = Math.max(0, Number(entry?.paidTotal) || 0);
          const initialCollateralValue = Number(entry?.initialCollateralValue);
          const initialLtv = Number(entry?.initialLtv);
          let collateralBase = 0;
          if (Number.isFinite(initialCollateralValue) && initialCollateralValue > 0) {
            collateralBase = initialCollateralValue;
          } else if (Number.isFinite(initialLtv) && initialLtv > 0) {
            collateralBase = initialLtv > 0 ? original / initialLtv : 0;
          } else {
            const policy = ltvByTicker[ticker] ?? defaultLtv;
            collateralBase = policy > 0 ? original / policy : 0;
          }
          acc.original += original;
          acc.outstanding += outstanding;
          acc.interest += interest;
          acc.paid += paid;
          acc.initialCollateral += Number.isFinite(collateralBase) && collateralBase > 0 ? collateralBase : 0;
          if (Number.isFinite(initialLtv) && initialLtv > 0 && original > 0) {
            acc.initialLtvWeightedSum += original * initialLtv;
            acc.initialLtvWeight += original;
          }
          return acc;
        }, {
          original: 0,
          outstanding: 0,
          interest: 0,
          paid: 0,
          initialCollateral: 0,
          initialLtvWeightedSum: 0,
          initialLtvWeight: 0,
        });
      }, [isBinance, binanceLoanLedger, loanAmount, ltvByTicker, defaultLtv]);
      const binanceOriginalPrincipalTotal = binanceLedgerTotals.original;
      const binanceInterestAccruedTotal = binanceLedgerTotals.interest;
      const binanceInitialCollateralTotal = binanceLedgerTotals.initialCollateral;
      const binanceInitialLtvWeighted = binanceLedgerTotals.initialLtvWeight > 0
        ? binanceLedgerTotals.initialLtvWeightedSum / binanceLedgerTotals.initialLtvWeight
        : null;
      const binanceTotalToRepay = Math.max(0, binanceOriginalPrincipalTotal + binanceInterestAccruedTotal);
      const binanceInitialLtv = Number.isFinite(binanceInitialLtvWeighted)
        ? binanceInitialLtvWeighted
        : (binanceInitialCollateralTotal > 0
          ? binanceOriginalPrincipalTotal / binanceInitialCollateralTotal
          : 0);
      const pct = (value, digits = 1) => formatPercent(Number(value), {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits,
      });

      const tickerToId = (ticker) => {
        const key = sanitizeTicker(ticker);
        return coingeckoIds[key] ?? globalCoingeckoIds[key] ?? BASE_GLOBAL_COINGECKO_IDS[key];
      };

      const tickersKey = useMemo(() => assets.filter(a=>a.priceAuto!==false).map(a=>sanitizeTicker(a.ticker)).sort().join(','), [assets]);

      const inFlight = useRef(false);
      const importInputRef = useRef(null);
      const exportMenuRef = useRef(null);
      const autoMasterRef = useRef(null);
      const collateralMasterRef = useRef(null);
      const [exportMenuOpen, setExportMenuOpen] = useState(false);
      async function fetchLivePricesNow(force = false) {
        try {
          if (inFlight.current) return; inFlight.current = true;
          setLiveError(null);
          if (!params.liveQuotes && !force) { inFlight.current = false; return; }
          const ids = Array.from(new Set(assets.filter(a => a.priceAuto !== false).map(a => tickerToId(a.ticker)).filter(Boolean)));
          if (!ids.length) { setLastPriceTs(Date.now()); inFlight.current = false; return; }
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
        finally { inFlight.current = false; }
      }

      async function fetchPricesForTickers(tickers = []) {
        try {
          if (!params.liveQuotes) return;
          const ids = Array.from(new Set(tickers.map(tickerToId).filter(Boolean)));
          if (!ids.length) return;
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
      }

      const closeExportMenu = () => setExportMenuOpen(false);

      const handleExportJSON = () => {
        const blob = new Blob([JSON.stringify({ assets, params, cashflowPlan, benchmarkConfig }, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${exportPrefix}_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        closeExportMenu();
      };

      const handleImportRequest = () => {
        closeExportMenu();
        importInputRef.current?.click();
      };

      const handleResetParams = () => {
        if (confirm("¿Restablecer parámetros por defecto?")) {
          localStorage.removeItem(storageKeys.params);
          setParams({ ...baseParams });
          setParamsOriginKey(storageKeys.params);
          setLoanDraftAmount(0);
        }
        closeExportMenu();
      };

      const handleResetAssets = () => {
        if (confirm("¿Restablecer activos por defecto?")) {
          localStorage.removeItem(storageKeys.assets);
          setAssets(sanitizeAssets(platformDefaultAssets));
          setAssetsOriginKey(storageKeys.assets);
        }
        closeExportMenu();
      };

      const handleToggleAllAuto = (checked) => {
        const nextTickers = checked
          ? Array.from(new Set(assets.map((asset) => sanitizeTicker(asset.ticker)).filter(Boolean)))
          : [];
        setAssets((prev) => prev.map((asset) => ({ ...asset, priceAuto: checked })));
        if (checked && nextTickers.length) {
          fetchPricesForTickers(nextTickers);
        }
      };

      const handleToggleAllCollateral = (checked) => {
        setAssets((prev) => prev.map((asset) => ({ ...asset, useAsCollateral: checked })));
      };

      const handleResetPlanners = () => {
        if (confirm("¿Limpiar plan de cashflow y benchmark?")) {
          localStorage.removeItem(storageKeys.cashflow);
          localStorage.removeItem(storageKeys.benchmark);
          setCashflowPlan(baseCashflowPlan);
          setBenchmarkConfig(baseBenchmarkConfig);
          setCashflowOriginKey(storageKeys.cashflow);
          setBenchmarkOriginKey(storageKeys.benchmark);
        }
        closeExportMenu();
      };

      const handleImportFile = (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        file.text()
          .then((text) => {
            try {
              const parsed = JSON.parse(text);
              if (parsed.assets) {
                setAssets(sanitizeAssets(parsed.assets));
                setAssetsOriginKey(storageKeys.assets);
              }
              if (parsed.params) {
                setParams(sanitizeParams(parsed.params));
                setParamsOriginKey(storageKeys.params);
              }
              if (parsed.cashflowPlan) {
                setCashflowPlan(sanitizeCashflowPlan(parsed.cashflowPlan, repayDate));
                setCashflowOriginKey(storageKeys.cashflow);
              }
              if (parsed.benchmarkConfig) {
                setBenchmarkConfig(sanitizeBenchmarkConfig(parsed.benchmarkConfig));
                setBenchmarkOriginKey(storageKeys.benchmark);
              }
            } catch (err) {
              alert(`No se pudo importar el archivo: ${err?.message || err}`);
            }
          })
          .finally(() => {
            if (importInputRef.current) importInputRef.current.value = '';
          });
      };

      useEffect(() => {
        if (!exportMenuOpen) return;
        if (typeof document === 'undefined') return;
        const handleClick = (event) => {
          if (!exportMenuRef.current) return;
          if (exportMenuRef.current.contains(event.target)) return;
          closeExportMenu();
        };
        const handleKey = (event) => {
          if (event.key === 'Escape') closeExportMenu();
        };
        document.addEventListener('mousedown', handleClick);
        document.addEventListener('keydown', handleKey);
        return () => {
          document.removeEventListener('mousedown', handleClick);
          document.removeEventListener('keydown', handleKey);
        };
      }, [exportMenuOpen]);

      useEffect(() => {
        if (!params.liveQuotes) return;
        fetchLivePricesNow();
        const sec = Math.max(LIVE_REFRESH_SECONDS, Number(params.refreshSec || LIVE_REFRESH_SECONDS));
        const t = setInterval(fetchLivePricesNow, sec * 1000);
        return () => clearInterval(t);
      }, [params.liveQuotes, params.refreshSec, tickersKey]);

      const loyaltyTicker = loyalty?.tokenTicker ? sanitizeTicker(loyalty.tokenTicker) : null;

      const totals = useMemo(() => {
        const withValue = assets.map((a, idx) => {
          const ticker = sanitizeTicker(a.ticker);
          const qty = toNumber(a.qty);
          const price = toNumber(a.price);
          const value = qty * price;
          const ltv = ltvByTicker[ticker] ?? a.ltv ?? defaultLtv;
          const loanAssigned = Math.max(0, toNumber(a.loanAssigned));
          return { ...a, ticker, qty, price, value, ltv, loanAssigned, useAsCollateral: a.useAsCollateral !== false };
        });
        const total = withValue.reduce((acc, a) => acc + a.value, 0);
        const totalLoyalty = loyaltyTicker ? withValue.filter(a => a.ticker === loyaltyTicker).reduce((acc, a) => acc + a.value, 0) : 0;
        const rest = total - totalLoyalty;
        const ratioVsRest = rest > 0 ? (totalLoyalty / rest) : (totalLoyalty > 0 ? Number.POSITIVE_INFINITY : 0);
        const ratioVsTotal = total > 0 ? (totalLoyalty / total) : 0;
        const collaterals = withValue.filter(a => a.useAsCollateral);
        const totalCollateralValue = collaterals.reduce((acc, a) => acc + a.value, 0);
        const maxBorrow = collaterals.reduce((acc, a) => acc + a.value * ((ltvByTicker[a.ticker] ?? a.ltv ?? defaultLtv) || 0), 0);
        return { withValue, total, totalLoyalty, rest, ratioVsRest, ratioVsTotal, totalCollateralValue, maxBorrow };
      }, [assets, loyaltyTicker, ltvByTicker, defaultLtv]);

      const allAuto = assets.length > 0 && assets.every((asset) => asset.priceAuto !== false);
      const someAuto = assets.some((asset) => asset.priceAuto !== false);
      const allCollateral = assets.length > 0 && assets.every((asset) => asset.useAsCollateral);
      const someCollateral = assets.some((asset) => asset.useAsCollateral);

      const binanceBorrowTicker = useMemo(() => {
        if (!isBinance) return null;
        const candidate = sanitizeTicker(params.binanceBorrowTicker);
        if (candidate && borrowRatesByTicker[candidate]) return candidate;
        return borrowTickerList[0] || null;
      }, [isBinance, params.binanceBorrowTicker, borrowRatesByTicker, borrowTickerList]);
      const binanceBorrowInfo = binanceBorrowTicker ? borrowRatesByTicker[binanceBorrowTicker] : null;
      const binanceActiveLoanEntries = useMemo(() => {
        if (!isBinance) return [];
        return Object.entries(loanRequestsTotals).filter(([, amount]) => amount > 0);
      }, [isBinance, loanRequestsTotals]);
      const binanceBorrowAnnualRate = useMemo(() => {
        if (!isBinance) return 0;
        if (Number.isFinite(binanceAggregate?.averageBorrowApr)) {
          return binanceAggregate.averageBorrowApr;
        }
        if (loanAmount > 0 && binanceActiveLoanEntries.length > 0) {
          return binanceActiveLoanEntries.reduce((acc, [ticker, amount]) => {
            const info = borrowRatesByTicker[ticker];
            const rate = info?.annual ?? binanceBorrowInfo?.annual ?? 0;
            return acc + rate * (amount / loanAmount);
          }, 0);
        }
        return binanceBorrowInfo?.annual ?? 0;
      }, [isBinance, loanAmount, binanceActiveLoanEntries, borrowRatesByTicker, binanceBorrowInfo, binanceAggregate?.averageBorrowApr]);
      const binanceBorrowNetAnnualRate = useMemo(() => {
        if (!isBinance) return 0;
        if (Number.isFinite(binanceAggregate?.averageNetApr)) {
          return binanceAggregate.averageNetApr;
        }
        if (loanAmount > 0 && binanceActiveLoanEntries.length > 0) {
          return binanceActiveLoanEntries.reduce((acc, [ticker, amount]) => {
            const info = borrowRatesByTicker[ticker];
            const net = info?.netAnnual ?? info?.annual ?? binanceBorrowInfo?.netAnnual ?? binanceBorrowInfo?.annual ?? 0;
            return acc + net * (amount / loanAmount);
          }, 0);
        }
        return binanceBorrowInfo?.netAnnual ?? binanceBorrowInfo?.annual ?? 0;
      }, [isBinance, loanAmount, binanceActiveLoanEntries, borrowRatesByTicker, binanceBorrowInfo, binanceAggregate?.averageNetApr]);
      const binanceBorrowAdjustment = useMemo(
        () => Math.max(0, binanceBorrowAnnualRate - binanceBorrowNetAnnualRate),
        [binanceBorrowAnnualRate, binanceBorrowNetAnnualRate]
      );
      const binanceBorrowLabel = useMemo(() => {
        if (!isBinance) return null;
        if (binanceActiveLoanEntries.length === 0) {
          return binanceBorrowInfo?.label || (binanceBorrowTicker || null);
        }
        if (binanceActiveLoanEntries.length === 1) {
          const [ticker] = binanceActiveLoanEntries[0];
          return borrowRatesByTicker[ticker]?.label || ticker;
        }
        const tickers = binanceActiveLoanEntries.map(([ticker]) => ticker).join(', ');
        return `${binanceActiveLoanEntries.length} criptos (${tickers})`;
      }, [isBinance, binanceActiveLoanEntries, borrowRatesByTicker, binanceBorrowInfo, binanceBorrowTicker]);

      useEffect(() => {
        if (autoMasterRef.current) {
          autoMasterRef.current.indeterminate = !allAuto && someAuto;
        }
      }, [allAuto, someAuto]);

      useEffect(() => {
        if (collateralMasterRef.current) {
          collateralMasterRef.current.indeterminate = !allCollateral && someCollateral;
        }
      }, [allCollateral, someCollateral]);

      const loyaltyModelActive = params.loyaltyModel ?? loyaltyModelFallback;

      const loyaltyTier = useMemo(() => {
        if (!loyalty) return aprConfig.baseTier ?? loyalty?.baseLabel ?? "—";
        if (!forceOn && totals.total < minBalancePerks) return loyalty.belowMinimumLabel ?? loyalty.baseLabel ?? "Sin perks";
        const ratioUsed = loyaltyModelActive === "vsTotal" ? totals.ratioVsTotal : totals.ratioVsRest;
        for (const tier of loyalty.tierThresholds ?? []) {
          if (ratioUsed >= tier.minRatio) return tier.label;
        }
        return loyalty.baseLabel ?? (aprConfig.baseTier ?? "Base");
      }, [loyalty, totals.total, minBalancePerks, loyaltyModelActive, totals.ratioVsTotal, totals.ratioVsRest, aprConfig.baseTier, forceOn]);

      const aprStandardTable = aprConfig.standard ?? {};
      const aprDiscountTable = aprConfig.discounted ?? aprStandardTable;
      const aprBaseTier = aprConfig.baseTier ?? (loyalty?.baseLabel ?? "Base");
      const aprBase = aprConfig.base ?? aprStandardTable[aprBaseTier] ?? aprStandardTable[loyalty?.baseLabel] ?? 0.20;
      const lowCostEligibleTiers = aprConfig.lowCostEligibleTiers ?? loyalty?.lowCostEligibleTiers ?? [];
      const earlyRuleDays = aprConfig.earlyRuleDays ?? 45;
      const earlyAPR = aprConfig.earlyAPR ?? aprBase;

      const recommendedLoanAtTarget = useMemo(() => targetLtv * totals.totalCollateralValue, [targetLtv, totals.totalCollateralValue]);
      const capLowCost = useMemo(() => Math.min(recommendedLoanAtTarget, totals.maxBorrow), [recommendedLoanAtTarget, totals.maxBorrow]);

      const chosenAPR = useMemo(() => {
        if (isBinance) {
          return binanceBorrowAnnualRate;
        }
        const table = loanAmountUsd <= recommendedLoanAtTarget ? aprDiscountTable : aprStandardTable;
        const aprFromTier = table?.[loyaltyTier];
        if (typeof aprFromTier === 'number') return aprFromTier;
        if (aprBaseTier && typeof table?.[aprBaseTier] === 'number') return table[aprBaseTier];
        if (loyalty?.baseLabel && typeof table?.[loyalty.baseLabel] === 'number') return table[loyalty.baseLabel];
        return aprBase;
      }, [isBinance, binanceBorrowAnnualRate, loanAmountUsd, recommendedLoanAtTarget, aprDiscountTable, aprStandardTable, loyaltyTier, aprBaseTier, aprBase, loyalty?.baseLabel]);

      const daysUntilRepay = useMemo(() => {
        const a = new Date(); const b = new Date(repayDate);
        const diffMs = Math.max(0, b.getTime() - a.getTime());
        return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      }, [repayDate]);

      const interestCalc = useMemo(() => {
        const P = loanAmount; const d = daysUntilRepay; const r = chosenAPR;
        const earlyDays = Math.max(0, earlyRuleDays - d);
        const main = P * (Math.pow(1 + r / 365, d) - 1);
        const early = d < earlyRuleDays ? P * (Math.pow(1 + earlyAPR / 365, earlyDays) - 1) : 0;
        const total = main + early; return { main, early, total, repayTotal: P + total };
      }, [loanAmount, daysUntilRepay, chosenAPR, earlyRuleDays, earlyAPR]);


      const earnEligible = (forceOn || totals.total >= minBalancePerks) && (forceOn || params.earnOptIn);
      const earnMonthly = useMemo(() => {
        if (!earnEligible) return 0;
        const days = 30;
        return totals.withValue.reduce((acc, a) => {
          if (!params.earnOnCollateral && a.useAsCollateral) return acc;
          const apr = earnAprTop[sanitizeTicker(a.ticker)] ?? 0;
          return acc + a.value * (Math.pow(1 + apr/365, days) - 1);
        }, 0);
      }, [earnEligible, params.earnOnCollateral, totals.withValue, earnAprTop]);

      const timeline = useMemo(() => {
        const totalDays = Math.max(1, daysUntilRepay);
        const steps = Math.max(4, Math.min(12, Math.ceil(totalDays / 20)));
        const arr = [];
        for (let i = 0; i <= steps; i++) {
          const day = (totalDays / steps) * i;
          const interest = loanAmount * (Math.pow(1 + chosenAPR / 365, day) - 1);
          let earn = 0;
          if (earnEligible) {
            earn = totals.withValue.reduce((acc, asset) => {
              if (!params.earnOnCollateral && asset.useAsCollateral) return acc;
              const apr = earnAprTop[sanitizeTicker(asset.ticker)] ?? 0;
              return acc + asset.value * (Math.pow(1 + apr / 365, day) - 1);
            }, 0);
          }
          const balance = Math.max(0, loanAmount + interest - earn);
          arr.push({ day, cost: interest, earn, balance });
        }
        return arr;
      }, [chosenAPR, daysUntilRepay, earnEligible, loanAmount, params.earnOnCollateral, totals.withValue, earnAprTop]);
      const totalEarnDuringPeriod = timeline.length ? timeline[timeline.length - 1].earn : 0;
      const adjustedEarnDuringPeriod = totalEarnDuringPeriod * aprFundingAlpha;
      const netInterestPeriod = interestCalc.total - adjustedEarnDuringPeriod;
      let standardNetAnnualRate = loanAmount > 0 && daysUntilRepay > 0 ? (Math.pow(1 + netInterestPeriod / loanAmount, 365 / daysUntilRepay) - 1) : 0;
      if (aprClampValue != null && Number.isFinite(aprClampValue)) {
        standardNetAnnualRate = Math.max(standardNetAnnualRate, aprClampValue);
      }

      const cashflowDerived = useMemo(() =>
        computeCashflowProjections(cashflowPlan, {
          loanAmount,
          apr: chosenAPR,
          repayDate,
          totalCollateralValue: totals.totalCollateralValue,
          targetLtv,
          marginCallLtv,
          autoRepayLtv,
          scenarioShocks: cashflowPlan?.scenarioShocks,
          loanByTicker: loanRequestsTotals,
          controls,
        }),
      [cashflowPlan, loanAmount, chosenAPR, repayDate, totals.totalCollateralValue, targetLtv, marginCallLtv, autoRepayLtv, loanRequestsTotals, controls]);

      const scheduledPrincipal = Math.max(0, cashflowDerived?.scheduledPrincipal || 0);
      const scheduledInterest = Math.max(0, cashflowDerived?.scheduledInterest || 0);
      const paidPrincipal = Math.min(loanAmount, scheduledPrincipal);
      const paidInterest = scheduledInterest;
      const totalPaid = Math.max(0, paidPrincipal + paidInterest);
      const hasCashflowPlanPayments = useMemo(() => {
        if (!Array.isArray(cashflowPlan?.payments)) return false;
        return cashflowPlan.payments.some((item) => {
          const amount = Number(item?.amount ?? item?.principal ?? 0);
          const interest = Number(item?.interest ?? 0);
          return (Number.isFinite(amount) && amount > 0) || (Number.isFinite(interest) && interest > 0);
        });
      }, [cashflowPlan]);
      const binancePlanPaidTotal = totalPaid;
      const binancePaidDisplayTotal = binancePlanPaidTotal;
      const binancePaidLabel = 'Pagos planificados';
      const derivedNetOutstanding = Number.isFinite(cashflowDerived?.netOutstandingAfterPlan)
        ? Math.max(0, cashflowDerived.netOutstandingAfterPlan)
        : null;
      const plannedOutstandingPrincipal = Math.max(0, cashflowDerived?.outstandingAfterPlan ?? loanAmount);
      const plannedAccruedInterest = Math.max(0, cashflowDerived?.accruedInterestAfterPlan ?? 0);
      const plannedOutstanding = derivedNetOutstanding != null
        ? derivedNetOutstanding
        : Math.max(0, plannedOutstandingPrincipal + plannedAccruedInterest);
      const binanceNetLoanValue = derivedNetOutstanding != null
        ? plannedOutstanding
        : Math.max(0, binanceOriginalPrincipalTotal + binanceInterestAccruedTotal - binancePaidDisplayTotal);
      const projectedFinalPayoff = Math.max(0, cashflowDerived?.projectedFinalPayoff || 0);
      const totalProjectedOutflows = Math.max(0, cashflowDerived?.totalCost || 0);
      const plannedCollateralDelta = cashflowDerived?.collateralDeltaPlanned ?? 0;
      const collateralAfterPlan = Math.max(0, cashflowDerived?.collateralAfterPlan ?? (totals.totalCollateralValue + plannedCollateralDelta));
      const monthlyLoanCost = useMemo(
        () => plannedOutstandingPrincipal * (Math.pow(1 + chosenAPR / 365, 30) - 1),
        [plannedOutstandingPrincipal, chosenAPR],
      );
      const lowCostHeadroom = useMemo(
        () => Math.max(0, capLowCost - plannedOutstandingPrincipal * usdPerUsdt),
        [capLowCost, plannedOutstandingPrincipal, usdPerUsdt],
      );
      const currentOverallLTV = useMemo(() => {
        if (!(totals.totalCollateralValue > 0)) return 0;
        const netLoanBase = isBinance ? binanceNetLoanValue : plannedOutstanding;
        const netLoanUsd = netLoanBase * usdPerUsdt;
        return netLoanUsd / totals.totalCollateralValue;
      }, [isBinance, binanceNetLoanValue, plannedOutstanding, totals.totalCollateralValue, usdPerUsdt]);
      const plannedOverallLTV = collateralAfterPlan > 0 && Number.isFinite(plannedOutstanding)
        ? (plannedOutstanding * usdPerUsdt) / collateralAfterPlan
        : (plannedOutstanding > 0 ? 1 : 0);
      const ltvProjectedValue = Number.isFinite(cashflowDerived?.ltvForGauge) ? Math.max(0, cashflowDerived.ltvForGauge) : plannedOverallLTV;
      const ltvGaugeValue = currentOverallLTV;
      const ltvScenarioLabel = cashflowDerived?.scenarioLabel;
      const cashflowAlerts = useMemo(
        () => normalizeAlertItems(cashflowDerived?.alerts),
        [cashflowDerived],
      );
      const toneForLtvValue = (value) => {
        if (!Number.isFinite(value)) return undefined;
        if (ltvHealthyThreshold > 0 && value <= ltvHealthyThreshold) return "ok";
        if (ltvWarnThreshold > 0 && value <= ltvWarnThreshold) return "warn";
        if (value > 0) return "danger";
        return undefined;
      };
      const ltvProjectedTone = toneForLtvValue(ltvProjectedValue);
      const ltvPlannedTone = toneForLtvValue(plannedOverallLTV);
      const plannedCollateralChange = collateralAfterPlan - totals.totalCollateralValue;
      const binanceLoanAfterPlan = plannedOutstanding;
      const binanceLoanPrincipalAfterPlan = plannedOutstandingPrincipal;
      const binanceOutstandingRatio = loanAmount > 0
        ? Math.max(0, Math.min(1, binanceLoanPrincipalAfterPlan / loanAmount))
        : 0;
      const binanceCollateralAfterPlan = collateralAfterPlan;
      const binanceLtvAfterPlan = plannedOverallLTV;
      const binanceInitialLtvTone = toneForLtvValue(binanceInitialLtv);
      const binanceCurrentLtvTone = toneForLtvValue(currentOverallLTV);
      const interestDisplayValue = plannedAccruedInterest > 0 ? plannedAccruedInterest : binanceInterestAccruedTotal;
      const binanceLoanNetSubtle = [
        interestDisplayValue > 0 ? `Interés ${formatLoan(interestDisplayValue)}` : null,
        binancePaidDisplayTotal > 0 ? `${binancePaidLabel} ${formatLoan(binancePaidDisplayTotal)}` : null,
      ].filter(Boolean).join(' · ') || 'Sin movimientos registrados';
      const binancePaidSubtle = hasCashflowPlanPayments
        ? 'Pagos planificados desde Cashflow'
        : 'Sin pagos planificados';
      const binanceInitialCollateralSubtle = binanceInitialCollateralTotal > 0
        ? `Colateral inicial ${formatUsd(binanceInitialCollateralTotal)}`
        : '—';
      const binanceNetLtvSubtle = totals.totalCollateralValue > 0
        ? `Colateral actual ${formatUsd(totals.totalCollateralValue)}`
        : 'Sin colateral';
      const binanceExtraCollateralNeeded = ltvHealthyThreshold > 0 ? Math.max(0, binanceLoanAfterPlan / ltvHealthyThreshold - binanceCollateralAfterPlan) : 0;
      const binanceRepayNeeded = Math.max(0, binanceLoanAfterPlan - binanceCollateralAfterPlan * ltvHealthyThreshold);
      const binanceBufferToCaution = Math.max(0, binanceCollateralAfterPlan * ltvWarnThreshold - binanceLoanAfterPlan);
      const binanceCautionLabel = ltvWarnThreshold > ltvHealthyThreshold ? `${toPct(ltvHealthyThreshold, 0)} – ${toPct(ltvWarnThreshold, 0)}` : `>${toPct(ltvHealthyThreshold, 0)}`;
      const currentLiquidationValue = marginCallLtv > 0 ? plannedOutstanding / marginCallLtv : 0;
      const currentLiquidationBuffer = totals.totalCollateralValue - currentLiquidationValue;
      const binanceLiquidationValue = marginCallLtv > 0 ? binanceLoanAfterPlan / marginCallLtv : 0;
      const binanceLiquidationBuffer = binanceCollateralAfterPlan - binanceLiquidationValue;

      const formatBinanceBufferValue = (buffer) => {
        if (!Number.isFinite(buffer)) return '—';
        const formatted = formatUsd(Math.abs(buffer));
        return buffer >= 0 ? formatted : `Déficit ${formatted}`;
      };

      const toneForBinanceBuffer = (buffer) => {
        if (!Number.isFinite(buffer)) return undefined;
        return buffer >= 0 ? "ok" : "danger";
      };

      const manualLoanAllocationEnabled = !!params.manualLoanAllocation;

      const collateralBreakdown = useMemo(() => {
        const totalCollateral = totals.totalCollateralValue || 0;
        if (!(totalCollateral > 0)) {
          return {
            items: [],
            manualActive: false,
            manualEnabled: manualLoanAllocationEnabled,
            manualTotal: 0,
            loanAllocated: 0,
            weightedAprOffset: isBinance ? binanceBorrowAdjustment : 0,
            weightedNetApr: isBinance ? binanceBorrowNetAnnualRate : chosenAPR,
          };
        }
        const outstandingMap = cashflowDerived?.outstandingByTicker || null;
        const hasOutstandingMap = !!(outstandingMap && Object.keys(outstandingMap).length > 0);
        const manualTotal = totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.loanAssigned > 0)
          .reduce((acc, asset) => acc + asset.loanAssigned, 0);
        const manualEnabled = manualLoanAllocationEnabled;
        const manualActive = manualEnabled && manualTotal > 0;
        const directLoanActive = isBinance ? Object.keys(loanRequestsTotals).length > 0 : loanAmount > 0;
        const directLoanSum = Object.values(loanRequestsTotals).reduce((acc, value) => acc + value, 0);
        const outstandingDirectTotal = hasOutstandingMap
          ? Object.values(outstandingMap).reduce((acc, value) => {
              const num = Number(value);
              return acc + (Number.isFinite(num) && num > 0 ? num : 0);
            }, 0)
          : (isBinance ? directLoanSum : directLoanSum * (binanceOutstandingRatio || 0));
        const loanBase = isBinance
          ? (binanceLedgerOutstandingTotal > 0 ? binanceLedgerOutstandingTotal : Math.max(0, directLoanSum || plannedOutstandingPrincipal))
          : Math.max(0, plannedOutstandingPrincipal);
        const items = totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.value > 0)
          .map((asset) => {
            const ticker = sanitizeTicker(asset.ticker);
            const policyLTV = ltvByTicker[ticker] ?? asset.ltv ?? defaultLtv;
            const maxBorrowForAsset = asset.value * policyLTV;
            const share = asset.value / totalCollateral;
            const mappedLoanRaw = directLoanActive ? Math.max(0, loanRequestsTotals[ticker] || 0) : 0;
            const plannedOutstanding = hasOutstandingMap && Object.prototype.hasOwnProperty.call(outstandingMap, ticker)
              ? Math.max(0, Number(outstandingMap[ticker]) || 0)
              : null;
            const hasPlannedOutstanding = plannedOutstanding !== null;
            const mappedLoan = directLoanActive
              ? (hasPlannedOutstanding ? plannedOutstanding : mappedLoanRaw)
              : 0;
            const ledgerEntry = isBinance ? binanceLoanLedger[ticker] : null;
            const manualAllocation = manualActive
              ? Math.max(0, asset.loanAssigned || 0)
              : (directLoanActive ? mappedLoan : loanBase * share);
            const ledgerOutstandingHint = Number.isFinite(ledgerEntry?.outstanding) && ledgerEntry.outstanding >= 0
              ? Math.max(0, ledgerEntry.outstanding)
              : 0;
            const paidTotal = Math.max(0, Number(ledgerEntry?.paidTotal) || 0);
            const interestAccrued = Math.max(0, Number(ledgerEntry?.interestAccrued) || 0);
            const originalPrincipal = Number.isFinite(ledgerEntry?.originalPrincipal) && ledgerEntry.originalPrincipal > 0
              ? ledgerEntry.originalPrincipal
              : Math.max(0, manualAllocation + paidTotal - interestAccrued);
            const ledgerNetOutstanding = Math.max(0, originalPrincipal + interestAccrued - paidTotal);
            const fallbackOutstanding = ledgerNetOutstanding > 0
              ? ledgerNetOutstanding
              : (ledgerOutstandingHint > 0 ? ledgerOutstandingHint : manualAllocation);
            const loanNetOutstanding = hasPlannedOutstanding
              ? plannedOutstanding
              : fallbackOutstanding;
            const usageVsCap = maxBorrowForAsset > 0 ? loanNetOutstanding / maxBorrowForAsset : 0;
            const qty = Number(asset.qty) || 0;
            const ledgerCollateralAmount = Number.isFinite(ledgerEntry?.collateralAmount) && ledgerEntry.collateralAmount > 0
              ? ledgerEntry.collateralAmount
              : null;
            const collateralQtyForCalc = ledgerCollateralAmount != null ? ledgerCollateralAmount : qty;
            const initialLtv = Number.isFinite(ledgerEntry?.initialLtv) && ledgerEntry.initialLtv > 0
              ? ledgerEntry.initialLtv
              : policyLTV;
            const ledgerBorrowIndexPrice = Number.isFinite(ledgerEntry?.borrowIndexPrice) && ledgerEntry.borrowIndexPrice > 0
              ? ledgerEntry.borrowIndexPrice
              : 1;
            const ledgerCollateralIndexPrice = Number.isFinite(ledgerEntry?.collateralIndexPrice) && ledgerEntry.collateralIndexPrice > 0
              ? ledgerEntry.collateralIndexPrice
              : (Number(asset.price) > 0 ? asset.price : null);
            const collateralIndexValue = ledgerCollateralIndexPrice != null && collateralQtyForCalc > 0
              ? ledgerCollateralIndexPrice * collateralQtyForCalc
              : null;
            const borrowValueIndex = ledgerBorrowIndexPrice * loanNetOutstanding;
            const actualLtv = collateralIndexValue && collateralIndexValue > 0
              ? borrowValueIndex / collateralIndexValue
              : (asset.value > 0 ? loanNetOutstanding / asset.value : 0);
            const earnApr = earnAprTop[ticker] ?? 0;
            const baseOffset = actualLtv > 0 ? earnApr / actualLtv : 0;
            const ledgerLoanCoin = isBinance ? sanitizeTicker(ledgerEntry?.loanCoin || '') : '';
            const defaultLoanCoin = isBinance ? sanitizeTicker(params.binanceBorrowTicker || '') : '';
            const loanCoinForRates = isBinance ? (ledgerLoanCoin || defaultLoanCoin || ticker) : '';
            const borrowInfo = isBinance && loanCoinForRates ? borrowRatesByTicker[loanCoinForRates] || {} : {};
            const annualAprRaw = isBinance
              ? (Number.isFinite(borrowInfo.annual) && borrowInfo.annual >= 0
                ? borrowInfo.annual
                : (Number.isFinite(ledgerEntry?.annualRate) && ledgerEntry.annualRate > 0
                  ? ledgerEntry.annualRate
                  : binanceBorrowAnnualRate))
              : chosenAPR;
            const annualApr = Number.isFinite(annualAprRaw) ? annualAprRaw : null;
            const vipAnnual = isBinance
              ? (Number.isFinite(borrowInfo.vipAnnual)
                ? borrowInfo.vipAnnual
                : (Number.isFinite(ledgerEntry?.vipAnnualRate) ? ledgerEntry.vipAnnualRate : null))
              : null;
            const fallbackNetApr = Number.isFinite(annualApr) && Number.isFinite(policyLTV) && policyLTV > 0
              ? annualApr - (earnApr / policyLTV)
              : annualApr;
            const netAprSim = isBinance ? computeNetAprForPair(loanCoinForRates, ticker, actualLtv) : null;
            const netAprRaw = isBinance
              ? (Number.isFinite(netAprSim)
                ? netAprSim
                : (Number.isFinite(ledgerEntry?.netAnnualRate)
                  ? ledgerEntry.netAnnualRate
                  : (Number.isFinite(borrowInfo.netAnnual)
                    ? borrowInfo.netAnnual
                    : fallbackNetApr)))
              : Math.max(0, (Number.isFinite(chosenAPR) ? chosenAPR : 0) - baseOffset);
            const netApr = Number.isFinite(netAprRaw) ? netAprRaw : 0;
            const aprOffset = isBinance
              ? (Number.isFinite(annualApr) && Number.isFinite(netApr) ? annualApr - netApr : 0)
              : baseOffset;
            const borrowUsdValue = borrowValueIndex;
            const computedEtb = Number.isFinite(initialLtv) && initialLtv > 0 && collateralQtyForCalc > 0 && Number.isFinite(ledgerCollateralIndexPrice)
              ? Math.max(0, collateralQtyForCalc * ledgerCollateralIndexPrice * initialLtv - borrowUsdValue)
              : null;
            const etb = Number.isFinite(computedEtb)
              ? computedEtb
              : (Number.isFinite(ledgerEntry?.etb) ? ledgerEntry.etb : null);
            let tone = "ok";
            if (isBinance) {
              const warnCut = ltvHealthyThreshold || 0;
              const dangerCut = ltvWarnThreshold > 0 ? ltvWarnThreshold : Math.max(warnCut, marginCallLtv);
              if (dangerCut > 0 && actualLtv >= dangerCut) {
                tone = "danger";
              } else if (warnCut > 0 && actualLtv >= warnCut) {
                tone = "warn";
              }
            } else {
              if (usageVsCap >= 1 || actualLtv >= policyLTV || plannedOverallLTV >= autoRepayLtv) {
                tone = "danger";
              } else if (usageVsCap > 0.75 || actualLtv > policyLTV * 0.9 || plannedOverallLTV >= marginCallLtv) {
                tone = "warn";
              }
            }
            const ledgerLiquidationLtvRaw = Number.isFinite(ledgerEntry?.liquidationLtv) && ledgerEntry.liquidationLtv > 0
              ? ledgerEntry.liquidationLtv
              : null;
            const biasApplied = liqBiasByTicker[ticker] ?? 0;
            const adjustedLiquidationLtv = ledgerLiquidationLtvRaw != null
              ? Math.max(0, ledgerLiquidationLtvRaw * (1 + biasApplied))
              : null;
            const liquidationThreshold = adjustedLiquidationLtv != null
              ? adjustedLiquidationLtv
              : (autoRepayLtv > 0 ? autoRepayLtv : marginCallLtv);
            const marginCallThreshold = Number.isFinite(ledgerEntry?.marginCallLtv) && ledgerEntry.marginCallLtv > 0
              ? ledgerEntry.marginCallLtv
              : marginCallLtv;
            const ledgerPrincipalOutstanding = Number.isFinite(ledgerEntry?.principalOutstanding) && ledgerEntry.principalOutstanding >= 0
              ? ledgerEntry.principalOutstanding
              : Math.max(0, fallbackOutstanding - interestAccrued);
            const principalOutstanding = hasPlannedOutstanding
              ? plannedOutstanding
              : ledgerPrincipalOutstanding;
            const liquidationBaseLoan = hasPlannedOutstanding
              ? plannedOutstanding
              : loanNetOutstanding;
            const liquidationValue = liquidationThreshold > 0
              ? (liquidationBaseLoan > 0 ? (ledgerBorrowIndexPrice * liquidationBaseLoan) / liquidationThreshold : 0)
              : null;
            const marginCallValue = marginCallThreshold > 0
              ? (liquidationBaseLoan > 0 ? (ledgerBorrowIndexPrice * liquidationBaseLoan) / marginCallThreshold : 0)
              : null;
            const computedLiquidationPrice = liquidationValue != null && collateralQtyForCalc > 0 ? liquidationValue / collateralQtyForCalc : null;
            const liquidationPrice = Number.isFinite(computedLiquidationPrice) && computedLiquidationPrice > 0
              ? computedLiquidationPrice
              : (Number.isFinite(ledgerEntry?.liquidationPriceHint) && ledgerEntry.liquidationPriceHint > 0
                ? ledgerEntry.liquidationPriceHint
                : null);
            const marginCallPrice = Number.isFinite(marginCallValue) && collateralQtyForCalc > 0 ? marginCallValue / collateralQtyForCalc : null;
            const referencePrice = ledgerCollateralIndexPrice ?? (Number(asset.price) > 0 ? asset.price : null);
            const liquidationBufferValue = Number.isFinite(liquidationValue) && collateralIndexValue != null
              ? collateralIndexValue - liquidationValue
              : null;
            const liquidationBufferPct = referencePrice && liquidationPrice && referencePrice > 0
              ? Math.max(0, (referencePrice - liquidationPrice) / referencePrice)
              : null;
            return {
              id: asset.id,
              name: asset.name || ticker || `Activo ${asset.id}`,
              ticker,
              value: asset.value,
              share,
              policyLTV,
              policyPct: policyLTV * 100,
              maxBorrowForAsset,
              allocatedLoan: loanNetOutstanding,
              usageVsCap: Math.max(0, usageVsCap),
              actualLtv,
              earnApr,
              aprOffset,
              netApr,
              tone,
              annualApr,
              vipAnnual,
              ledger: ledgerEntry ? { ...ledgerEntry, payments: Array.isArray(ledgerEntry.payments) ? ledgerEntry.payments.map((p) => ({ ...p })) : [] } : null,
              paidTotal,
              interestAccrued,
              originalPrincipal,
              principalOutstanding,
              liquidationPrice,
              marginCallPrice,
              liquidationBufferPct,
              liquidationBufferValue,
              currentPrice: referencePrice,
              qty: collateralQtyForCalc,
              marginCallThreshold,
              autoLiquidationThreshold: autoRepayLtv > 0 ? autoRepayLtv : null,
              marginCallValue,
              liquidationValue,
              liquidationThreshold,
              liquidationBaseLoan,
              loanNetOutstanding,
              borrowIndexPrice: ledgerBorrowIndexPrice,
              collateralIndexPrice: ledgerCollateralIndexPrice,
              indexCollateralValue: collateralIndexValue,
              ltvFromApi: Number.isFinite(ledgerEntry?.currentLtv) ? ledgerEntry.currentLtv : null,
              loanCoin: loanCoinForRates || null,
              etb,
            };
          })
          .sort((a, b) => b.value - a.value);
        const netOutstandingTotal = items.reduce((acc, item) => acc + Math.max(0, item.loanNetOutstanding || 0), 0);
        const fallbackAllocatedTotal = items.reduce((acc, item) => acc + Math.max(0, item.allocatedLoan || 0), 0);
        const fallbackLoanBase = manualActive
          ? manualTotal
          : directLoanActive
            ? (hasOutstandingMap
              ? (outstandingDirectTotal > 0 ? outstandingDirectTotal : loanBase)
              : (directLoanSum > 0 ? directLoanSum : loanBase))
            : fallbackAllocatedTotal;
        const loanShareDenom = netOutstandingTotal > 0
          ? netOutstandingTotal
          : (fallbackLoanBase > 0 ? fallbackLoanBase : loanBase);
        const itemsWithShare = items.map((item) => {
          const shareAmount = item.loanNetOutstanding > 0
            ? item.loanNetOutstanding
            : Math.max(0, item.allocatedLoan || 0);
          const loanShare = loanShareDenom > 0 ? shareAmount / loanShareDenom : 0;
          return { ...item, loanShare, loanShareAmount: shareAmount };
        });
        const totalAllocated = loanShareDenom > 0 ? loanShareDenom : loanBase;
        const weightedAprOffset = totalAllocated > 0
          ? itemsWithShare.reduce((acc, item) => acc + Math.max(0, item.aprOffset || 0) * ((item.loanShareAmount || 0) / totalAllocated), 0)
          : (isBinance ? binanceBorrowAdjustment : 0);
        const weightedNetApr = totalAllocated > 0
          ? itemsWithShare.reduce((acc, item) => acc + (item.netApr ?? chosenAPR) * ((item.loanShareAmount || 0) / totalAllocated), 0)
          : (isBinance ? binanceBorrowNetAnnualRate : Math.max(0, chosenAPR - weightedAprOffset));
        return {
          items: itemsWithShare.map(({ loanShareAmount, ...rest }) => rest),
          manualActive,
          manualEnabled,
          manualTotal,
          loanAllocated: totalAllocated || loanBase,
          loanShareDenom,
          netOutstandingTotal,
          weightedAprOffset,
          weightedNetApr,
        };
      }, [autoRepayLtv, binanceBorrowAdjustment, binanceBorrowNetAnnualRate, binanceOutstandingRatio, binanceLoanLedger, binanceLedgerOutstandingTotal, borrowRatesByTicker, cashflowDerived?.outstandingByTicker, defaultLtv, earnAprTop, isBinance, loanAmount, loanRequestsTotals, manualLoanAllocationEnabled, marginCallLtv, plannedOverallLTV, plannedOutstanding, plannedOutstandingPrincipal, totals.totalCollateralValue, totals.withValue, ltvByTicker, ltvHealthyThreshold, ltvWarnThreshold, params.binanceBorrowTicker]);

      const binanceNetAprOffset = isBinance ? Math.max(0, collateralBreakdown.weightedAprOffset || 0) : 0;
      const binanceBaseAnnualRate = isBinance ? binanceBorrowAnnualRate : chosenAPR;
      const binanceNetAnnualRate = isBinance ? binanceBorrowNetAnnualRate : 0;
      const netAnnualRate = isBinance ? binanceNetAnnualRate : standardNetAnnualRate;
      const renderNow = Date.now();
      const binanceLastUpdatedMs = binanceLiveMeta?.lastUpdated ?? null;
      const binanceSecondsAgo = binanceLastUpdatedMs != null ? Math.max(0, Math.floor((renderNow - binanceLastUpdatedMs) / 1000)) : null;
      const binanceUpdatedLabel = binanceSecondsAgo != null ? ` · actualizado hace ${binanceSecondsAgo}s` : '';
      const binanceNetAprSubtle = isBinance
        ? ((binanceOutstandingRatio < 0.999
          ? `Saldo neto ${toPct(binanceOutstandingRatio, 0)} · tasa neta ${toPct(binanceNetAnnualRate, 2)}`
          : (binanceNetAprOffset > 0
            ? `Préstamo ${toPct(binanceBaseAnnualRate, 2)} − ajuste ${toPct(binanceNetAprOffset, 2)}`
            : `Préstamo ${toPct(binanceBaseAnnualRate, 2)}`)) + binanceUpdatedLabel)
        : undefined;

      const extraCollateralForTarget = useMemo(() => {
        if (targetLtv <= 0) return 0;
        const neededCollateral = (plannedOutstanding * usdPerUsdt) / targetLtv;
        return Math.max(0, neededCollateral - totals.totalCollateralValue);
      }, [plannedOutstanding, targetLtv, totals.totalCollateralValue, usdPerUsdt]);

      const loyaltyReqs = useMemo(() => {
        if (!loyalty) return null;
        const denom = loyaltyModelActive === "vsTotal" ? totals.total : totals.rest;
        const tiers = (loyalty.tierThresholds ?? []).map((tier) => {
          const required = denom * tier.minRatio;
          const missing = Math.max(0, required - totals.totalLoyalty);
          return { ...tier, required, missing };
        });
        return { denom, tiers };
      }, [loyalty, loyaltyModelActive, totals.total, totals.rest, totals.totalLoyalty]);

      const meetsLowCost = useMemo(() => {
        const withinTarget = loanAmountUsd <= recommendedLoanAtTarget;
        if (lowCostEligibleTiers.length === 0) {
          return totals.total >= minBalancePerks && withinTarget;
        }
        const hasTier = lowCostEligibleTiers.includes(loyaltyTier);
        return totals.total >= minBalancePerks && withinTarget && hasTier;
      }, [loanAmountUsd, recommendedLoanAtTarget, loyaltyTier, totals.total, lowCostEligibleTiers, minBalancePerks]);

      const handleAssetChange = (id, patch) => setAssets(prev => prev.map(a => (a.id === id ? { ...a, ...patch } : a)));

      const addRow = () => {
        const nextId = Math.max(0, ...assets.map(a => a.id)) + 1;
        setAssets(prev => ([...prev, { id: nextId, name: "Nuevo", ticker: "TKN", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: defaultLtv, loanAssigned: 0 }]));
      };
      const removeRow = (id) => setAssets(prev => prev.filter(a => a.id !== id));

      const displayPlatformName = platformName || platformId;


      useEffect(() => {
        document.title = `Simulador de Préstamos / ${displayPlatformName}`;
      }, [displayPlatformName]);

      useEffect(() => {
        applyTheme(themeName);
      }, [themeName]);

      return (
        <div className="min-h-screen w-full text-neutral-900">
          <div className={`${headerClass} text-white`}>
            <div className="mx-auto max-w-7xl px-4 py-6">
              <header className="flex flex-wrap items-end justify-between gap-4">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">{`Simulador de Préstamos / ${displayPlatformName}`}</h1>
                  <p className={`${accentClass}`}>{platformTagline}</p>
                </div>
                <div className="flex flex-col items-end gap-3 sm:flex-row sm:items-center">
                  <div ref={exportMenuRef} className="relative">
                    <input
                      ref={importInputRef}
                      type="file"
                      accept="application/json"
                      className="hidden"
                      onChange={handleImportFile}
                    />
                    <button
                      type="button"
                      onClick={() => setExportMenuOpen((open) => !open)}
                      className="nx-btn text-sm"
                      aria-haspopup="true"
                      aria-expanded={exportMenuOpen}
                    >
                      Plantillas &amp; datos
                    </button>
                    {exportMenuOpen && (
                      <div className="absolute right-0 z-20 mt-3 w-60 rounded-2xl border border-neutral-200 bg-white p-2 text-neutral-700 shadow-2xl">
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm font-semibold hover:bg-neutral-100" onClick={handleExportJSON}>Exportar JSON</button>
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm font-semibold hover:bg-neutral-100" onClick={handleImportRequest}>Importar JSON</button>
                        <div className="my-1 border-t border-neutral-200" />
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100" onClick={handleResetParams}>Reset parámetros</button>
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100" onClick={handleResetAssets}>Reset activos</button>
                        <button type="button" className="w-full rounded-xl px-3 py-2 text-left text-sm hover:bg-neutral-100" onClick={handleResetPlanners}>Reset planners</button>
                      </div>
                    )}
                  </div>
                  <div className="flex flex-wrap items-center justify-end gap-4">
                    <div className="flex items-center gap-2">
                      <label className="text-sm font-medium">Plataforma</label>
                      <select value={platformId} onChange={(e) => setPlatformId(PLATFORM_IDS.includes(e.target.value) ? e.target.value : initialPlatformId)} className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80">
                        {PLATFORM_IDS.map((pid) => (
                          <option key={pid} value={pid} className="text-neutral-900">{platformConfigs[pid]?.name ?? pid}</option>
                        ))}
                      </select>
                    </div>
                    <div className="flex items-center gap-2 text-sm font-medium">
                      <label htmlFor="currency-select">Mostrar en</label>
                      <select
                        id="currency-select"
                        value={currency}
                        onChange={(e) => setSelectedCurrency(e.target.value)}
                        className="rounded-xl border border-white/40 bg-white/15 px-3 py-1.5 text-sm font-semibold text-white shadow-sm backdrop-blur focus:outline-none focus:ring-2 focus:ring-white/80"
                      >
                        {SUPPORTED_CURRENCIES.map((option) => (
                          <option
                            key={option.code}
                            value={option.code}
                            className="text-neutral-900"
                            title={option.label}
                          >
                            {option.code}
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>
                </div>
              </header>
            </div>
          </div>

          <div className="mx-auto max-w-7xl px-4 py-6">
            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
              {(isBinance ? [
                { key: 'loan-current', title: 'Préstamo original', value: formatLoan(binanceOriginalPrincipalTotal), subtle: binanceOriginalPrincipalTotal > 0 ? 'Capital original' : '—' },
                { key: 'repay-total', title: 'Total a devolver', value: formatLoan(binanceTotalToRepay) },
                { key: 'loan-paid', title: 'Pagos hechos', value: formatLoan(binancePaidDisplayTotal), subtle: binancePaidSubtle },
                { key: 'loan-plan', title: 'Préstamo neto', value: formatLoan(binanceNetLoanValue), subtle: binanceLoanNetSubtle },
                { key: 'collateral-current', title: 'Colateral actual', value: formatUsd(totals.totalCollateralValue) },
                { key: 'ltv-current', title: 'LTV inicial', value: toPct(binanceInitialLtv, 2), tone: binanceInitialLtvTone, subtle: binanceInitialCollateralSubtle },
                { key: 'ltv-plan', title: 'LTV neto', value: toPct(currentOverallLTV, 2), tone: binanceCurrentLtvTone, subtle: binanceNetLtvSubtle },
                { key: 'apr', title: 'Tasa anual (APR)', value: toPct(isBinance ? binanceBaseAnnualRate : chosenAPR, 2), subtle: binanceBorrowLabel || undefined },
                {
                  key: 'apr-net',
                  title: 'Tasa anual neta',
                  value: toPct(isBinance ? binanceNetAnnualRate : netAnnualRate, 2),
                  subtle: binanceNetAprSubtle,
                  tone: isBinance
                    ? (binanceNetAnnualRate <= binanceBaseAnnualRate ? 'ok' : undefined)
                    : (netAnnualRate <= chosenAPR ? 'ok' : undefined),
                },
                {
                  key: 'interest-monthly',
                  title: 'Interés mensual estimado',
                  value: formatLoan(monthlyLoanCost),
                  subtle: `${toPct(chosenAPR, 2)} APR base`,
                },
              ] : [
                { key: 'balance', title: 'Balance total', value: formatUsd(totals.total) },
                { key: 'loyalty', title: loyalty ? (loyalty.kpiLabel || 'Loyalty Tier') : 'Programa', value: loyalty ? loyaltyTier : '—', subtle: loyalty && totals.total < minBalancePerks ? '(balance < mínimo)' : undefined },
                { key: 'apr', title: 'APR crédito', value: toPct(chosenAPR, 2), subtle: meetsLowCost ? 'Low-Cost activo' : undefined },
                { key: 'cap-lowcost', title: 'Cap. Low-Cost (≤20% LTV)', value: formatUsd(capLowCost), subtle: 'potencial' },
                { key: 'ltv-top', title: 'Tope por LTVs', value: formatUsd(totals.maxBorrow) },
                { key: 'loan-target', title: 'Préstamo recomendado (≤20%)', value: formatUsd(recommendedLoanAtTarget) },
                { key: 'interest-total', title: 'Interés hasta repago', value: formatLoan(interestCalc.total), subtle: `${daysUntilRepay} días` },
                { key: 'repay-total', title: 'Total a devolver', value: formatLoan(totalProjectedOutflows), subtle: projectedFinalPayoff > 0 ? `Pago final proyectado ${formatLoan(projectedFinalPayoff)}` : undefined },
                { key: 'earn-monthly', title: 'Earn mensual (hasta)', value: formatUsd(earnMonthly), subtle: earnEligible ? (minBalancePerks > 0 ? `Savings ≥ US$${formatDecimal(minBalancePerks, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}` : undefined) : (forceOn ? 'forzado (sim)' : 'no elegible') },
              ]).map((item) => (
                <KPI key={item.key} title={item.title} value={item.value} subtle={item.subtle} tone={item.tone} variant={item.variant || 'button'} />
              ))}
            </section>

            {isBinance && collateralBreakdown.items.length > 0 && (
              <section className="mb-8">
                <div className="mb-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                  <h3 className="text-lg font-semibold text-neutral-800">Detalle por cripto (Binance Loans)</h3>
                  <p className="text-sm text-neutral-500">LTV, préstamo asignado y APR neta por cada colateral.</p>
                </div>
                <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">
                  {collateralBreakdown.items.map((item) => (
                    <BinanceAssetCard
                      key={item.id}
                      item={item}
                      currency={currency}
                      formatUsd={formatUsd}
                      formatLoan={formatLoan}
                      chosenAPR={chosenAPR}
                    />
                  ))}
                  <CollateralLoanShareCard
                    breakdown={collateralBreakdown.items}
                    currency={currency}
                    formatUsd={formatUsd}
                    formatLoan={formatLoan}
                    loanAmount={plannedOutstandingPrincipal}
                    overallLTV={currentOverallLTV}
                    healthyThreshold={ltvHealthyThreshold}
                    warnThreshold={ltvWarnThreshold}
                    autoRepayThreshold={autoRepayLtv}
                  />
                </div>
              </section>
            )}

            <section className="mb-10 grid grid-cols-1 gap-6 items-start xl:grid-cols-2">
              <div className="space-y-6">
                <Card title="Préstamo & Repago">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 justify-items-center">
                    <Field label={`Monto a pedir (${currency})`} align="center" className="w-full max-w-xs">
                      <LocaleNumberInput
                        value={loanDraftAmount * loanRate}
                        onChange={(v) => setLoanDraftAmount(Math.max(0, v / loanRate))}
                        decimals={2}
                        min={0}
                        className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                      />
                    </Field>
                    <Field label="Fecha de repago" align="center" className="w-full max-w-xs">
                      <input
                        type="date"
                        className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                        value={repayDate}
                        min={todayISO()}
                        onChange={(e)=> setRepayDate(e.target.value)}
                      />
                    </Field>
                    {isBinance && borrowTickerList.length > 0 && (
                      <Field label="Cripto del préstamo" align="center" className="w-full max-w-xs md:col-span-2">
                        <select
                          value={binanceBorrowTicker || ''}
                          onChange={(e) => setParams({ ...params, binanceBorrowTicker: sanitizeTicker(e.target.value) })}
                          className={`w-full rounded-full border border-neutral-300 px-5 py-3 text-center text-lg font-semibold shadow-sm focus:outline-none focus:ring-2 ${focusRingClass}`}
                        >
                          {borrowTickerList.map((ticker) => (
                            <option key={`borrow-${ticker}`} value={ticker}>
                              {borrowRatesByTicker[ticker]?.label || ticker} · {toPct(borrowRatesByTicker[ticker]?.annual ?? 0, 2)} APR
                            </option>
                          ))}
                        </select>
                      </Field>
                    )}
                  </div>
                  <div className="mt-4 flex flex-col items-center justify-center gap-3 md:flex-row">
                    <button
                      type="button"
                      onClick={handleAddLoanRequest}
                      disabled={!(loanDraftAmount > 0)}
                      className="nx-btn text-sm disabled:cursor-not-allowed disabled:opacity-60"
                    >
                      Agregar préstamo
                    </button>
                    {loanRequests.length > 0 && (
                      <button
                        type="button"
                        onClick={handleClearLoanRequests}
                        className="nx-btn nx-btn-ghost text-sm"
                      >
                        Limpiar préstamos
                      </button>
                    )}
                    <span className="text-sm font-medium text-neutral-600">
                      Total cargado: {formatLoan(loanAmount)}
                    </span>
                  </div>
                  {isBinance && (
                    <p className="mt-6 text-sm text-neutral-500 text-center">
                      Distribución actual: <span className="font-semibold text-neutral-700">{binanceBorrowLabel || '—'}</span>.{' '}
                      {params.manualLoanAllocation
                        ? 'Estás distribuyendo el préstamo manualmente entre los colaterales activos.'
                        : (binanceActiveLoanEntries.length > 0
                          ? 'Se respeta la asignación por cripto que agregaste en la lista.'
                          : 'La herramienta reparte el préstamo de forma proporcional al valor del colateral.')}
                    </p>
                  )}
                  <div className="mt-4 w-full">
                    {loanRequests.length > 0 ? (
                      <div className="nx-card-secondary p-3">
                        <div className="flex flex-col gap-2">
                          {loanRequests.map((request) => {
                            const ticker = sanitizeTicker(request.ticker || '');
                            const info = isBinance && ticker ? borrowRatesByTicker[ticker] : null;
                            const label = info?.label || (ticker || 'General');
                            const share = loanAmount > 0 ? request.amount / loanAmount : 0;
                            const aprText = info?.annual != null ? toPct(info.annual, 2) : '—';
                            return (
                              <div
                                key={request.id}
                                className="grid grid-cols-1 gap-2 px-3 py-2 text-sm text-neutral-700 md:grid-cols-[minmax(0,1fr)_auto_auto] md:items-center nx-card-tertiary"
                              >
                                <div>
                                  <div className="font-semibold text-neutral-900">{label}</div>
                                  <div className="text-xs text-neutral-500">
                                    {share > 0 ? `${toPct(share, 1)} del total` : 'Sin distribución'}{info ? ` · ${aprText} APR` : ''}
                                  </div>
                                </div>
                                <div className="text-right font-semibold text-neutral-800">
                                  {formatLoan(request.amount)}
                                </div>
                                <div className="text-right">
                                  <button
                                    type="button"
                                    onClick={() => handleRemoveLoanRequest(request.id)}
                                    className="nx-btn nx-btn-ghost nx-btn-sm"
                                  >
                                    Quitar
                                  </button>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ) : (
                      <p className="text-center text-sm text-neutral-500">No agregaste préstamos todavía.</p>
                    )}
                  </div>
                  <div className="mt-6 space-y-3">
                    {isBinance ? (
                      <p className="text-sm text-neutral-500 text-center">
                        Distribución actual: <span className="font-semibold text-neutral-700">{binanceBorrowLabel || '—'}</span>.{' '}
                        {params.manualLoanAllocation
                          ? 'Estás distribuyendo el préstamo manualmente entre los colaterales activos.'
                          : (binanceActiveLoanEntries.length > 0
                            ? 'Se respeta la asignación por cripto que agregaste en la lista.'
                            : 'La herramienta reparte el préstamo de forma proporcional al valor del colateral.')}
                      </p>
                    ) : (
                      <>
                        <Pill label="LTV si pides esto" value={toPct(plannedOverallLTV, 2)} tone={ltvPlannedTone} />
                        <Pill label="≤20% LTV (fijo)" value={loanAmountUsd <= recommendedLoanAtTarget ? "Sí" : "No"} tone={loanAmountUsd <= recommendedLoanAtTarget ? "ok" : "warn"} />
                        <Pill label="¿Califica Low-Cost?" value={meetsLowCost ? "Sí" : "No"} tone={meetsLowCost ? "ok" : "warn"} />
                        <Pill label="Margen Low-Cost" value={formatUsd(lowCostHeadroom)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                      </>
                    )}
                  </div>
                </Card>

                <Card title="Proyección del préstamo">
                  <TrendChart data={timeline} currency={currency} rate={loanRate} />
                </Card>

              </div>

              <div className="space-y-6">
                <Card title="Salud del préstamo">
                  <LTVGauge value={ltvGaugeValue} zones={ltvGaugeZones} markers={ltvGaugeMarkers} />
                  <div className="mt-2 text-center text-xs text-neutral-500">
                    {ltvScenarioLabel ? `Escenario activo: ${ltvScenarioLabel}` : 'Escenario base sin shocks.'}
                  </div>
                  {cashflowAlerts.length > 0 && (
                    <div className="mt-3 space-y-2 text-xs">
                      {cashflowAlerts.slice(0, 2).map((alert) => {
                        const tone = ALERT_TONE_STYLES[alert.tone] || ALERT_TONE_STYLES.info;
                        return (
                          <div
                            key={alert.id}
                            className={`rounded-xl border px-3 py-2 ${tone.border} ${tone.bg} ${tone.text}`}
                          >
                            {alert.message}
                          </div>
                        );
                      })}
                    </div>
                  )}
                  <div className="mt-4 space-y-2">
                    {isBinance ? (
                      <>
                        <Line label="LTV inicial" value={toPct(binanceInitialLtv, 2)} tone={binanceInitialLtvTone} />
                        <Line label="LTV neto" value={toPct(currentOverallLTV, 2)} tone={binanceCurrentLtvTone} />
                        <Line label="LTV proyectado (cashflow)" value={Number.isFinite(ltvProjectedValue) ? toPct(ltvProjectedValue, 2) : '∞'} tone={ltvProjectedTone} />
                        <Line label="Rango saludable" value={`≤ ${toPct(ltvHealthyThreshold, 0)}`} muted />
                        <Line label="Riesgo medio" value={binanceCautionLabel} muted />
                        <Line label="Margin call" value={toPct(marginCallLtv, 0)} muted />
                        <Line label="Auto-liquidación" value={toPct(autoRepayLtv, 0)} muted />
                        <Line label="Buffer actual" value={formatBinanceBufferValue(currentLiquidationBuffer)} tone={toneForBinanceBuffer(currentLiquidationBuffer)} />
                        <Line label="Buffer simulado" value={formatBinanceBufferValue(binanceLiquidationBuffer)} tone={toneForBinanceBuffer(binanceLiquidationBuffer)} />
                      </>
                    ) : (
                      <>
                        <Line label="LTV proyectado (cashflow)" value={Number.isFinite(ltvProjectedValue) ? toPct(ltvProjectedValue, 1) : '∞'} tone={ltvProjectedTone} />
                        <Line label="LTV actual" value={toPct(currentOverallLTV, 1)} muted />
                        <Line label="Objetivo Low-Cost" value={toPct(targetLtv, 0)} muted />
                        <Line label="Margin call" value={toPct(marginCallLtv, 0)} muted />
                        <Line label="Auto-repay" value={toPct(autoRepayLtv, 0)} muted />
                        <Line label="Cap Low-Cost" value={formatUsd(capLowCost)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                      </>
                    )}
                  </div>
                </Card>

                <BenchmarkCeFiDeFi
                  config={benchmarkConfig}
                  onChange={updateBenchmarkConfig}
                  fmt={fmt}
                  currency={currency}
                  rate={loanRate}
                  loanAmount={loanAmount}
                  chosenAPR={chosenAPR}
                  daysUntilRepay={daysUntilRepay}
                  scenarioName={ltvScenarioLabel}
                  cashflowNet={cashflowDerived?.netBalanceFinal}
                  defaultMatrix={baseBenchmarkConfig?.rateMatrix}
                />

                {!isBinance && (
                  <Card title="Diagnóstico & Sugerencias">
                  <ul className="list-disc pl-5 space-y-2 text-sm">
                    {loyalty ? (
                      <li>
                      Tu {loyalty.ratioLabel ?? `ratio ${loyalty.tokenTicker?.toUpperCase() || ''}`} es <b>{toPct(totals.ratioVsRest, 2)} vs resto</b> / <b>{toPct(totals.ratioVsTotal, 2)} vs total</b>. Modelo activo: <b>{loyaltyModelActive === "vsTotal" ? "vs total" : "vs resto"}</b>. Nivel actual: <b>{loyaltyTier}</b>.
                        {totals.total < minBalancePerks && (<span className="text-neutral-600"> (El balance total no supera el mínimo de perks).</span>)}
                      </li>
                    ) : (
                      <li>Esta plataforma no requiere ratio de token para acceder a mejores tasas: el enfoque es puramente por colateral.</li>
                    )}
                    {loyalty && loyaltyReqs?.tiers?.length ? (
                      <li>
                        {loyaltyReqs.tiers.map((tier, idx) => (
                          <span key={tier.label}>{idx > 0 ? ' · ' : ''}Para <b>{tier.label}</b> faltan {formatUsd(tier.missing)}</span>
                        ))}
                      </li>
                    ) : null}
                    <li>
                      Con tu colateral actual, el tope por LTVs es {formatUsd(totals.maxBorrow)}. El cap Low-Cost (≤{toPct(targetLtv, 0)}) permite pedir hasta {formatUsd(capLowCost)} y deja {formatUsd(lowCostHeadroom)} de margen.
                    </li>
                    <li>
                      Para sostener un préstamo neto de {formatLoan(plannedOutstanding)} y mantener ≤{toPct(targetLtv, 0)} LTV se requieren {formatUsd(extraCollateralForTarget)} adicionales en colateral.
                    </li>
                    <li>
                      APR estimado: <b>{toPct(chosenAPR, 2)}</b>{isBinance && binanceBorrowLabel ? ` (${binanceBorrowLabel})` : ''}. Interés hasta repago ({daysUntilRepay} días): {formatLoan(interestCalc.total)}.{interestCalc.early > 0 && <span> Incluye interés por "early rule".</span>}
                    </li>
                    <li>
                  Earn (flex) mensual estimado {earnEligible ? (minBalancePerks > 0 ? "(tope)" : "") : (forceOn ? "(forzado sim)" : (minBalancePerks > 0 ? "(requiere balance mínimo)" : "(no elegible)"))}: <b>{formatUsd(earnMonthly)}</b>.
                    </li>
                  </ul>
                  </Card>
                )}
              </div>

              <div className="xl:col-span-2">
                <CashflowPlanner
                  plan={cashflowPlan}
                  derived={cashflowDerived}
                  onPlanChange={updateCashflowPlan}
                  currency={currency}
                  rate={loanRate}
                  fmt={fmt}
                  loanAmount={loanAmount}
                  chosenAPR={chosenAPR}
                  interestCalc={interestCalc}
                  daysUntilRepay={daysUntilRepay}
                  repayDate={repayDate}
                  totals={totals}
                  targetLtv={targetLtv}
                  marginCallLtv={marginCallLtv}
                  autoRepayLtv={autoRepayLtv}
                  scenarioDefaults={cashflowPlan?.scenarioShocks}
                  focusRingClass={focusRingClass}
                  earnMonthly={earnMonthly}
                  earnEligible={earnEligible}
                  minBalancePerks={minBalancePerks}
                />
              </div>
            </section>

            <section className="mb-10">
              <div className="flex flex-col items-center gap-4 md:flex-row md:items-center md:justify-between mb-4">
                <h2 className="text-xl font-semibold text-center md:text-left">Activos y colateral</h2>
                <div className="flex flex-wrap items-center justify-center gap-2">
                  <button onClick={addRow} className="nx-btn text-sm">Añadir activo</button>
                  <button onClick={() => { localStorage.removeItem(storageKeys.assets); setAssets(sanitizeAssets(platformDefaultAssets)); }} className="nx-btn nx-btn-ghost text-sm">Reset</button>
                  <label className="flex items-center gap-2 rounded-full border border-neutral-200 bg-white px-3 py-1 text-xs font-medium shadow-sm">
                    <input type="checkbox" ref={autoMasterRef} className="h-4 w-4" checked={allAuto} onChange={(e) => handleToggleAllAuto(e.target.checked)} />
                    Auto (todos)
                  </label>
                  <label className="flex items-center gap-2 rounded-full border border-neutral-200 bg-white px-3 py-1 text-xs font-medium shadow-sm">
                    <input type="checkbox" ref={collateralMasterRef} className="h-4 w-4" checked={allCollateral} onChange={(e) => handleToggleAllCollateral(e.target.checked)} />
                    Colateral (todos)
                  </label>
                  <label className="flex items-center gap-2 rounded-full border border-amber-200 bg-amber-50 px-3 py-1 text-xs font-medium text-amber-700 shadow-sm">
                    <input
                      type="checkbox"
                      className="h-4 w-4 accent-amber-500"
                      checked={!!params.manualLoanAllocation}
                      onChange={(e) => setParams({ ...params, manualLoanAllocation: e.target.checked })}
                    />
                    Asignar préstamo manualmente
                  </label>
                </div>
                {params.manualLoanAllocation && (
                  <p className="mt-2 text-center text-xs text-neutral-500">Distribuí el préstamo por activo en la columna "Préstamo asignado" para reflejar cómo Binance exige definir el colateral.</p>
                )}
              </div>

              <div className="overflow-x-auto rounded-2xl nx-card">
                <table className="min-w-full text-sm">
                  <thead className="bg-neutral-900 text-white sticky top-0 z-10">
                    <tr>
                      <Th>Activo</Th>
                      <Th>Ticker</Th>
                      <Th>Cantidad</Th>
                      <Th>Precio (USD)</Th>
                      <Th>Auto</Th>
                      <Th>Valor</Th>
                      <Th>Préstamo asignado (USD)</Th>
                      <Th>Colateral</Th>
                      <Th>LTV (fijo)</Th>
                      <Th>APR Earn (flex máx)</Th>
                      <Th></Th>
                    </tr>
                  </thead>
                  <tbody>
                    {totals.withValue.map((a) => (
                      <tr key={a.id} className="border-t border-neutral-100 even:bg-neutral-50 hover:bg-neutral-100/50 transition-colors">
                        <Td align="center">
                          <input value={a.name} onChange={(e) => handleAssetChange(a.id, { name: e.target.value })} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input value={a.ticker} onChange={(e) => { const newT = sanitizeTicker(e.target.value); const newL = ltvByTicker[newT] ?? defaultLtv; handleAssetChange(a.id, { ticker: newT, ltv: newL }); if (a.priceAuto !== false) { fetchPricesForTickers([newT]); } }} className="w-24 rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <LocaleNumberInput
                            value={a.qty}
                            onChange={(v) => handleAssetChange(a.id, { qty: Math.max(0, v) })}
                            decimals={4}
                            className={`w-full rounded-xl border border-neutral-300 px-2 py-1 text-center focus:outline-none focus:ring-2 ${focusRingClass}`}
                          />
                        </Td>
                        <Td align="center">
                          <LocaleNumberInput
                            value={a.price}
                            onChange={(v) => handleAssetChange(a.id, { price: Math.max(0, v) })}
                            decimals={4}
                            disabled={a.priceAuto !== false}
                            className={`w-full rounded-xl border border-neutral-300 px-2 py-1 text-center focus:outline-none focus:ring-2 ${focusRingClass} disabled:bg-neutral-50 disabled:text-neutral-400`}
                          />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" checked={a.priceAuto !== false} onChange={(e) => { handleAssetChange(a.id, { priceAuto: e.target.checked }); if (e.target.checked) { fetchPricesForTickers([a.ticker]); } }} className="h-5 w-5" />
                        </Td>
                        <Td align="center" className="font-medium">{formatUsd(a.value)}</Td>
                        <Td align="center">
                          <LocaleNumberInput
                            value={a.loanAssigned}
                            onChange={(v) => handleAssetChange(a.id, { loanAssigned: Math.max(0, v) })}
                            decimals={2}
                            disabled={!params.manualLoanAllocation}
                            className={`w-full rounded-xl border border-neutral-300 px-2 py-1 text-center focus:outline-none focus:ring-2 ${focusRingClass} ${!params.manualLoanAllocation ? 'bg-neutral-50 text-neutral-400' : ''}`}
                          />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" title="Si está activo, este activo cuenta como colateral para LTV y Tope por LTVs" checked={a.useAsCollateral} onChange={(e) => handleAssetChange(a.id, { useAsCollateral: e.target.checked })} className="h-5 w-5" />
                        </Td>
                        <Td align="center" title="Política de LTV fija por plataforma">
                          <span className="inline-block rounded-xl bg-neutral-100 px-3 py-1 font-semibold">{pct(ltvByTicker[sanitizeTicker(a.ticker)] ?? a.ltv ?? 0)}</span>
                        </Td>
                        <Td align="center" title="Flexible Savings – tasa tope mostrada públicamente">
                          <span className="inline-block rounded-xl bg-blue-50 text-blue-700 px-3 py-1 font-semibold">{pct(earnAprTop[sanitizeTicker(a.ticker)] ?? 0)}</span>
                        </Td>
                        <Td align="center">
                          <button onClick={() => removeRow(a.id)} className="nx-btn nx-btn-ghost nx-btn-sm">Borrar</button>
                        </Td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="mb-10">
              <Card title="Ideas para un simulador único">
                <p className="text-sm text-neutral-600">Backlog sugerido para diferenciar la herramienta y hacerla monetizable.</p>
                <ol className="mt-3 list-decimal space-y-3 pl-5 text-sm text-neutral-700">
                  {improvementIdeas.map((idea) => (
                    <li key={idea.id}>
                      <div className="font-semibold text-neutral-900">{idea.title}</div>
                      <p className="text-xs text-neutral-500 mt-1">{idea.description}</p>
                    </li>
                  ))}
                </ol>
              </Card>
            </section>

            {disclaimers?.finePrint && (
              <p className="mb-6 text-xs text-neutral-500 text-center">{disclaimers.finePrint}</p>
            )}

            <footer className="text-xs text-neutral-500 space-y-1 text-center md:text-left">
              <p>© {new Date().getFullYear()} – Demo técnica. Estilos y métricas se adaptan según la plataforma elegida.</p>
              <p>Activos digitales: actualización automática cada {LIVE_REFRESH_SECONDS} segundos (fuente CoinGecko). Tipos de cambio oficiales: actualización cada {FX_REFRESH_MINUTES} minutos (exchangerate.host).</p>
            </footer>
      </div>
    </div>
  );
}

    function CashflowPlanner({
      plan,
      derived,
      onPlanChange,
      currency,
      rate,
      fmt,
      loanAmount,
      chosenAPR,
      interestCalc,
      daysUntilRepay,
      repayDate,
      totals,
      targetLtv,
      marginCallLtv,
      autoRepayLtv,
      scenarioDefaults,
      focusRingClass,
      earnMonthly,
      earnEligible,
      minBalancePerks,
    }) {
      const safePlan = plan || {};
      const baseScenarios = { base: 0, bear: -0.25, bull: 0.15, ...(scenarioDefaults || {}) };
      const combinedShocks = { ...baseScenarios, ...(safePlan.scenarioShocks || {}), ...(derived?.scenarioShocks || {}) };
      const scenarioKeys = Object.keys(combinedShocks);
      const activeScenario = scenarioKeys.includes(safePlan.activeScenario)
        ? safePlan.activeScenario
        : (derived?.activeScenario && scenarioKeys.includes(derived.activeScenario) ? derived.activeScenario : scenarioKeys[0]);
      const timeline = derived?.timeline || [];
      const chartData = derived?.chartData || [];
      const fundingGaps = derived?.fundingGaps || [];
      const alerts = useMemo(
        () => normalizeAlertItems(derived?.alerts),
        [derived],
      );
      const netFinal = derived?.netBalanceFinal ?? loanAmount;
      const minNet = derived?.minNetBalance ?? netFinal;
      const outstandingPlan = derived?.netOutstandingAfterPlan ?? derived?.outstandingAfterPlan ?? loanAmount;
      const outstandingPrincipalPlan = derived?.outstandingAfterPlan ?? loanAmount;
      const outstandingInterestPlan = Math.max(0, outstandingPlan - outstandingPrincipalPlan);
      const scheduledPrincipalPlan = derived?.scheduledPrincipal ?? 0;
      const scheduledInterestPlan = derived?.scheduledInterest ?? 0;
      const projectedPayoffPlan = derived?.projectedFinalPayoff ?? Math.max(0, outstandingPlan);
      const totalScheduledOutflows = scheduledPrincipalPlan + scheduledInterestPlan;

      const scenarioLabels = { base: 'Base', bear: 'Bajista', bull: 'Alcista' };

      const loanByTicker = derived?.loanByTicker || {};
      const outstandingByTicker = derived?.outstandingByTicker || {};
      const paymentTickerOptions = useMemo(() => {
        const bucket = new Set();
        Object.keys(loanByTicker || {}).forEach((ticker) => {
          const key = normalizeTicker(ticker);
          if (key) bucket.add(key);
        });
        Object.keys(outstandingByTicker || {}).forEach((ticker) => {
          const key = normalizeTicker(ticker);
          if (key) bucket.add(key);
        });
        (totals?.withValue || []).forEach((asset) => {
          if (asset?.ticker) {
            const key = normalizeTicker(asset.ticker);
            if (key) bucket.add(key);
          }
        });
        return Array.from(bucket).sort();
      }, [loanByTicker, outstandingByTicker, totals?.withValue]);
      const defaultPaymentTicker = paymentTickerOptions[0] || '';

      const setScenarioShock = (key, valuePct) => {
        const pct = Number(valuePct);
        if (!Number.isFinite(pct)) return;
        onPlanChange((prev) => ({
          ...prev,
          scenarioShocks: { ...(prev?.scenarioShocks || {}), [key]: pct / 100 },
        }));
      };

      const setActiveScenario = (value) => {
        if (!scenarioKeys.includes(value)) return;
        onPlanChange({ activeScenario: value });
      };

      const updateListItem = (listName, id, patch) => {
        onPlanChange((prev) => ({
          ...prev,
          [listName]: (prev?.[listName] || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
        }));
      };

      const removeListItem = (listName, id) => {
        onPlanChange((prev) => ({
          ...prev,
          [listName]: (prev?.[listName] || []).filter((item) => item.id !== id),
        }));
      };

      const addPayment = () => {
        const nextId = Math.max(0, ...((safePlan.payments || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          payments: [...(prev?.payments || []), {
            id: nextId,
            date: repayDate,
            amount: Math.max(0, loanAmount || 0),
            label: `Pago ${nextId}`,
            ticker: defaultPaymentTicker,
          }],
        }));
      };

      const addEarn = () => {
        const nextId = Math.max(0, ...((safePlan.earns || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          earns: [...(prev?.earns || []), {
            id: nextId,
            startDate: todayISO(),
            endDate: repayDate,
            frequency: 'monthly',
            amount: Math.max(0, earnMonthly || 0),
            platform: '',
            token: '',
            label: `Earn ${nextId}`,
          }],
        }));
      };

      const addManual = () => {
        const nextId = Math.max(0, ...((safePlan.manual || []).map((p) => Number(p.id) || 0))) + 1;
        onPlanChange((prev) => ({
          ...prev,
          manual: [...(prev?.manual || []), {
            id: nextId,
            date: todayISO(),
            amount: 1000,
            direction: 'outflow',
            collateralImpact: 'increase',
            label: `Evento ${nextId}`,
          }],
        }));
      };

      const formatMoney = (value) => fmt(value * rate, currency);

      const summaryTiles = [
        { label: 'Balance final proyectado', value: formatMoney(netFinal), tone: netFinal >= 0 ? 'text-emerald-600' : 'text-rose-600', hint: `Mínimo ${formatMoney(minNet)}` },
        { label: 'Capital pendiente (plan)', value: formatMoney(outstandingPlan), tone: 'text-neutral-700', hint: outstandingPlan > 0 ? `Principal ${formatMoney(outstandingPrincipalPlan)} · Interés ${formatMoney(outstandingInterestPlan)}` : '—' },
        { label: 'Pagos programados', value: formatMoney(totalScheduledOutflows), tone: totalScheduledOutflows > 0 ? 'text-neutral-700' : 'text-neutral-500', hint: totalScheduledOutflows > 0 ? `Capital ${formatMoney(scheduledPrincipalPlan)} · Interés cancelado ${formatMoney(scheduledInterestPlan)}` : 'Sin pagos programados' },
        { label: 'Pago final proyectado', value: formatMoney(projectedPayoffPlan), tone: projectedPayoffPlan >= 0 ? 'text-neutral-700' : 'text-rose-600', hint: outstandingPlan > 0 ? 'Restante tras plan' : 'Cubierto por plan' },
        { label: 'Earn mensual', value: fmt(earnMonthly * rate, currency), tone: 'text-neutral-700', hint: earnEligible ? 'Earn activo' : (forceOn ? 'Earn forzado (sim)' : 'Earn inactivo') },
      ];

      return (
        <Card title="Planificador de cashflow">
          <div className="grid gap-6 text-sm lg:grid-cols-[1.1fr_minmax(0,1fr)]">
            <div className="space-y-6">
              <div className="grid grid-cols-1 gap-3 sm:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-5">
                {summaryTiles.map((tile) => (
                  <div key={tile.label} className="nx-tab px-4 py-3 text-neutral-700">
                    <div className="text-xs font-semibold uppercase tracking-wide text-neutral-600">{tile.label}</div>
                    <div className={`text-lg font-semibold ${tile.tone}`}>{tile.value}</div>
                    {tile.hint && <div className="text-[11px] text-neutral-600/80">{tile.hint}</div>}
                  </div>
                ))}
              </div>

              <div>
                <h4 className="mb-2 text-sm font-semibold text-neutral-700">Curva de saldo neto</h4>
                <TrendChart data={chartData} currency={currency} rate={rate} />
              </div>

          <div
            className="rounded-2xl border border-sky-200/70 p-4 space-y-4 shadow-sm"
            style={{ background: ACCENT_SURFACES.soft }}
          >
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <div>
                    <div className="text-sm font-semibold text-neutral-700">Escenarios de estrés</div>
                    <p className="text-xs text-neutral-500">Define shocks de precio (%) y selecciona cuál alimenta el velocímetro de LTV.</p>
                  </div>
                  <select value={activeScenario} onChange={(e) => setActiveScenario(e.target.value)} className={`rounded-full border border-neutral-300 px-3 py-1.5 text-sm font-semibold focus:outline-none focus:ring-2 ${focusRingClass}`}>
                    {scenarioKeys.map((key) => (
                      <option key={key} value={key}>{scenarioLabels[key] || key}</option>
                    ))}
                  </select>
                </div>
                <div className="grid grid-cols-1 gap-3 text-xs sm:grid-cols-2 xl:grid-cols-3">
                  {scenarioKeys.map((key) => (
                    <div key={`scenario-${key}`} className={`rounded-2xl border ${activeScenario === key ? 'border-blue-400 bg-blue-50/40' : 'border-neutral-200 bg-neutral-50/60'} p-3 space-y-2`}>
                      <div className="flex items-center justify-between">
                        <span className="font-semibold text-neutral-700">{scenarioLabels[key] || key}</span>
                        <LocaleNumberInput
                          value={(combinedShocks[key] ?? 0) * 100}
                          onChange={(v) => setScenarioShock(key, v)}
                          decimals={2}
                          allowNegative
                          className={`w-20 rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                        />
                      </div>
                      <div className="text-[11px] text-neutral-500">Shock sobre colateral</div>
                      <div className="text-[11px] text-neutral-600">LTV final: {derived?.scenarioSummaries?.[key]?.last != null && Number.isFinite(derived.scenarioSummaries[key].last) ? formatPercent(derived.scenarioSummaries[key].last, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) : '—'}</div>
                      <div className="text-[11px] text-neutral-600">Saldo: {derived?.scenarioSummaries?.[key]?.net != null ? formatMoney(derived.scenarioSummaries[key].net) : formatMoney(netFinal)}</div>
                    </div>
                  ))}
                </div>
                {alerts.length > 0 && (
                  <div className="space-y-2 text-xs">
                    {alerts.map((alert) => {
                      const tone = ALERT_TONE_STYLES[alert.tone] || ALERT_TONE_STYLES.info;
                      return (
                        <div
                          key={alert.id}
                          className={`rounded-2xl border px-3 py-2 ${tone.border} ${tone.bg} ${tone.text}`}
                        >
                          {alert.message}
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>

              {fundingGaps.length > 0 && (
                <div className="rounded-2xl border border-rose-200 bg-rose-50 px-4 py-3 text-xs text-rose-700">
                  <div className="font-semibold mb-1">Gaps de liquidez detectados</div>
                  <ul className="list-disc pl-5 space-y-1">
                    {fundingGaps.map((gap, idx) => (
                      <li key={`gap-${idx}`}>Día {gap.day} ({gap.date}) · saldo neto {formatMoney(gap.net)}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>

            <div className="space-y-6">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-sm font-semibold text-neutral-700">Pagos programados</h4>
                  <button className="nx-btn nx-btn-sm" onClick={addPayment}>Agregar pago</button>
                </div>
                <div className="space-y-3">
                  {(safePlan.payments || []).length === 0 && (
                    <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">No hay pagos definidos. Añade uno para proyectar obligaciones.</div>
                  )}
                  {(safePlan.payments || []).map((item) => (
                    <div
                      key={item.id}
                      className="grid grid-cols-1 md:grid-cols-5 gap-2 rounded-2xl border border-sky-200/70 px-4 py-3 text-xs shadow-sm"
                      style={{ background: ACCENT_SURFACES.halo }}
                    >
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Fecha</div>
                        <input type="date" value={item.date || ''} onChange={(e) => updateListItem('payments', item.id, { date: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Monto total</div>
                        <LocaleNumberInput
                          value={item.amount ?? item.principal ?? 0}
                          onChange={(v) => updateListItem('payments', item.id, { amount: Math.max(0, v) })}
                          decimals={2}
                          min={0}
                          className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                        />
                        <div className="mt-1 text-[10px] text-neutral-500">Se descuenta interés acumulado primero.</div>
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Cripto</div>
                        <select
                          value={item.ticker || ''}
                          onChange={(e) => updateListItem('payments', item.id, { ticker: normalizeTicker(e.target.value) })}
                          className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}
                        >
                          <option value="">General / proporcional</option>
                          {paymentTickerOptions.map((ticker) => (
                            <option key={`payment-token-${ticker}`} value={ticker}>{ticker}</option>
                          ))}
                        </select>
                      </div>
                      <div className="md:col-span-1">
                        <div className="text-[11px] uppercase text-neutral-400">Nota</div>
                        <input type="text" value={item.label || ''} onChange={(e) => updateListItem('payments', item.id, { label: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      </div>
                      <div className="flex items-end justify-end sm:col-span-2 xl:col-span-1">
                        <button className="text-rose-600 hover:underline" onClick={() => removeListItem('payments', item.id)}>Eliminar</button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-sm font-semibold text-neutral-700">Flujos de Earn / staking</h4>
                  <button className="nx-btn nx-btn-sm" onClick={addEarn}>Agregar flujo</button>
                </div>
                <div className="space-y-3">
                  {(safePlan.earns || []).length === 0 && (
                    <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">Suma tus estrategias de rendimiento para cubrir el costo del préstamo.</div>
                  )}
                  {(safePlan.earns || []).map((item) => (
                    <div
                      key={item.id}
                      className="grid grid-cols-1 gap-2 sm:grid-cols-2 xl:grid-cols-6 rounded-2xl border border-sky-200/70 px-4 py-3 text-xs shadow-sm"
                      style={{ background: ACCENT_SURFACES.halo }}
                    >
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Inicio</div>
                        <input type="date" value={item.startDate || ''} onChange={(e) => updateListItem('earns', item.id, { startDate: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Fin</div>
                        <input type="date" value={item.endDate || ''} onChange={(e) => updateListItem('earns', item.id, { endDate: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Frecuencia</div>
                        <select value={item.frequency || 'monthly'} onChange={(e) => updateListItem('earns', item.id, { frequency: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                          <option value="daily">Diario</option>
                          <option value="weekly">Semanal</option>
                          <option value="monthly">Mensual</option>
                        </select>
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Monto</div>
                        <LocaleNumberInput
                          value={item.amount ?? 0}
                          onChange={(v) => updateListItem('earns', item.id, { amount: Math.max(0, v) })}
                          decimals={2}
                          min={0}
                          className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                        />
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Origen</div>
                        <input type="text" value={item.platform || ''} onChange={(e) => updateListItem('earns', item.id, { platform: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      </div>
                      <div className="flex items-end justify-between gap-2 sm:col-span-2 xl:col-span-1">
                        <input type="text" value={item.token || ''} placeholder="Token" onChange={(e) => updateListItem('earns', item.id, { token: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                        <button className="text-rose-600 hover:underline" onClick={() => removeListItem('earns', item.id)}>Eliminar</button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-sm font-semibold text-neutral-700">Eventos manuales</h4>
                  <button className="nx-btn nx-btn-sm" onClick={addManual}>Agregar evento</button>
                </div>
                <div className="space-y-3">
                  {(safePlan.manual || []).length === 0 && (
                    <div className="rounded-xl border border-neutral-200 bg-neutral-50 px-4 py-3 text-xs text-neutral-500">Registra recargas de colateral o retiros planificados.</div>
                  )}
                  {(safePlan.manual || []).map((item) => (
                    <div
                      key={item.id}
                      className="grid grid-cols-1 gap-2 sm:grid-cols-2 xl:grid-cols-5 rounded-2xl border border-sky-200/70 px-4 py-3 text-xs shadow-sm"
                      style={{ background: ACCENT_SURFACES.halo }}
                    >
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Fecha</div>
                        <input type="date" value={item.date || ''} onChange={(e) => updateListItem('manual', item.id, { date: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Monto</div>
                        <LocaleNumberInput
                          value={item.amount ?? 0}
                          onChange={(v) => updateListItem('manual', item.id, { amount: v })}
                          decimals={2}
                          allowNegative
                          className={`w-full rounded-full border border-neutral-300 px-2 py-1 text-right focus:outline-none focus:ring-2 ${focusRingClass}`}
                        />
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Dirección</div>
                        <select value={item.direction || 'outflow'} onChange={(e) => updateListItem('manual', item.id, { direction: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                          <option value="outflow">Salida</option>
                          <option value="inflow">Entrada</option>
                        </select>
                      </div>
                      <div>
                        <div className="text-[11px] uppercase text-neutral-400">Colateral</div>
                        <select value={item.collateralImpact || 'increase'} onChange={(e) => updateListItem('manual', item.id, { collateralImpact: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`}>
                          <option value="increase">Aumenta</option>
                          <option value="decrease">Disminuye</option>
                          <option value="none">Sin cambio</option>
                        </select>
                      </div>
                      <div className="flex items-end justify-between gap-2 sm:col-span-2 xl:col-span-1">
                        <input type="text" value={item.label || ''} placeholder="Descripción" onChange={(e) => updateListItem('manual', item.id, { label: e.target.value })} className={`w-full rounded-full border border-neutral-300 px-2 py-1 focus:outline-none focus:ring-2 ${focusRingClass}`} />
                        <button className="text-rose-600 hover:underline" onClick={() => removeListItem('manual', item.id)}>Eliminar</button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border border-neutral-200 bg-neutral-50/70 px-4 py-3 text-[11px] text-neutral-600 space-y-1">
                <div>APR: {formatPercent(chosenAPR, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} · Interés total estimado: {formatMoney(interestCalc?.total || 0)} · Plazo restante: {daysUntilRepay} días</div>
                <div>Colateral: {formatMoney(totals.totalCollateralValue || 0)} · Objetivo LTV: {formatPercent(targetLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })} · Margin call: {formatPercent(marginCallLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })} · Auto-repay: {formatPercent(autoRepayLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</div>
              </div>
            </div>
          </div>
        </Card>
      );
    }

    function computeCashflowProjectionsDetailed(plan, context = {}) {
      const {
        loanAmount = 0,
        apr = 0,
        repayDate,
        totalCollateralValue = 0,
        targetLtv = 0.2,
        marginCallLtv = 0.7,
        autoRepayLtv = 0.85,
        scenarioShocks = {},
        controls = {},
      } = context;
      const safePlan = plan || {};
      const baseScenarios = { base: 0, bear: -0.25, bull: 0.15, ...(safePlan.scenarioShocks || {}), ...(scenarioShocks || {}) };
      const sigmaCandidate = Number(controls?.sigmaK);
      const sigmaScale = Number.isFinite(sigmaCandidate) ? sigmaCandidate : 1;
      const scenarioShockMap = Object.keys(baseScenarios).reduce((acc, key) => {
        const raw = Number(baseScenarios[key]) || 0;
        acc[key] = raw * sigmaScale;
        return acc;
      }, {});
      const scenarioKeys = Object.keys(scenarioShockMap);
      const activeScenario = scenarioKeys.includes(safePlan.activeScenario) ? safePlan.activeScenario : scenarioKeys[0];
      const msInDay = 24 * 60 * 60 * 1000;
      const today = new Date(); today.setHours(0, 0, 0, 0);
      const parseDate = (value, fallback) => {
        if (value instanceof Date && !Number.isNaN(value.getTime())) {
          const d = new Date(value.getTime()); d.setHours(0, 0, 0, 0); return d;
        }
        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
          const d = new Date(value); if (!Number.isNaN(d.getTime())) { d.setHours(0,0,0,0); return d; }
        }
        return fallback ? new Date(fallback.getTime()) : new Date(today.getTime());
      };
      const endDate = parseDate(repayDate, today);
      const events = [];
      const pushEvent = (event) => {
        const date = parseDate(event.date, today);
        events.push({ ...event, date });
      };
      pushEvent({ id: 'loan', type: 'loan', date: today, amount: loanAmount, label: 'Desembolso' });

      (safePlan.payments || []).forEach((item, idx) => {
        const total = Math.max(0, Number(item.amount ?? item.principal) || 0);
        if (!(total > 0)) return;
        pushEvent({
          id: `payment-${item.id ?? idx}`,
          type: 'payment',
          date: item.date || endDate,
          label: item.label || `Pago ${idx + 1}`,
          amount: -total,
          paymentTotal: total,
          ticker: item.ticker ? normalizeTicker(item.ticker) : undefined,
        });
      });

      const freqToDays = { daily: 1, weekly: 7, monthly: 30 };
      (safePlan.earns || []).forEach((item, idx) => {
        const step = freqToDays[item.frequency] || 30;
        const amount = Number(item.amount) || 0;
        if (!(amount > 0) || step <= 0) return;
        let current = parseDate(item.startDate, today);
        const limit = parseDate(item.endDate, endDate);
        let count = 0;
        while (current.getTime() <= limit.getTime() && count < 120) {
          pushEvent({ id: `earn-${item.id ?? idx}-${count}`, type: 'earn', date: current, label: item.label || `Earn ${idx + 1}`, amount });
          current = new Date(current.getTime() + step * msInDay);
          count += 1;
        }
      });

      (safePlan.manual || []).forEach((item, idx) => {
        const amount = Number(item.amount) || 0;
        if (!(amount > 0)) return;
        const direction = item.direction === 'inflow' ? 1 : -1;
        const impact = item.collateralImpact;
        const collateralDelta = impact === 'increase' ? amount : impact === 'decrease' ? -amount : 0;
        pushEvent({
          id: `manual-${item.id ?? idx}`,
          type: 'manual',
          date: item.date || today,
          label: item.label || `Evento ${idx + 1}`,
          amount: amount * direction,
          collateralDelta,
        });
      });

      events.sort((a, b) => a.date.getTime() - b.date.getTime());

      let outstanding = loanAmount;
      let collateral = Math.max(0, totalCollateralValue);
      let cumulativeCash = 0;
      let accruedInterest = 0;
      let totalEarn = 0;
      let totalOutflows = 0;
      let scheduledPrincipal = 0;
      let scheduledInterest = 0;
      let collateralDeltaTotal = 0;
      let projectedFinalPayoff = 0;
      let minNet = Number.POSITIVE_INFINITY;
      const timeline = [];
      const alerts = [];
      const fundingGaps = [];
      const scenarioSummaries = {};
      scenarioKeys.forEach((key) => { scenarioSummaries[key] = { last: 0, net: loanAmount, max: 0 }; });

      let lastDate = today;
      const addSnapshot = (event) => {
        const day = Math.max(0, Math.round((event.date.getTime() - today.getTime()) / msInDay));
        const scenarioStats = {};
        scenarioKeys.forEach((key) => {
          const shock = Number(scenarioShockMap[key]) || 0;
          const adjustedCollateral = collateral * (1 + shock);
          const ltv = adjustedCollateral > 0 ? outstanding / adjustedCollateral : (outstanding > 0 ? Number.POSITIVE_INFINITY : 0);
          scenarioStats[key] = ltv;
          scenarioSummaries[key].last = ltv;
          scenarioSummaries[key].net = cumulativeCash - accruedInterest;
          scenarioSummaries[key].max = Math.max(scenarioSummaries[key].max || 0, Number.isFinite(ltv) ? ltv : 0);
          if (ltv >= autoRepayLtv) {
            alerts.push(`Escenario ${key} supera auto-liquidación (${formatPercent(autoRepayLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}) en día ${day}.`);
          } else if (ltv >= marginCallLtv) {
            alerts.push(`Escenario ${key} supera margin call (${formatPercent(marginCallLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}) en día ${day}.`);
          }
        });
        const netBalance = cumulativeCash - accruedInterest;
        minNet = Math.min(minNet, netBalance);
        if (netBalance < 0) {
          const existingGap = fundingGaps.find((gap) => gap.day === day);
          if (!existingGap) fundingGaps.push({ day, date: event.date.toISOString().slice(0, 10), net: netBalance });
        }
        timeline.push({
          id: event.id,
          type: event.type,
          label: event.label,
          date: event.date.toISOString().slice(0, 10),
          day,
          amount: event.amount,
          interestAccrued: accruedInterest,
          cashCumulative: cumulativeCash,
          netBalance,
          outstanding,
          scenarioStats,
          totalCost: totalOutflows,
          totalEarn,
        });
        lastDate = event.date;
      };

      events.forEach((event) => {
        const deltaDays = Math.max(0, Math.round((event.date.getTime() - lastDate.getTime()) / msInDay));
        if (deltaDays > 0 && outstanding > 0) {
          const interest = outstanding * (Math.pow(1 + apr / 365, deltaDays) - 1);
          accruedInterest += interest;
        }
        cumulativeCash += event.amount || 0;
        if ((event.amount || 0) >= 0) totalEarn += event.amount || 0; else totalOutflows += Math.abs(event.amount || 0);
        if (event.type === 'payment') {
          const totalPayment = Math.max(0, Number(event.paymentTotal) || Math.abs(event.amount) || 0);
          if (totalPayment > 0) {
            let remainingPayment = totalPayment;
            const interestPaid = Math.min(accruedInterest, remainingPayment);
            if (interestPaid > 0) {
              scheduledInterest += interestPaid;
              accruedInterest = Math.max(0, accruedInterest - interestPaid);
              remainingPayment -= interestPaid;
            }
            if (remainingPayment > 0) {
              const principalPaid = Math.min(outstanding, remainingPayment);
              if (principalPaid > 0) {
                scheduledPrincipal += principalPaid;
                outstanding = Math.max(0, outstanding - principalPaid);
                remainingPayment -= principalPaid;
              }
            }
            if (remainingPayment > 0) {
              cumulativeCash += remainingPayment;
              totalOutflows = Math.max(0, totalOutflows - remainingPayment);
            }
          }
        }
        if (event.collateralDelta) {
          const delta = Number(event.collateralDelta) || 0;
          collateralDeltaTotal += delta;
          collateral = Math.max(0, collateral + delta);
        }
        addSnapshot(event);
      });

      if (endDate.getTime() > lastDate.getTime() && outstanding > 0) {
        const deltaDays = Math.max(0, Math.round((endDate.getTime() - lastDate.getTime()) / msInDay));
        if (deltaDays > 0) {
          const interest = outstanding * (Math.pow(1 + apr / 365, deltaDays) - 1);
          accruedInterest += interest;
        }
        addSnapshot({ id: 'carry', type: 'carry', label: 'Interés acumulado', date: endDate, amount: 0 });
      }

      const outstandingAfterPlan = outstanding;
      const collateralAfterPlan = collateral;
      const accruedAfterPlan = accruedInterest;

      if (outstanding > 0 || accruedInterest > 0) {
        projectedFinalPayoff = outstanding + accruedInterest;
        const payoff = -projectedFinalPayoff;
        cumulativeCash += payoff;
        totalOutflows += Math.abs(payoff);
        outstanding = 0;
        accruedInterest = 0;
        addSnapshot({ id: 'closure', type: 'closure', label: 'Pago final proyectado', date: endDate, amount: payoff });
      }

      const chartData = timeline.map((item) => ({ day: item.day, cost: item.totalCost, earn: item.totalEarn, balance: item.netBalance }));
      const uniqueAlerts = [...new Set(alerts)];
      const scenarioLabel = { base: 'Escenario base', bear: 'Escenario bajista', bull: 'Escenario alcista' }[activeScenario] || activeScenario;
      const firstSnapshot = timeline.length ? timeline[0] : null;
      const currentGaugeLtv = firstSnapshot && Number.isFinite(firstSnapshot.scenarioStats?.[activeScenario])
        ? firstSnapshot.scenarioStats[activeScenario]
        : (totalCollateralValue > 0 ? loanAmount / totalCollateralValue : 0);
      const peakGaugeLtv = timeline.reduce((max, item) => {
        const value = item.scenarioStats?.[activeScenario];
        return Number.isFinite(value) ? Math.max(max, value) : max;
      }, Number.NEGATIVE_INFINITY);
      const safePeakLtv = Number.isFinite(peakGaugeLtv) && peakGaugeLtv >= 0 ? peakGaugeLtv : currentGaugeLtv;

      return {
        timeline,
        chartData,
        alerts: uniqueAlerts,
        fundingGaps,
        netBalanceFinal: timeline.length ? timeline[timeline.length - 1].netBalance : loanAmount,
        minNetBalance: Number.isFinite(minNet) ? minNet : loanAmount,
        lastOutstanding: outstandingAfterPlan,
        outstandingAfterPlan,
        collateralAfterPlan,
        collateralDeltaPlanned: collateralDeltaTotal,
        scheduledPrincipal,
        scheduledInterest,
        totalCost: totalOutflows,
        totalEarn,
        projectedFinalPayoff,
        accruedInterestAfterPlan: accruedAfterPlan,
        scenarioSummaries,
        scenarioShocks: baseScenarios,
        activeScenario,
        ltvForGauge: currentGaugeLtv,
        ltvCurrent: currentGaugeLtv,
        ltvPeak: safePeakLtv,
        scenarioLabel,
      };
    }

    function BenchmarkCeFiDeFi({
      config,
      onChange,
      fmt,
      currency,
      rate,
      loanAmount,
      chosenAPR,
      daysUntilRepay,
      scenarioName,
      cashflowNet,
      defaultMatrix,
    }) {
      const safeConfig = config || {};
      const matrix = safeConfig.rateMatrix || [];
      const strategies = safeConfig.strategies || [];
      const termDays = Math.max(1, daysUntilRepay || 0);
      const baseAmount = loanAmount || 0;

      const updateRate = (id, patch) => onChange((prev) => ({
        ...prev,
        rateMatrix: (prev?.rateMatrix || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
      }));

      const removeRate = (id) => onChange((prev) => ({
        ...prev,
        rateMatrix: (prev?.rateMatrix || []).filter((item) => item.id !== id),
      }));

      const addRate = () => {
        const nextId = `rate-${Math.max(0, ...matrix.map((item) => Number(String(item.id).replace(/\D/g, '')) || 0)) + 1}`;
        onChange((prev) => ({
          ...prev,
          rateMatrix: [...(prev?.rateMatrix || []), { id: nextId, platform: 'Plataforma', product: 'Producto', type: 'APR', value: chosenAPR || 0 }],
        }));
      };

      const updateStrategy = (id, patch) => onChange((prev) => ({
        ...prev,
        strategies: (prev?.strategies || []).map((item) => (item.id === id ? { ...item, ...patch } : item)),
      }));

      const removeStrategy = (id) => onChange((prev) => ({
        ...prev,
        strategies: (prev?.strategies || []).filter((item) => item.id !== id),
      }));

      const addStrategy = () => {
        const nextId = `strategy-${Math.max(0, ...strategies.map((item) => Number(String(item.id).replace(/\D/g, '')) || 0)) + 1}`;
        const loanRate = matrix[0]?.id || defaultMatrix?.[0]?.id || 'loan-default';
        const yieldRate = matrix[1]?.id || defaultMatrix?.[1]?.id || 'yield-default';
        onChange((prev) => ({
          ...prev,
          strategies: [...(prev?.strategies || []), {
            id: nextId,
            label: `Estrategia ${nextId}`,
            lenderRateId: loanRate,
            yieldRateId: yieldRate,
            apr: matrix.find((r) => r.id === loanRate)?.value ?? chosenAPR ?? 0,
            apy: matrix.find((r) => r.id === yieldRate)?.value ?? 0,
            feesIn: 0,
            feesOut: 0,
            riskCeFiLender: true,
            riskDeFiYield: false,
            riskNewProtocol: false,
          }],
        }));
      };

      const findRate = (id) => matrix.find((item) => item.id === id);

      const computeResult = (strategy) => {
        const amount = strategy.amountOverride != null ? Number(strategy.amountOverride) || 0 : baseAmount;
        const apr = Number.isFinite(strategy.apr) ? strategy.apr : (findRate(strategy.lenderRateId)?.value || 0);
        const apy = Number.isFinite(strategy.apy) ? strategy.apy : (findRate(strategy.yieldRateId)?.value || 0);
        const fees = (Number(strategy.feesIn) || 0) + (Number(strategy.feesOut) || 0);
        const interestPaid = amount > 0 ? amount * (Math.pow(1 + apr / 365, termDays) - 1) : 0;
        const interestEarned = amount > 0 ? amount * (Math.pow(1 + apy / 365, termDays) - 1) : 0;
        const spread = interestEarned - interestPaid - fees;
        const netPct = amount > 0 ? Math.max(-0.99, spread / amount) : 0;
        const annualized = termDays > 0 ? (Math.pow(1 + netPct, 365 / termDays) - 1) : 0;
        const riskPenalty = (strategy.riskDeFiYield ? 0.02 : 0) + (strategy.riskNewProtocol ? 0.03 : 0) + (strategy.riskCeFiLender ? 0 : 0.01);
        return {
          spread,
          annualized,
          adjustedAnnual: annualized - riskPenalty,
          amount,
          apr,
          apy,
          fees,
          interestPaid,
          interestEarned,
        };
      };

      const results = strategies.map((strategy) => ({ strategy, metrics: computeResult(strategy) }));
      const ranked = [...results].sort((a, b) => (b.metrics.adjustedAnnual || 0) - (a.metrics.adjustedAnnual || 0));

      const formatMoney = (value) => fmt(value * rate, currency);

      return (
        <Card title="Benchmark CeFi vs. CeFi/DeFi">
          <div className="space-y-6 text-xs">
            <div
              className="rounded-2xl border border-sky-200/70 px-4 py-3 space-y-1 text-neutral-600 shadow-sm"
              style={{ background: ACCENT_SURFACES.soft }}
            >
              <div>Monto base: {formatMoney(baseAmount)} · APR préstamo: {formatPercent(chosenAPR, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} · Plazo: {termDays} días</div>
              <div>Escenario cashflow: {scenarioName || 'Base'} · Saldo neto proyectado: {cashflowNet != null ? formatMoney(cashflowNet) : '—'}</div>
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Matriz de tasas</h4>
                <button className="nx-btn nx-btn-sm" onClick={addRate}>Agregar tasa</button>
              </div>
              <div className="space-y-2">
                {matrix.length === 0 && (
                  <div
                    className="rounded-xl border border-sky-200/70 px-4 py-3 text-neutral-500 shadow-sm"
                    style={{ background: ACCENT_SURFACES.soft }}
                  >
                    Define al menos una tasa APR/APY para combinar estrategias.
                  </div>
                )}
                {matrix.map((item) => (
                  <div
                    key={item.id}
                    className="grid grid-cols-1 gap-2 md:grid-cols-[minmax(0,1.5fr)_minmax(0,1.5fr)_minmax(0,0.8fr)_minmax(0,0.9fr)_minmax(0,0.6fr)] rounded-2xl border border-sky-200/70 px-4 py-3 shadow-sm"
                    style={{ background: ACCENT_SURFACES.halo }}
                  >
                    <input type="text" value={item.platform || ''} onChange={(e) => updateRate(item.id, { platform: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1" placeholder="Plataforma" />
                    <input type="text" value={item.product || ''} onChange={(e) => updateRate(item.id, { product: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1" placeholder="Producto" />
                    <select value={item.type || 'APR'} onChange={(e) => updateRate(item.id, { type: e.target.value })} className="rounded-full border border-neutral-300 px-2 py-1">
                      <option value="APR">APR</option>
                      <option value="APY">APY</option>
                    </select>
                    <LocaleNumberInput
                      value={item.value ?? 0}
                      onChange={(v) => updateRate(item.id, { value: v })}
                      decimals={2}
                      className="rounded-full border border-neutral-300 px-2 py-1 text-right"
                    />
                    <div className="flex items-end justify-end">
                      <button className="text-rose-600 hover:underline" onClick={() => removeRate(item.id)}>Eliminar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold text-neutral-700">Estrategias</h4>
                <button className="nx-btn nx-btn-sm" onClick={addStrategy}>Agregar estrategia</button>
              </div>
              <div className="space-y-3">
                {strategies.length === 0 && (
                  <div
                    className="rounded-xl border border-sky-200/70 px-4 py-3 text-neutral-500 shadow-sm"
                    style={{ background: ACCENT_SURFACES.soft }}
                  >
                    Crea combinaciones préstamo → rendimiento para medir el spread neto.
                  </div>
                )}
                {strategies.map((strategy) => {
                  const metrics = computeResult(strategy);
                  const position = ranked.findIndex((item) => item.strategy.id === strategy.id) + 1;
                  return (
                    <div
                      key={strategy.id}
                      className="grid grid-cols-1 gap-2 md:grid-cols-[minmax(0,1.8fr)_minmax(0,1.2fr)_minmax(0,1.1fr)_minmax(0,1.1fr)_minmax(0,0.9fr)_minmax(0,0.6fr)] rounded-2xl border border-sky-200/70 px-4 py-3 shadow-sm"
                      style={{ background: ACCENT_SURFACES.halo }}
                    >
                      <div className="md:col-span-2 space-y-1">
                        <input type="text" value={strategy.label || ''} onChange={(e) => updateStrategy(strategy.id, { label: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1" placeholder="Nombre de la estrategia" />
                        <select value={strategy.lenderRateId || ''} onChange={(e) => updateStrategy(strategy.id, { lenderRateId: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1">
                          <option value="">Sin tasa</option>
                          {matrix.map((item) => <option key={`lend-${item.id}`} value={item.id}>{item.platform} · {item.product}</option>)}
                        </select>
                        <LocaleNumberInput
                          value={strategy.apr ?? metrics.apr}
                          onChange={(v) => updateStrategy(strategy.id, { apr: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                        />
                      </div>
                      <div className="space-y-1">
                        <select value={strategy.yieldRateId || ''} onChange={(e) => updateStrategy(strategy.id, { yieldRateId: e.target.value })} className="w-full rounded-full border border-neutral-300 px-2 py-1">
                          <option value="">Sin tasa</option>
                          {matrix.map((item) => <option key={`yield-${item.id}`} value={item.id}>{item.platform} · {item.product}</option>)}
                        </select>
                        <LocaleNumberInput
                          value={strategy.apy ?? metrics.apy}
                          onChange={(v) => updateStrategy(strategy.id, { apy: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                        />
                        <LocaleNumberInput
                          value={Number.isFinite(strategy.amountOverride) ? strategy.amountOverride : null}
                          onChange={(v) => updateStrategy(strategy.id, { amountOverride: v == null ? null : v })}
                          decimals={2}
                          allowEmpty
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                          placeholder="Monto personalizado"
                        />
                      </div>
                      <div className="space-y-1">
                        <LocaleNumberInput
                          value={strategy.feesIn ?? 0}
                          onChange={(v) => updateStrategy(strategy.id, { feesIn: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                          placeholder="Fee entrada"
                        />
                        <LocaleNumberInput
                          value={strategy.feesOut ?? 0}
                          onChange={(v) => updateStrategy(strategy.id, { feesOut: v })}
                          decimals={2}
                          className="w-full rounded-full border border-neutral-300 px-2 py-1 text-right"
                          placeholder="Fee salida"
                        />
                        <div className="text-[11px] text-neutral-500">Spread: {formatMoney(metrics.spread)}</div>
                      </div>
                      <div className="space-y-1 text-[11px] text-neutral-600">
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskCeFiLender !== false} onChange={(e) => updateStrategy(strategy.id, { riskCeFiLender: e.target.checked })} /> Custodia CeFi</label>
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskDeFiYield === true} onChange={(e) => updateStrategy(strategy.id, { riskDeFiYield: e.target.checked })} /> Yield DeFi</label>
                        <label className="flex items-center gap-2"><input type="checkbox" checked={strategy.riskNewProtocol === true} onChange={(e) => updateStrategy(strategy.id, { riskNewProtocol: e.target.checked })} /> Smart contract nuevo</label>
                      </div>
                      <div className="space-y-1">
                        <div className={`text-sm font-semibold ${metrics.spread >= 0 ? 'text-emerald-600' : 'text-rose-600'}`}>{formatMoney(metrics.spread)}</div>
                        <div className="text-[11px] text-neutral-500">Anualizado: {formatPercent(metrics.annualized, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                        <div className="text-[11px] text-neutral-500">Ajustado riesgo: {formatPercent(metrics.adjustedAnnual, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                      </div>
                      <div className="flex items-end justify-between gap-2">
                        <div className="text-sm font-semibold text-neutral-700">#{position || '–'}</div>
                        <button className="text-rose-600 hover:underline" onClick={() => removeStrategy(strategy.id)}>Eliminar</button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            {ranked.length > 0 && (
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                {ranked.slice(0, 3).map((item, idx) => (
                  <div key={`rank-${item.strategy.id}`} className="nx-tab px-4 py-3 text-neutral-700">
                    <div className="text-[11px] uppercase text-neutral-400">Top {idx + 1}</div>
                    <div className="text-sm font-semibold text-neutral-700">{item.strategy.label || item.strategy.id}</div>
                    <div className="text-[11px] text-neutral-500">Spread ajustado {formatPercent(item.metrics.adjustedAnnual, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                    <div className="text-[11px] text-neutral-500">Spread neto {formatMoney(item.metrics.spread)}</div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </Card>
      );
    }

    // UI helpers (pocas funciones y tono visual)
    function KPI({ title, value, subtle, tone, variant }) {
      const toneCls = tone === 'ok' ? 'text-emerald-200' : tone === 'danger' ? 'text-rose-200' : '';
      const baseCls = variant === 'button' ? 'nx-kpi-btn' : 'bg-white nx-kpi';
      return (
        <div className={`relative overflow-hidden rounded-2xl p-4 shadow-sm transition-transform duration-200 ${baseCls} cursor-pointer`} role="button" aria-label={title}>
          <div className={`text-xs uppercase tracking-wide text-center ${variant==='button' ? 'text-white/80' : 'text-neutral-500'}`}>{title}</div>
          <div className={`mt-1 text-xl font-bold text-center ${toneCls}`}>{value}</div>
          {subtle && <div className={`text-xs mt-1 text-center ${variant==='button' ? 'text-white/70' : 'text-neutral-500'}`}>{subtle}</div>}
        </div>
      );
    }
    function Card({ title, children }) {
      return (
        <div className="flex h-full flex-col rounded-2xl p-5 nx-card">
          <div className="mb-4 text-center">
            <h3 className="text-lg font-semibold tracking-tight text-neutral-800">{title}</h3>
          </div>
          <div className="flex-1">
            {children}
          </div>
        </div>
      );
    }
    function Field({ label, children, align = "left", className = "" }) {
      const centered = align === "center";
      return (
        <label className={`${centered ? "flex flex-col items-center text-center gap-2 text-sm" : "block text-sm"} ${className}`}>
          <div className={`text-neutral-700 font-medium ${centered ? "text-base" : "mb-1"}`}>{label}</div>
          {children}
        </label>
      );
    }
    function LocaleNumberInput({
      value,
      onChange,
      decimals = 2,
      min,
      max,
      allowNegative = false,
      allowEmpty = false,
      className = '',
      onFocus,
      onBlur,
      disabled,
      ...rest
    }) {
      const safeDecimals = Math.max(decimals ?? 2, 2);
      const [display, setDisplay] = useState(() => formatNumberForInput(value, safeDecimals));
      const [focused, setFocused] = useState(false);
      useEffect(() => {
        if (focused) return;
        setDisplay(formatNumberForInput(value, safeDecimals));
      }, [value, focused, safeDecimals]);

      const clamp = (num) => {
        let next = Number.isFinite(num) ? num : 0;
        if (typeof min === 'number') next = Math.max(min, next);
        if (typeof max === 'number') next = Math.min(max, next);
        return next;
      };

      const updateValue = (raw) => {
        if (disabled) return;
        let sanitized = `${raw}`.replace(/\s+/g, '');
        if (!allowNegative) sanitized = sanitized.replace(/-/g, '');
        const hasNegative = allowNegative && /^-/.test(raw);
        sanitized = sanitized.replace(/[^0-9.,]/g, '');
        sanitized = sanitized.replace(/\./g, ',');
        const parts = sanitized.split(',');
        const integerPart = (parts.shift() || '').replace(/[^0-9]/g, '');
        const fractionRaw = parts.join('');
        const fractionPart = safeDecimals > 0 ? fractionRaw.slice(0, safeDecimals) : '';
        const rebuilt = `${hasNegative ? '-' : ''}${integerPart}${fractionPart ? `,${fractionPart}` : ''}`;
        setDisplay(rebuilt);
        if (rebuilt === '') {
          if (allowEmpty) {
            onChange?.(null);
          } else {
            const next = clamp(0);
            onChange?.(next);
          }
          return;
        }
        const parsed = parseLocaleNumber(rebuilt);
        if (!Number.isFinite(parsed)) return;
        const next = clamp(parsed);
        onChange?.(next);
      };

      const handleBlur = (event) => {
        setFocused(false);
        const parsed = parseLocaleNumber(display);
        if (Number.isFinite(parsed)) {
          const next = clamp(parsed);
          setDisplay(formatNumberForInput(next, safeDecimals));
          onChange?.(next);
        } else {
          if (allowEmpty && display === '') {
            onChange?.(null);
            setDisplay('');
            onBlur?.(event);
            return;
          }
          setDisplay(formatNumberForInput(clamp(value ?? 0), safeDecimals));
        }
        onBlur?.(event);
      };

      const handleFocus = (event) => {
        setFocused(true);
        setDisplay((prev) => (typeof prev === 'string' ? prev.replace(/\./g, '') : prev));
        onFocus?.(event);
        requestAnimationFrame(() => event.target.select?.());
      };

      return (
        <input
          type="text"
          inputMode="decimal"
          value={display}
          onChange={(e) => updateValue(e.target.value)}
          onFocus={handleFocus}
          onBlur={handleBlur}
          className={className}
          disabled={disabled}
          {...rest}
        />
      );
    }

    function NumberParam({ label, value, onChange, step = 1, ringClass = "focus:ring-blue-700" }) {
      const decimals = inferFractionDigits(step, 2);
      return (
        <Field label={label}>
          <LocaleNumberInput
            value={value}
            onChange={onChange}
            decimals={decimals}
            className={`w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 ${ringClass} text-right`}
          />
        </Field>
      );
    }
    function Th({ children }) { return (<th className="px-3 py-2 text-center align-middle text-xs font-semibold">{children}</th>); }
    function Td({ children, align = "left", ...rest }) {
      const alignClass = align === "right" ? "text-right" : align === "center" ? "text-center" : "text-left";
      return (<td {...rest} className={`px-3 py-2 align-middle ${alignClass}`}>{children}</td>);
    }
    function Pill({ label, value, tone = "neutral" }) {
      const tones = {
        ok: "bg-emerald-50 text-emerald-700 border-emerald-200",
        warn: "bg-amber-50 text-amber-700 border-amber-200",
        danger: "bg-rose-50 text-rose-700 border-rose-200",
        neutral: "bg-neutral-50 text-neutral-700 border-neutral-200",
      };
      return (
        <div className={`rounded-2xl border px-4 py-3 flex items-center justify-between gap-4 ${tones[tone]}`}>
          <span className="text-sm font-medium text-neutral-600">{label}</span>
          <span className="text-base font-semibold">{value}</span>
        </div>
      );
    }
    function Line({ label, value, muted = false, tone }) {
      const color = tone === "ok" ? "text-emerald-700" : tone === "warn" ? "text-amber-700" : tone === "danger" ? "text-rose-700" : "";
      return (
        <div className="flex items-center justify-between gap-4">
          <span className={`text-sm ${muted ? "text-neutral-400" : "text-neutral-700"}`}>{label}</span>
          <span className={`text-sm font-medium ${color}`}>{value}</span>
        </div>
      );
    }

    function LTVGauge({ value, zones = [], markers = [] }) {
      const clamp = (v) => Math.max(0, Math.min(1, Number.isFinite(v) ? v : 0));
      const size = 300;
      const center = size / 2;
      const radius = center - 18;
      const ring = 34;
      const startAngle = (Math.PI * 5) / 4; // 225°
      const sweepAngle = (Math.PI * 3) / 2; // 270°
      const angleFor = (pct) => startAngle - clamp(pct) * sweepAngle;
      const polarPoint = (pct, r = radius) => {
        const angle = angleFor(pct);
        return {
          angle,
          x: center + r * Math.cos(angle),
          y: center + r * Math.sin(angle),
        };
      };
      const describeArc = (from, to, r = radius) => {
        const start = polarPoint(from, r);
        const end = polarPoint(to, r);
        const delta = (to - from) * sweepAngle;
        const largeArc = Math.abs(delta) > Math.PI ? 1 : 0;
        const sweepFlag = delta <= 0 ? 1 : 0;
        return `M ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${end.x} ${end.y}`;
      };
      const palette = ['#064e3b', '#22c55e', '#facc15', '#fb923c', '#ef4444'];
      const normalizedZones = (zones.length ? zones : [
        { label: 'Muy saludable', max: 0.2, color: palette[0], legend: '0-20%', tone: 'ok' },
        { label: 'Saludable', max: 0.5, color: palette[1], legend: '20-50%', tone: 'ok' },
        { label: 'Vigilancia', max: 0.7, color: palette[2], legend: '50-70%', tone: 'warn' },
        { label: 'Tensión', max: 0.83, color: palette[3], legend: '70-83%', tone: 'warn' },
        { label: 'Crítico', max: 1, color: palette[4], legend: '>83%', tone: 'danger' },
      ]).map((zone, idx, arr) => ({
        label: zone.label ?? `Zona ${idx + 1}`,
        color: zone.color ?? palette[Math.min(idx, palette.length - 1)],
        legend: zone.legend ?? `≤${Math.round(clamp(zone.max) * 100)}%`,
        rawTo: clamp(zone.max),
        tone: zone.tone ?? (idx === 0 ? 'ok' : idx === arr.length - 1 ? 'danger' : 'warn'),
      }))
        .filter((zone, idx, arr) => zone.rawTo > 0 && idx === arr.findIndex((z) => z.rawTo === zone.rawTo))
        .sort((a, b) => a.rawTo - b.rawTo);
      const gap = 0.005;
      const segments = normalizedZones.reduce((acc, zone) => {
        const prev = acc[acc.length - 1];
        const from = prev ? prev.rawTo : 0;
        const capped = Math.min(Math.max(zone.rawTo, from), 1);
        if (capped <= from) return acc;
        const to = Math.max(Math.min(1, capped), from + 0.002);
        acc.push({ from, to, rawTo: capped, color: zone.color, label: zone.label, legend: zone.legend, tone: zone.tone });
        return acc;
      }, []);
      const valuePct = clamp(value);
      const pointerAngle = angleFor(valuePct);
      const pointerTip = polarPoint(valuePct, radius - ring * 0.25);
      const pointerBaseRadius = 22;
      const baseLeft = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle + Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle + Math.PI / 2),
      };
      const baseRight = {
        x: center + pointerBaseRadius * Math.cos(pointerAngle - Math.PI / 2),
        y: center + pointerBaseRadius * Math.sin(pointerAngle - Math.PI / 2),
      };
      const pointerPath = `M ${baseLeft.x} ${baseLeft.y} L ${pointerTip.x} ${pointerTip.y} L ${baseRight.x} ${baseRight.y} Z`;
      const statusZone = segments.find((seg) => valuePct <= seg.rawTo + 1e-6) ?? segments[segments.length - 1];
      const status = statusZone?.label ?? '—';
      const toneKey = statusZone?.tone ?? 'warn';
      const toneStyles = {
        ok: { text: 'text-emerald-500', bg: 'bg-emerald-100/70', dot: '#22c55e' },
        warn: { text: 'text-amber-500', bg: 'bg-amber-100/70', dot: '#facc15' },
        danger: { text: 'text-rose-500', bg: 'bg-rose-100/70', dot: '#ef4444' },
      };
      const statusTone = toneStyles[toneKey] ?? toneStyles.warn;
      const valueLabelY = center + radius * 0.44;
      const statusLabelY = valueLabelY + 24;
      return (
        <div className="flex flex-col items-center">
          <svg viewBox={`0 0 ${size} ${size}`} className="w-full max-w-[340px]">
            <defs>
              <radialGradient id="gaugeDepth" cx="50%" cy="50%" r="60%">
                <stop offset="0%" stopColor="#ffffff" stopOpacity="0.98" />
                <stop offset="100%" stopColor="#e2e8f0" stopOpacity="0.55" />
              </radialGradient>
              <linearGradient id="gaugeRing" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.12)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <radialGradient id="gaugeBackdrop" cx="50%" cy="48%" r="72%">
                <stop offset="0%" stopColor="rgba(191,219,254,0.42)" />
                <stop offset="55%" stopColor="rgba(148,163,184,0.28)" />
                <stop offset="100%" stopColor="rgba(226,232,240,0.9)" />
              </radialGradient>
              <radialGradient id="gaugeCore" cx="50%" cy="50%" r="65%">
                <stop offset="0%" stopColor="rgba(30,64,175,0.35)" />
                <stop offset="45%" stopColor="rgba(59,130,246,0.28)" />
                <stop offset="100%" stopColor="rgba(14,165,233,0.18)" />
              </radialGradient>
              <filter id="pointerShadow" x="-40%" y="-40%" width="180%" height="180%">
                <feDropShadow dx="0" dy="3" stdDeviation="3" floodColor="rgba(15,23,42,0.35)" />
              </filter>
              <filter id="ringShadow" x="-30%" y="-30%" width="160%" height="160%">
                <feDropShadow dx="0" dy="8" stdDeviation="12" floodColor="rgba(15,23,42,0.18)" floodOpacity="0.5" />
              </filter>
            </defs>
            <g filter="url(#ringShadow)">
              <circle cx={center} cy={center} r={radius + 10} fill="url(#gaugeBackdrop)" />
              <circle cx={center} cy={center} r={radius + 6} fill="url(#gaugeRing)" opacity="0.65" />
              <circle cx={center} cy={center} r={radius - ring * 0.15} fill="url(#gaugeDepth)" />
            </g>
            {segments.map((seg, idx) => {
              const isFirst = idx === 0;
              const isLast = idx === segments.length - 1;
              const from = seg.from + (isFirst ? 0 : gap);
              const to = Math.max(from + 0.001, seg.to - (isLast ? 0 : gap));
              return (
                <path
                  key={`${seg.label}-${idx}`}
                  d={describeArc(from, to, radius)}
                  stroke={seg.color}
                  strokeWidth={ring}
                  strokeLinecap="round"
                  fill="none"
                  opacity="0.95"
                />
              );
            })}
            <g filter="url(#pointerShadow)">
              <path d={pointerPath} fill="#0f172a" opacity="0.92" />
            </g>
            <circle cx={center} cy={center} r={18} fill="url(#gaugeCore)" stroke="rgba(191,219,254,0.65)" strokeWidth="5" />
            <circle cx={center} cy={center} r={6} fill="rgba(255,255,255,0.8)" stroke="rgba(148,163,184,0.35)" strokeWidth="1.5" />
            <text
              x={center}
              y={valueLabelY}
              textAnchor="middle"
              className="fill-slate-700"
              style={{ fontWeight: 700, fontSize: '24px' }}
            >
              {formatPercent(valuePct, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
            </text>
            <text
              x={center}
              y={statusLabelY}
              textAnchor="middle"
              className="fill-slate-400"
              style={{ fontWeight: 600, fontSize: '11px', letterSpacing: '0.16em' }}
            >
              Salud
            </text>
          </svg>
          <div className={`mt-4 flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold ${statusTone.bg} ${statusTone.text}`}>
            <span className="inline-flex h-2.5 w-2.5 rounded-full" style={{ backgroundColor: statusTone.dot }} />
            {status}
          </div>
          <div className="mt-5 grid grid-cols-2 gap-3 text-[11px] font-semibold text-neutral-600">
            {segments.map((seg, idx) => (
              <div key={`${seg.label}-${idx}-legend`} className="flex items-center gap-2">
                <span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: seg.color }} />
                <span>{seg.legend ?? seg.label}</span>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function TrendChart({ data, currency, rate }) {
      if (!data || data.length < 2) {
        return <div className="text-sm text-neutral-500">Configura un monto y una fecha de repago para visualizar la trayectoria.</div>;
      }
      const maxVal = data.reduce((max, point) => {
        const candidates = [point.cost, point.earn, point.balance];
        for (const raw of candidates) {
          const value = Number(raw);
          if (Number.isFinite(value) && value > max) {
            max = value;
          }
        }
        return max;
      }, 0);
      if (!(maxVal > 0)) {
        return <div className="text-sm text-neutral-500">Agrega colateral o préstamo para generar la proyección.</div>;
      }
      const width = 420;
      const height = 220;
      const paddingX = 36;
      const paddingY = 28;
      const step = data.length > 1 ? (width - paddingX * 2) / (data.length - 1) : 0;
      const baseY = height - paddingY;
      const scaleY = (value) => {
        if (!maxVal) return baseY;
        const ratio = value / maxVal;
        const usableHeight = height - paddingY * 1.6;
        return baseY - ratio * usableHeight;
      };
      const pathFor = (key) => data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point[key]);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPath = data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point.balance);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPathClosed = `${areaPath} L ${paddingX + step * (data.length - 1)} ${baseY} L ${paddingX} ${baseY} Z`;
      const tickIndexes = Array.from(new Set([0, Math.floor(data.length / 2), data.length - 1])).filter(i => i >= 0 && i < data.length);
      const ticks = tickIndexes.map((i) => ({ x: paddingX + i * step, label: `Día ${Math.round(data[i].day)}` }));
      const colors = { balance: '#8b5cf6', cost: '#60a5fa', earn: '#34d399' };
      const lastPoint = data[data.length - 1];
      return (
        <div>
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full">
            <defs>
              <linearGradient id="chartBg" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.08)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <linearGradient id="balanceArea" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#a855f7" stopOpacity="0.35" />
                <stop offset="100%" stopColor="#a855f7" stopOpacity="0.05" />
              </linearGradient>
            </defs>
            <rect x="0" y="0" width={width} height={height} fill="url(#chartBg)" opacity="1" rx="18" />
            <path d={`M ${paddingX} ${baseY} L ${paddingX + step * (data.length - 1)} ${baseY}`} stroke="rgba(148,163,184,0.35)" strokeWidth="1.5" strokeLinecap="round" />
            <path d={areaPathClosed} fill="url(#balanceArea)" opacity="0.6" />
            <path d={pathFor('balance')} stroke={colors.balance} strokeWidth="3" fill="none" strokeLinecap="round" />
            <path d={pathFor('cost')} stroke={colors.cost} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="4 4" />
            <path d={pathFor('earn')} stroke={colors.earn} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="6 4" />
            {ticks.map((tick) => (
              <g key={tick.label} transform={`translate(${tick.x}, ${baseY + 14})`}>
                <circle cx="0" cy="0" r="2" fill="rgba(148,163,184,0.5)" />
                <text textAnchor="middle" dy="12" className="fill-slate-400" style={{ fontSize: '10px', letterSpacing: '0.04em' }}>{tick.label}</text>
              </g>
            ))}
            {data.map((point, index) => {
              const x = paddingX + index * step;
              return (
                <circle key={`dot-${index}`} cx={x} cy={scaleY(point.balance)} r="3.5" fill="#8b5cf6" stroke="#fff" strokeWidth="1.5" />
              );
            })}
          </svg>
          <div className="mt-3 flex flex-wrap gap-4 text-xs font-semibold text-neutral-500">
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.balance }} />Balance neto</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.cost }} />Costo (interés)</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.earn }} />Earn estimado</span>
          </div>
          <div className="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3 text-sm">
            <div className="rounded-xl bg-blue-50/70 px-3 py-2">
              <div className="text-xs uppercase text-blue-600">Interés total</div>
              <div className="text-sm font-semibold text-blue-700">{fmt(lastPoint.cost * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-emerald-50/70 px-3 py-2">
              <div className="text-xs uppercase text-emerald-600">Earn acumulado</div>
              <div className="text-sm font-semibold text-emerald-700">{fmt(lastPoint.earn * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-violet-50/70 px-3 py-2">
              <div className="text-xs uppercase text-violet-600">Balance estimado</div>
              <div className="text-sm font-semibold text-violet-700">{fmt(lastPoint.balance * rate, currency)}</div>
            </div>
          </div>
        </div>
      );
    }

    function BinanceBaselineStatus({ meta, nowTs }) {
      const status = meta?.dynamicStatus || readDynamicModelStatus();
      const hasCache = !!status?.hasCache;
      const cacheTs = status?.cacheTs ?? status?.snapshot?.serverTime ?? null;
      const ageMsRaw = Number.isFinite(status?.ageMs) ? status.ageMs : null;
      const ageMs = ageMsRaw != null ? ageMsRaw : (cacheTs != null && Number.isFinite(nowTs) ? Math.max(0, nowTs - cacheTs) : null);
      const ageSeconds = Number.isFinite(ageMs) ? Math.floor(ageMs / 1000) : null;
      const origin = status?.source || 'dynamic_model';
      const snapshot = status?.snapshot || null;
      const fetchedAt = snapshot?.fetchedAt || cacheTs || null;
      const fetchedAgo = formatRelativeTime(fetchedAt, { now: nowTs, fallback: null });
      const detailItems = [
        { label: 'Cache', value: hasCache ? 'Disponible' : 'Sin datos', tone: hasCache ? 'ok' : 'warn' },
        {
          label: 'Edad del snapshot',
          value: ageSeconds != null ? `${ageSeconds}s` : '—',
          tone: ageSeconds != null && ageSeconds > 300 ? 'warn' : 'neutral',
        },
        { label: 'Origen', value: origin, tone: 'neutral' },
      ];
      const cacheLabel = fetchedAgo ? `Último cálculo hace ${fetchedAgo}.` : null;
      const metadataSource = snapshot?.metadata?.model || origin;
      return (
        <div className="rounded-2xl border border-emerald-200 bg-emerald-50 px-4 py-3">
          <div className="text-sm font-semibold text-emerald-700">Modelo dinámico activo (sin backend)</div>
          <div className="mt-1 text-xs font-medium text-emerald-700/80">Fórmulas + datos públicos (spot/funding)</div>
          <div className="mt-3 space-y-2">
            {detailItems.map((item) => (
              <Line key={item.label} label={item.label} value={item.value} tone={item.tone} />
            ))}
            <Line label="Modelo" value={metadataSource} muted />
          </div>
          {cacheLabel && (
            <div className="mt-2 text-[11px] font-medium text-emerald-700/80">{cacheLabel}</div>
          )}
          <div className="mt-3 rounded-xl border border-emerald-200/70 bg-white/80 p-3 text-[11px] text-emerald-800/80">
            LTV y precio de liquidación se autoajustan con volatilidad y pueden calibrarse por activo.
          </div>
        </div>
      );
    }

    function BinanceLivePanel({
      apiKey,
      apiSecret,
      onChangeKey,
      onChangeSecret,
      onRefresh,
      meta,
      aggregate,
      dataStale,
      secondsAgo,
      formatUsd,
    }) {
      const borrowApr = Number.isFinite(aggregate?.averageBorrowApr) ? aggregate.averageBorrowApr : null;
      const netApr = Number.isFinite(aggregate?.averageNetApr) ? aggregate.averageNetApr : null;
      const ltv = Number.isFinite(aggregate?.ltv) ? aggregate.ltv : null;
      const borrowUsd = Number.isFinite(aggregate?.borrowUsd) ? aggregate.borrowUsd : null;
      const collateralUsd = Number.isFinite(aggregate?.collateralUsd) ? aggregate.collateralUsd : null;
      const loading = !!meta?.loading;
      const error = meta?.error ? String(meta.error) : null;
      const status = meta?.status || 'idle';
      const statusLabel = (() => {
        if (status === 'missing') return 'Configura tu API Key y Secret (solo lectura).';
        if (status === 'incomplete') return 'Completa ambas credenciales para sincronizar.';
        if (status === 'syncing' || status === 'syncing-manual') return 'Sincronizando con Binance…';
        if (status === 'ok') {
          if (secondsAgo != null) {
            return secondsAgo === 0 ? 'Actualizado hace <1s' : `Actualizado hace ${secondsAgo}s`;
          }
          return 'Sincronizado con Binance';
        }
        if (status === 'error' && error) return error;
        return 'Sincronización manual disponible.';
      })();
      const statusTone = status === 'error'
        ? 'text-rose-600'
        : dataStale && status !== 'missing' && status !== 'incomplete'
          ? 'text-amber-600'
          : 'text-neutral-800';
      return (
        <Card title="Binance Loans – API en vivo">
          <div className="space-y-4 text-sm">
            <div className="grid gap-3 sm:grid-cols-2">
              <label className="flex flex-col gap-1">
                <span className="text-xs font-semibold uppercase text-neutral-500">API Key (READ)</span>
                <input
                  type="password"
                  autoComplete="off"
                  className="rounded-xl border border-neutral-300 px-3 py-2 text-sm"
                  value={apiKey}
                  onChange={(e) => onChangeKey(e.target.value.trim())}
                  placeholder="Ingresa tu API Key"
                />
              </label>
              <label className="flex flex-col gap-1">
                <span className="text-xs font-semibold uppercase text-neutral-500">API Secret</span>
                <input
                  type="password"
                  autoComplete="off"
                  className="rounded-xl border border-neutral-300 px-3 py-2 text-sm"
                  value={apiSecret}
                  onChange={(e) => onChangeSecret(e.target.value.trim())}
                  placeholder="Ingresa tu API Secret"
                />
              </label>
            </div>
            <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
              <div>
                <div className="text-xs font-semibold uppercase text-neutral-500">Estado</div>
                <div className={`text-sm font-semibold ${statusTone}`}>{statusLabel}</div>
                {error && status !== 'error' && (
                  <div className="text-xs text-rose-600 mt-1">{error}</div>
                )}
                {dataStale && !loading && status === 'ok' && (
                  <div className="text-xs text-amber-600 mt-1">Datos con más de 90s · revisa la conexión.</div>
                )}
              </div>
              <button
                type="button"
                onClick={onRefresh}
                disabled={loading}
                className="nx-btn nx-btn-sm self-start disabled:cursor-not-allowed disabled:opacity-60"
              >
                {loading ? 'Sincronizando…' : 'Sincronizar ahora'}
              </button>
            </div>
            <div className="grid gap-3 text-xs sm:grid-cols-2">
              <div className="nx-card-secondary p-3">
                <div className="text-[10px] font-semibold uppercase text-neutral-500">APR préstamo</div>
                <div className="text-sm font-semibold text-neutral-800">{borrowApr != null ? formatPercent(borrowApr, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}</div>
              </div>
              <div className="nx-card-secondary p-3">
                <div className="text-[10px] font-semibold uppercase text-neutral-500">APR neto</div>
                <div className={`text-sm font-semibold ${netApr != null && netApr < 0 ? 'text-emerald-600' : 'text-neutral-800'}`}>
                  {netApr != null ? formatPercent(netApr, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}
                </div>
              </div>
              <div className="nx-card-secondary p-3">
                <div className="text-[10px] font-semibold uppercase text-neutral-500">Deuda total (USDT)</div>
                <div className="text-sm font-semibold text-neutral-800">{borrowUsd != null ? formatUsd(borrowUsd, true) : '—'}</div>
              </div>
              <div className="nx-card-secondary p-3">
                <div className="text-[10px] font-semibold uppercase text-neutral-500">Colateral indexado</div>
                <div className="text-sm font-semibold text-neutral-800">{collateralUsd != null ? formatUsd(collateralUsd, true) : '—'}</div>
              </div>
              <div className="nx-card-secondary p-3 sm:col-span-2">
                <div className="text-[10px] font-semibold uppercase text-neutral-500">LTV (índice)</div>
                <div className={`text-sm font-semibold ${ltv != null && ltv > 0.85 ? 'text-rose-600' : 'text-neutral-800'}`}>
                  {ltv != null ? formatPercent(ltv, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}
                </div>
              </div>
            </div>
            <div className="nx-card-secondary px-3 py-2 text-[11px] text-neutral-500">
              Las credenciales requieren permisos READ para Loans y Simple Earn. Binance recomienda restringir la API por IP.
            </div>
          </div>
        </Card>
      );
    }

    function BinanceAssetCard({ item, currency, formatUsd, formatLoan, chosenAPR }) {
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      const toneBar = { ok: '#10b981', warn: '#f97316', danger: '#ef4444' };
      const tickerUpper = (item.ticker || '').toUpperCase();
      const highlightEtbDetails = tickerUpper === 'ADA' || tickerUpper === 'ALGO';
      const usagePct = item.policyLTV > 0 ? Math.min(100, (item.actualLtv / item.policyLTV) * 100) : Math.min(100, item.actualLtv * 100);
      const annualAprValue = Number.isFinite(item.annualApr) ? item.annualApr : (Number.isFinite(chosenAPR) ? chosenAPR : null);
      const vipApr = Number.isFinite(item.vipAnnual) ? item.vipAnnual : (Number.isFinite(item.vipAnnualRate) ? item.vipAnnualRate : null);
      const netAprValue = Number.isFinite(item.netApr) ? item.netApr : null;
      const netTone = netAprValue != null && netAprValue < 0
        ? 'text-emerald-600'
        : netAprValue != null && annualAprValue != null && netAprValue <= annualAprValue
          ? 'text-neutral-900'
          : netAprValue != null
            ? 'text-amber-600'
            : 'text-neutral-400';
      const ledger = item.ledger || {};
      const interestAccrued = Number.isFinite(item.interestAccrued) ? Math.max(0, item.interestAccrued) : 0;
      const interestLabel = interestAccrued > 0 ? formatLoan(interestAccrued) : '—';
      const liquidationPrice = Number.isFinite(item.liquidationPrice) && item.liquidationPrice > 0 ? item.liquidationPrice : null;
      const liquidationDigits = liquidationPrice != null && liquidationPrice < 0.1 ? { minimumFractionDigits: 6, maximumFractionDigits: 8 } : { minimumFractionDigits: 4, maximumFractionDigits: 6 };
      const liquidationPriceLabel = liquidationPrice != null ? `$${formatDecimal(liquidationPrice, liquidationDigits)}` : '—';
      const liquidationLtv = Number.isFinite(item.liquidationThreshold) ? item.liquidationThreshold : null;
      const marginCallLtv = Number.isFinite(item.marginCallThreshold) ? item.marginCallThreshold : null;
      const autoLiquidationLtv = Number.isFinite(item.autoLiquidationThreshold) ? item.autoLiquidationThreshold : null;
      const liquidationLtvLabel = liquidationLtv != null ? formatPercent(liquidationLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : '—';
      const marginCallLtvLabel = marginCallLtv != null ? formatPercent(marginCallLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : null;
      const autoLiquidationLabel = autoLiquidationLtv != null ? formatPercent(autoLiquidationLtv, { minimumFractionDigits: 0, maximumFractionDigits: 0 }) : null;
      const marginCallPrice = Number.isFinite(item.marginCallPrice) && item.marginCallPrice > 0 ? item.marginCallPrice : null;
      const marginCallDigits = marginCallPrice != null && marginCallPrice < 0.1 ? { minimumFractionDigits: 6, maximumFractionDigits: 8 } : { minimumFractionDigits: 4, maximumFractionDigits: 6 };
      const marginCallPriceLabel = marginCallPrice != null ? `$${formatDecimal(marginCallPrice, marginCallDigits)}` : '—';
      const showMarginCall = marginCallLtvLabel != null && (liquidationLtv == null || Math.abs(marginCallLtv - liquidationLtv) > 0.0005 || marginCallPrice != null);
      const showAutoLiquidation = autoLiquidationLabel != null && (liquidationLtv == null || Math.abs(autoLiquidationLtv - liquidationLtv) > 0.0005);
      const ltvApi = Number.isFinite(item.ltvFromApi) ? item.ltvFromApi : null;
      const ltvDrift = ltvApi != null ? item.actualLtv - ltvApi : null;
      const showLtvDrift = ltvDrift != null && Math.abs(ltvDrift) >= 0.0005;
      const borrowDate = ledger.borrowDate;
      const lastUpdated = ledger.lastUpdated;
      const loanCoin = item.loanCoin || ledger.loanCoin || null;
      const etbValue = Number.isFinite(item.etb) ? item.etb : (Number.isFinite(ledger.etb) ? ledger.etb : null);
      const allocatedLoanLabel = formatLoan(item.allocatedLoan);
      const etbLabel = etbValue != null ? formatLoan(etbValue) : '—';
      return (
        <div className="nx-card-secondary p-4">
          <div className="flex items-start justify-between gap-3">
            <div>
              <div className="text-sm font-semibold text-neutral-900">{item.name}</div>
              <div className="text-xs text-neutral-500">{item.ticker || '—'}{loanCoin ? ` · préstamo ${loanCoin}` : ''}</div>
            </div>
            <span className={`rounded-full px-2 py-1 text-xs font-semibold ${toneBadge[item.tone] || toneBadge.ok}`}>
              {item.tone === 'ok' ? 'Sano' : item.tone === 'warn' ? 'Vigilar' : 'Riesgo'}
            </span>
          </div>
          <div className="mt-3 space-y-3 text-xs text-neutral-600">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">Colateral</div>
                <div className="text-sm font-semibold text-neutral-800">{formatUsd(item.value)}</div>
              </div>
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">{highlightEtbDetails ? 'ETB neto asignado' : 'Préstamo & flujos'}</div>
                <div className="text-sm font-semibold text-neutral-800">{highlightEtbDetails ? etbLabel : allocatedLoanLabel}</div>
                {highlightEtbDetails && (
                  <div className="text-[10px] text-neutral-500">Préstamo vigente {allocatedLoanLabel}</div>
                )}
                <div className="text-[10px] text-neutral-500">Interés devengado {interestLabel}</div>
              </div>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div>
                <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">LTV neto</div>
                <div className="text-sm font-semibold text-neutral-800">{formatPercent(item.actualLtv, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}</div>
                {ltvApi != null && (
                  <div className="text-[10px] text-neutral-500">LTV API {formatPercent(ltvApi, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}</div>
                )}
                {showLtvDrift && (
                  <div className={`text-[10px] ${ltvDrift > 0 ? 'text-amber-600' : 'text-emerald-600'}`}>
                    Δ vs API {ltvDrift > 0 ? '+' : ''}{formatPercent(Math.abs(ltvDrift), { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                  </div>
                )}
              </div>
              <div className="space-y-2">
                <div>
                  <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">Tasa anual (APR)</div>
                  <div className="text-sm font-semibold text-neutral-800">{annualAprValue != null ? formatPercent(annualAprValue, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}</div>
                  {vipApr != null && (
                    <div className="mt-1">
                      <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">APR VIP</div>
                      <div className="text-sm font-semibold text-neutral-800">{formatPercent(vipApr, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                    </div>
                  )}
                </div>
                <div>
                  <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">Parámetros de liquidación</div>
                  <div className="text-sm font-semibold text-neutral-800">{liquidationLtvLabel}</div>
                  <div className="text-[10px] text-neutral-500">Precio liquidación <span className="font-medium text-neutral-700">{liquidationPriceLabel}</span></div>
                  {showMarginCall && (
                    <div className="text-[10px] text-neutral-500">
                      Margin call <span className="font-medium text-neutral-700">{marginCallLtvLabel}</span>
                      {marginCallPrice != null && (
                        <> · precio <span className="font-medium text-neutral-700">{marginCallPriceLabel}</span></>
                      )}
                    </div>
                  )}
                  {showAutoLiquidation && (
                    <div className="text-[10px] text-neutral-500">Auto-liquidación <span className="font-medium text-neutral-700">{autoLiquidationLabel}</span></div>
                  )}
                </div>
              </div>
            </div>
          </div>
          <div className="mt-3">
            <div className="h-2 w-full overflow-hidden rounded-full bg-neutral-200">
              <div className="h-full transition-all" style={{ width: `${usagePct.toFixed(1)}%`, backgroundColor: toneBar[item.tone] || toneBar.ok }} />
            </div>
            <div className="mt-1 flex justify-between text-[10px] text-neutral-500">
              <span>Uso</span>
              <span>Tope</span>
            </div>
          </div>
          <div className="mt-3">
            <div className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">Tasa anual neta</div>
            <div className={`text-base font-semibold ${netTone}`}>{netAprValue != null ? formatPercent(netAprValue, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}</div>
            {(borrowDate || lastUpdated) && (
              <div className="mt-1 text-[10px] text-neutral-500">
                {borrowDate && <div>Inicio préstamo: {borrowDate}</div>}
                {lastUpdated && <div>Última actualización: {lastUpdated}</div>}
              </div>
            )}
          </div>
        </div>
      );
    }

    function LoanDistributionDonut({ segments, size = 160 }) {
      const fallbackColors = ['#ef6784', '#4b8fda', '#f5b64d', '#38c5b8'];
      const center = size / 2;
      const outerRadius = center - 8;
      const innerRadius = outerRadius * 0.6;

      const degToRad = (deg) => (deg * Math.PI) / 180;
      const polarToCartesian = (angleDeg, radius) => {
        const rad = degToRad(angleDeg);
        return {
          x: center + radius * Math.cos(rad),
          y: center + radius * Math.sin(rad),
        };
      };

      const createSegmentPath = (startAngle, endAngle) => {
        const sweep = endAngle - startAngle;
        if (!Number.isFinite(sweep) || sweep <= 0.0001) {
          return '';
        }

        const notch = Math.min(Math.max(sweep * 0.18, 4), 18);
        const clippedStart = startAngle + notch;
        const clippedEnd = endAngle - notch;

        const largeArc = sweep > 180 ? 1 : 0;

        if (clippedEnd <= clippedStart) {
          const outerStart = polarToCartesian(startAngle, outerRadius);
          const outerEnd = polarToCartesian(endAngle, outerRadius);
          const innerEnd = polarToCartesian(endAngle, innerRadius);
          const innerStart = polarToCartesian(startAngle, innerRadius);
          return [
            `M ${outerStart.x.toFixed(2)} ${outerStart.y.toFixed(2)}`,
            `A ${outerRadius.toFixed(2)} ${outerRadius.toFixed(2)} 0 ${largeArc} 1 ${outerEnd.x.toFixed(2)} ${outerEnd.y.toFixed(2)}`,
            `L ${innerEnd.x.toFixed(2)} ${innerEnd.y.toFixed(2)}`,
            `A ${innerRadius.toFixed(2)} ${innerRadius.toFixed(2)} 0 ${largeArc} 0 ${innerStart.x.toFixed(2)} ${innerStart.y.toFixed(2)}`,
            'Z',
          ].join(' ');
        }

        const startOuter = polarToCartesian(clippedStart, outerRadius);
        const endOuter = polarToCartesian(clippedEnd, outerRadius);
        const startTip = polarToCartesian(startAngle + notch * 0.35, outerRadius * 0.94);
        const endTip = polarToCartesian(endAngle - notch * 0.35, outerRadius * 0.94);
        const innerEnd = polarToCartesian(endAngle - notch * 0.45, innerRadius);
        const innerStart = polarToCartesian(startAngle + notch * 0.45, innerRadius);

        return [
          `M ${startTip.x.toFixed(2)} ${startTip.y.toFixed(2)}`,
          `L ${startOuter.x.toFixed(2)} ${startOuter.y.toFixed(2)}`,
          `A ${outerRadius.toFixed(2)} ${outerRadius.toFixed(2)} 0 ${largeArc} 1 ${endOuter.x.toFixed(2)} ${endOuter.y.toFixed(2)}`,
          `L ${endTip.x.toFixed(2)} ${endTip.y.toFixed(2)}`,
          `L ${innerEnd.x.toFixed(2)} ${innerEnd.y.toFixed(2)}`,
          `A ${innerRadius.toFixed(2)} ${innerRadius.toFixed(2)} 0 ${largeArc} 0 ${innerStart.x.toFixed(2)} ${innerStart.y.toFixed(2)}`,
          'Z',
        ].join(' ');
      };

      let currentAngle = -90;
      const shapes = segments.map((seg, idx) => {
        const sweep = (Number.isFinite(seg.share) ? seg.share : 0) * 360;
        const start = currentAngle;
        const end = currentAngle + sweep;
        currentAngle = end;
        const path = createSegmentPath(start, end);
        return {
          path,
          color: seg.color || fallbackColors[idx % fallbackColors.length],
          key: `${seg.ticker || seg.name || 'segment'}-${idx}`,
        };
      }).filter((shape) => shape.path);

      if (shapes.length === 0) {
        return (
          <div
            className="relative flex h-36 w-36 items-center justify-center rounded-full shadow-lg"
            style={{ background: ACCENT_SURFACES.halo }}
          >
            <div
              className="h-20 w-20 rounded-full shadow-inner"
              style={{ background: ACCENT_SURFACES.soft, border: '1px solid rgba(59,130,246,0.18)' }}
            />
          </div>
        );
      }

      return (
        <svg
          viewBox={`0 0 ${size} ${size}`}
          className="h-36 w-36"
          role="img"
          aria-label="Distribución visual del préstamo"
        >
          <defs>
            <filter id="donutShadow" x="-20%" y="-20%" width="140%" height="140%">
              <feDropShadow dx="0" dy="8" stdDeviation="8" floodColor="rgba(15,30,70,0.18)" />
            </filter>
            <radialGradient id="donutCenterGlow" cx="50%" cy="45%" r="65%">
              <stop offset="0%" stopColor="rgba(255,255,255,0.96)" />
              <stop offset="55%" stopColor="rgba(219,234,254,0.82)" />
              <stop offset="100%" stopColor="rgba(148,163,184,0.32)" />
            </radialGradient>
            <radialGradient id="donutCore" cx="50%" cy="50%" r="68%">
              <stop offset="0%" stopColor="rgba(30,64,175,0.22)" />
              <stop offset="45%" stopColor="rgba(37,99,235,0.18)" />
              <stop offset="100%" stopColor="rgba(14,165,233,0.12)" />
            </radialGradient>
          </defs>
          <g filter="url(#donutShadow)">
            {shapes.map((shape) => (
              <path
                key={shape.key}
                d={shape.path}
                fill={shape.color}
                stroke="rgba(255,255,255,0.9)"
                strokeWidth="1.5"
              />
            ))}
          </g>
          <circle
            cx={center}
            cy={center}
            r={innerRadius + 6}
            fill="url(#donutCore)"
            opacity="0.75"
          />
          <circle
            cx={center}
            cy={center}
            r={innerRadius - 4}
            fill="url(#donutCenterGlow)"
            stroke="rgba(59,130,246,0.18)"
            strokeWidth="2"
          />
          <circle
            cx={center}
            cy={center}
            r={innerRadius * 0.32}
            fill="rgba(255,255,255,0.65)"
            stroke="rgba(148,163,184,0.28)"
            strokeWidth="1"
          />
        </svg>
      );
    }

    function CollateralLoanShareCard({ breakdown, currency, formatUsd, formatLoan, loanAmount, overallLTV, healthyThreshold, warnThreshold, autoRepayThreshold }) {
      const items = (breakdown || []).map((item) => {
        const share = item.loanShare > 0 ? item.loanShare : item.share;
        return { ...item, share: Math.max(0, share) };
      }).filter((item) => item.share > 0);
      if (items.length === 0) {
        return (
          <div className="nx-card-secondary p-4 text-sm text-neutral-500">
            Activa al menos un colateral con préstamo asignado para ver la distribución.
          </div>
        );
      }

      const toneColors = { ok: '#34d399', warn: '#facc15', danger: '#fb7185' };
      const assetPalette = ['#2563eb', '#f97316', '#10b981', '#8b5cf6', '#ec4899', '#14b8a6', '#facc15', '#0ea5e9', '#ef4444', '#22d3ee'];
      const distribution = items.map((item) => {
        const ledger = item.ledger || {};
        const precomputedOutstanding = Number.isFinite(item.loanNetOutstanding)
          ? Math.max(0, item.loanNetOutstanding)
          : null;
        const ledgerOriginal = Number.isFinite(ledger.originalPrincipal) ? Math.max(0, ledger.originalPrincipal) : 0;
        const ledgerInterest = Number.isFinite(ledger.interestAccrued) ? Math.max(0, ledger.interestAccrued) : 0;
        const ledgerPaid = Number.isFinite(ledger.paidTotal) ? Math.max(0, ledger.paidTotal) : 0;
        const ledgerOutstanding = Math.max(0, ledgerOriginal + ledgerInterest - ledgerPaid);
        const recordedOutstanding = Number.isFinite(ledger.outstanding) ? Math.max(0, ledger.outstanding) : 0;
        const fallbackOutstanding = Number.isFinite(item.allocatedLoan) ? Math.max(0, item.allocatedLoan) : 0;
        const amount = precomputedOutstanding != null
          ? precomputedOutstanding
          : (ledgerOutstanding > 0
            ? ledgerOutstanding
            : (recordedOutstanding > 0 ? recordedOutstanding : fallbackOutstanding));
        return { ...item, amount };
      }).filter((item) => item.amount > 0);
      if (distribution.length === 0) {
        return (
          <div className="nx-card-secondary p-4 text-sm text-neutral-500">
            Activa al menos un colateral con préstamo asignado para ver la distribución.
          </div>
        );
      }

      const totalOutstanding = distribution.reduce((acc, item) => acc + item.amount, 0);
      const consideredLoan = totalOutstanding > 0 ? totalOutstanding : Math.max(0, loanAmount);
      const denominator = totalOutstanding > 0 ? totalOutstanding : (consideredLoan > 0 ? consideredLoan : 1);
      let accShare = 0;
      const segments = distribution.map((item, idx) => {
        const share = denominator > 0 ? item.amount / denominator : 0;
        const start = accShare;
        accShare += share;
        const end = Math.min(1, accShare);
        const color = assetPalette[idx % assetPalette.length];
        return { start, end, tone: item.tone, name: item.name, ticker: item.ticker, share, color, amount: item.amount };
      });
      const healthy = Number.isFinite(healthyThreshold) ? healthyThreshold : 0.2;
      const warn = Number.isFinite(warnThreshold) ? warnThreshold : Math.max(healthy + 0.2, healthy);
      const auto = Number.isFinite(autoRepayThreshold) ? autoRepayThreshold : 1;
      const overallTone = overallLTV <= healthy ? 'ok' : overallLTV <= warn ? 'warn' : 'danger';
      const overallLabel = overallTone === 'ok' ? 'Sano' : overallTone === 'warn' ? 'Vigilar' : 'Crítico';
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      const toneText = { ok: 'text-emerald-600', warn: 'text-amber-600', danger: 'text-rose-600' };
      const consideredLoanLabel = formatLoan(consideredLoan);
      const overallLtvLabel = formatPercent(overallLTV, { minimumFractionDigits: 1, maximumFractionDigits: 1 });

      return (
        <div className="nx-card-secondary p-4 flex flex-col gap-4">
          <div className="flex items-center justify-between">
            <div className="text-sm font-semibold text-neutral-900">Distribución del préstamo</div>
            <span className={`rounded-full px-2 py-1 text-[11px] font-semibold ${toneBadge[overallTone]}`}>{overallLabel}</span>
          </div>
          <div className="flex flex-col items-center gap-4">
            <LoanDistributionDonut segments={segments} />
            <div className="text-xs text-neutral-500 text-center">
              Préstamo considerado: <span className="font-semibold text-neutral-700">{formatLoan(consideredLoan)}</span>
            </div>
          </div>
          <div className="space-y-2 text-xs text-neutral-600">
            {segments.map((seg, idx) => (
              <div key={`${seg.ticker || seg.name || 'segment'}-${idx}`} className="flex items-center justify-between gap-3">
                <div className="flex items-center gap-2">
                  <span className="h-2.5 w-2.5 rounded-full" style={{ backgroundColor: seg.color || '#60a5fa' }} />
                  <span className="font-medium text-neutral-800">{seg.name}</span>
                </div>
                <div className="flex flex-col items-end">
                  <span className="font-semibold text-neutral-800">{formatPercent(seg.share, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}</span>
                  <span className="text-[10px] text-neutral-500">{formatLoan(seg.share * consideredLoan)}</span>
                </div>
              </div>
            ))}
          </div>
          <div className="flex flex-wrap gap-2 text-[10px] text-neutral-500">
            <span className="flex items-center gap-1"><span className="h-2 w-3 rounded-full" style={{ backgroundColor: toneColors.ok }} />Sano ≤ {formatPercent(healthy, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
            <span className="flex items-center gap-1"><span className="h-2 w-3 rounded-full" style={{ backgroundColor: toneColors.warn }} />Alerta ≤ {formatPercent(warn, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
            <span className="flex items-center gap-1"><span className="h-2 w-3 rounded-full" style={{ backgroundColor: toneColors.danger }} />Riesgo ≥ {formatPercent(auto, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
          </div>
        </div>
      );
    }

    // Tests mínimos (no tocar a menos que estén mal) + 2 nuevos
    function approxEq(a, b, eps = 1e-6) { return Math.abs(a - b) <= eps; }
    function runDevTests() {
      try {
        const nexo = PLATFORM_BASE_CONFIGS.nexo;
        const binance = PLATFORM_BASE_CONFIGS.binance;
        const youhodler = PLATFORM_BASE_CONFIGS.youhodler;
        const ledn = PLATFORM_BASE_CONFIGS.ledn;
        console.assert(approxEq((nexo.policies?.targetLtv ?? 0), 0.20), 'Test1: Target LTV Nexo 20%');
        console.assert(approxEq((nexo.ltvByTicker?.BTC ?? 0), 0.50), 'Test2: LTV BTC Nexo 50%');
        console.assert((binance.earnAprTop?.BNB ?? 0) >= 0.05, 'Test3: Earn BNB Binance ≥5%');
        console.assert(BASE_GLOBAL_COINGECKO_IDS.BTC === 'bitcoin', 'Test4: CoinGecko BTC');
        console.assert(PLATFORM_IDS.includes('nexo') && PLATFORM_IDS.includes('binance'), 'Test5: plataformas registradas');
        const lowCostNexo = nexo.apr?.lowCostEligibleTiers || [];
        console.assert(lowCostNexo.includes('Gold') && lowCostNexo.includes('Platinum'), 'Test6: Low-Cost tiers Nexo');
        const defaultTicker = (nexo.defaultAssets?.[0]?.ticker || '').toUpperCase();
        console.assert(defaultTicker === 'BTC', 'Test7: default asset BTC');
        console.assert((youhodler?.policies?.targetLtv ?? 0) >= 0.7, 'Test8: Target LTV YouHodler ≥70%');
        console.assert((ledn?.ltvByTicker?.BTC ?? 0) <= 0.7, 'Test9: LTV BTC Ledn ≤70%');
        console.assert(PLATFORM_IDS.includes('youhodler') && PLATFORM_IDS.includes('ledn'), 'Test10: nuevas plataformas registradas');
        console.log('%cSanity tests OK', 'color:green');
      } catch (e) { console.error('Sanity tests failed', e); }
    }
    if (typeof window !== 'undefined') { try { runDevTests(); } catch (_) {} }

    const container = document.getElementById('root');
    if (!container) {
      throw new Error('No se encontró el contenedor #root para montar la app.');
    }
    const root = ReactDOM.createRoot(container);
    root.render(
      <ErrorBoundary>
        <SimuladorPrestamos />
      </ErrorBoundary>
    );
  </script>
</body>
</html>
