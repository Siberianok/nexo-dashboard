<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nexo Loan Dashboard — HTML (portable)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    body{font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
    /* Paleta y estilos inspirados en Nexo */
    .nx-gradient{background:linear-gradient(135deg,#0b1e4b 0%,#1b44a6 50%,#2052c1 100%)}
    .nx-gradient-soft{background:linear-gradient(180deg,#eef3ff 0%, #f6f9ff 100%)}
    .nx-card{border:1px solid #dfe6ff; box-shadow:0 12px 30px rgba(16,35,90,.08); border-radius:1.5rem}
    .nx-kpi{border:1px solid #e6eaf5}
    .nx-kpi-btn{
      position:relative;
      border-radius:1.25rem;
      background:linear-gradient(155deg,#1c3fa0 0%,#2f5de0 45%,#4c8fff 100%);
      color:#fff;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),0 16px 30px rgba(8,20,66,0.35);
      transition:transform .25s ease, box-shadow .25s ease, filter .25s ease;
    }
    .nx-kpi-btn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 -18px 30px rgba(0,0,0,0.18);
      pointer-events:none;
    }
    .nx-kpi-btn:hover{
      transform:translateY(-3px);
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),0 22px 36px rgba(12,28,84,0.42);
    }
    .nx-kpi-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),0 10px 18px rgba(10,24,70,0.3);
    }
    .nx-btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:.4rem;
      background:linear-gradient(155deg,#2451d5 0%,#3368f0 45%,#4a8cff 100%);
      color:#fff;
      border-radius:1rem;
      padding:.55rem 1.35rem;
      font-weight:600;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),0 14px 28px rgba(15,33,90,0.32);
      transition:transform .22s ease, box-shadow .22s ease, filter .22s ease;
    }
    .nx-btn:hover{
      transform:translateY(-2px);
      filter:brightness(1.03);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),0 20px 34px rgba(12,30,88,0.4);
    }
    .nx-btn:active{
      transform:translateY(1px);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.35),0 10px 20px rgba(10,26,70,0.25);
    }
    .nx-btn-ghost{
      background:linear-gradient(150deg,#ffffff 0%,#f1f5ff 100%);
      color:#1e2f67;
      border:1px solid rgba(30,64,175,0.16);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),0 10px 22px rgba(15,30,70,0.12);
    }
    .nx-btn-ghost:hover{
      filter:brightness(1.02);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8),0 16px 26px rgba(15,30,70,0.18);
    }
    .nx-btn-sm{padding:.35rem .95rem; font-size:.8rem; border-radius:.9rem;}
  </style>
</head>
<body class="nx-gradient-soft">
  <div id="root"></div>

  <!-- React 18 UMD + ReactDOM + Babel (para compilar JSX en el navegador) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    // NEXO LOAN DASHBOARD – HTML portable (sin build, con CDN)
    const { useState, useEffect, useMemo, useRef } = React;

    const fmt = (n, currency = "USD", show = true) =>
      show ? n.toLocaleString(undefined, { style: "currency", currency }) : n.toLocaleString();

    const todayISO = () => new Date().toISOString().slice(0, 10);

    const COINGECKO_IDS = {
      BTC: "bitcoin",
      ETH: "ethereum",
      NEXO: "nexo",
      USDT: "tether",
      USDC: "usd-coin",
      ADA: "cardano",
      ALGO: "algorand",
      XRP: "ripple",
      BNB: "binancecoin",
    };
    const tickerToId = (t) => COINGECKO_IDS[t?.toUpperCase()];

    // LTV por activo (no editable). Fuente pública Nexo, 10-oct-2025.
    const LTV_BY_TICKER = {
      BTC: 0.50,
      ETH: 0.50,
      NEXO: 0.15,
      XRP: 0.30,
      BNB: 0.30,
      USDC: 0.50,
      USDT: 0.50,
      ADA: 0.50,
      ALGO: 0.30,
    };

    // Tasas "hasta" para Flexible Savings (no editables). Público en nexo.com (pueden variar por tier/país).
    const EARN_APR_TOP = {
      BTC: 0.06,
      ETH: 0.07,
      USDC: 0.12,
      USDT: 0.12,
      NEXO: 0.04,
      XRP: 0.07,
      BNB: 0.07,
      SOL: 0.07,
      ADA: 0.02,
      ALGO: 0.02,
    };

    // *** POLÍTICAS FIJAS DE NEXO (no editables) ***
    const TARGET_LTV = 0.20;                 // Low-Cost bajo 20% LTV
    const MIN_BALANCE_PERKS = 5000;          // Balance mínimo perks/earn
    const APR = {                            // APR por categoría y promo ≤20%
      base: 0.189,
      silver: 0.179,
      gold: 0.139,
      platinum: 0.109,
      goldDisc: 0.059,   // low-cost ≤20%
      platDisc: 0.029,   // low-cost ≤20%
      earlyRuleDays: 45,
      earlyAPR: 0.189,
    };

    const defaultAssets = [
      { id: 1, name: "Bitcoin", ticker: "BTC", qty: 0, price: 0, priceAuto: true, useAsCollateral: true, ltv: LTV_BY_TICKER.BTC },
      { id: 2, name: "Ethereum", ticker: "ETH", qty: 0, price: 0, priceAuto: true, useAsCollateral: true, ltv: LTV_BY_TICKER.ETH },
      { id: 3, name: "NEXO Token", ticker: "NEXO", qty: 0, price: 0, priceAuto: true, useAsCollateral: true, ltv: LTV_BY_TICKER.NEXO },
      { id: 4, name: "Tether", ticker: "USDT", qty: 0, price: 1, priceAuto: true, useAsCollateral: true, ltv: LTV_BY_TICKER.USDT },
      { id: 5, name: "USD Coin", ticker: "USDC", qty: 0, price: 1, priceAuto: true, useAsCollateral: true, ltv: LTV_BY_TICKER.USDC },
      { id: 6, name: "Cardano", ticker: "ADA", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: LTV_BY_TICKER.ADA },
      { id: 7, name: "Algorand", ticker: "ALGO", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: LTV_BY_TICKER.ALGO },
    ];

    // Parámetros SOLO de entorno (sí editables)
    const defaultParams = {
      usdToArs: 1000,
      loyaltyModel: "vsRest",
      liveQuotes: true,
      refreshSec: 60,
      earnOptIn: true,
      earnOnCollateral: true,
    };

    function NexoDashboard() {
      const [assets, setAssets] = useState(() => {
        try {
          const saved = typeof window !== 'undefined' ? localStorage.getItem("nexo_assets_v1") : null;
          const base = saved ? JSON.parse(saved) : defaultAssets;
          return base.map((a) => ({
            ...a,
            ticker: (a.ticker || "").toUpperCase(),
            priceAuto: a.priceAuto === false ? false : true,
            ltv: LTV_BY_TICKER[(a.ticker||"").toUpperCase()] ?? a.ltv ?? 0,
          }));
        } catch { return defaultAssets; }
      });

      const [params, setParams] = useState(() => {
        try {
          const saved = typeof window !== 'undefined' ? localStorage.getItem("nexo_params_v1") : null;
          const fallback = defaultParams;
          return saved ? { ...fallback, ...JSON.parse(saved) } : fallback;
        } catch { return defaultParams; }
      });

      const [loanAmount, setLoanAmount] = useState(0);
      const [repayDate, setRepayDate] = useState(() => {
        const d = new Date(); d.setDate(d.getDate() + 60); return d.toISOString().slice(0, 10);
      });
      const [showArs, setShowArs] = useState(false);
      const [lastPriceTs, setLastPriceTs] = useState(null);
      const [liveError, setLiveError] = useState(null);

      useEffect(() => { try { localStorage.setItem("nexo_assets_v1", JSON.stringify(assets)); } catch {} }, [assets]);
      useEffect(() => { try { localStorage.setItem("nexo_params_v1", JSON.stringify(params)); } catch {} }, [params]);

      const currency = showArs ? "ARS" : "USD";
      const rate = showArs ? params.usdToArs : 1;
      const pct = (x) => (x == null ? "—" : (x * 100).toFixed(1) + "%");

      const tickersKey = useMemo(() => assets.filter(a=>a.priceAuto!==false).map(a=>a.ticker?.toUpperCase()).sort().join(','), [assets]);

      const inFlight = useRef(false);
      async function fetchLivePricesNow() {
        try {
          if (inFlight.current) return; inFlight.current = true;
          setLiveError(null);
          if (!params.liveQuotes) { inFlight.current = false; return; }
          const ids = Array.from(new Set(assets.filter(a => a.priceAuto !== false).map(a => tickerToId(a.ticker)).filter(Boolean)));
          if (!ids.length) { setLastPriceTs(Date.now()); inFlight.current = false; return; }
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
        finally { inFlight.current = false; }
      }

      async function fetchPricesForTickers(tickers = []) {
        try {
          if (!params.liveQuotes) return;
          const ids = Array.from(new Set(tickers.map(tickerToId).filter(Boolean)));
          if (!ids.length) return;
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          setAssets(prev => prev.map(a => {
            const id = tickerToId(a.ticker);
            if (!id || a.priceAuto === false) return a;
            const p = data?.[id]?.usd;
            return (p != null) ? { ...a, price: Number(p) } : a;
          }));
          setLastPriceTs(Date.now());
        } catch (e) { setLiveError(String(e?.message || e)); }
      }

      useEffect(() => {
        if (!params.liveQuotes) return;
        fetchLivePricesNow();
        const sec = Math.max(10, Number(params.refreshSec || 60));
        const t = setInterval(fetchLivePricesNow, sec * 1000);
        return () => clearInterval(t);
      }, [params.liveQuotes, params.refreshSec, tickersKey]);

      const totals = useMemo(() => {
        const withValue = assets.map(a => ({ ...a, value: (Number(a.qty) || 0) * (Number(a.price) || 0) }));
        const total = withValue.reduce((acc, a) => acc + a.value, 0);
        const totalNexo = withValue.filter(a => (a.ticker || "").toUpperCase() === "NEXO").reduce((acc, a) => acc + a.value, 0);
        const rest = total - totalNexo;
        const ratioVsRest = rest > 0 ? (totalNexo / rest) : (totalNexo > 0 ? Number.POSITIVE_INFINITY : 0);
        const ratioVsTotal = total > 0 ? (totalNexo / total) : 0;
        const collaterals = withValue.filter(a => a.useAsCollateral);
        const totalCollateralValue = collaterals.reduce((acc, a) => acc + a.value, 0);
        const maxBorrow = collaterals.reduce((acc, a) => acc + a.value * ((LTV_BY_TICKER[(a.ticker||"").toUpperCase()] ?? a.ltv) || 0), 0);
        return { withValue, total, totalNexo, rest, ratioVsRest, ratioVsTotal, totalCollateralValue, maxBorrow };
      }, [assets]);

      const loyaltyTier = useMemo(() => {
        if (totals.total < MIN_BALANCE_PERKS) return "Sin perks";
        const ratioUsed = params.loyaltyModel === "vsTotal" ? totals.ratioVsTotal : totals.ratioVsRest;
        if (ratioUsed >= 0.10) return "Platinum";
        if (ratioUsed >= 0.05) return "Gold";
        if (ratioUsed >= 0.01) return "Silver";
        return "Base";
      }, [totals.total, totals.ratioVsRest, totals.ratioVsTotal, params.loyaltyModel]);

      const recommendedLoanAtTarget = useMemo(() => TARGET_LTV * totals.totalCollateralValue, [totals.totalCollateralValue]);
      const capLowCost = useMemo(() => Math.min(recommendedLoanAtTarget, totals.maxBorrow), [recommendedLoanAtTarget, totals.maxBorrow]);
      const lowCostHeadroom = useMemo(() => Math.max(0, capLowCost - loanAmount), [capLowCost, loanAmount]);

      const marginCallLTV = 0.70; // soporte Nexo
      const autoRepayLTV = 0.8333333333; // 83.33%

      const dropTo70 = useMemo(() => {
        if (totals.totalCollateralValue <= 0) return null;
        const denom = marginCallLTV * totals.totalCollateralValue; if (denom <= 0) return null;
        const d = 1 - (loanAmount / denom); return Math.max(0, Math.min(1, d));
      }, [loanAmount, totals.totalCollateralValue]);

      const dropTo83 = useMemo(() => {
        if (totals.totalCollateralValue <= 0) return null;
        const denom = autoRepayLTV * totals.totalCollateralValue; if (denom <= 0) return null;
        const d = 1 - (loanAmount / denom); return Math.max(0, Math.min(1, d));
      }, [loanAmount, totals.totalCollateralValue]);

      const chosenAPR = useMemo(() => {
        const withinTarget = loanAmount <= recommendedLoanAtTarget && totals.total >= MIN_BALANCE_PERKS;
        if (totals.total < MIN_BALANCE_PERKS) return APR.base;
        if (withinTarget) {
          if (loyaltyTier === "Platinum") return APR.platDisc;
          if (loyaltyTier === "Gold") return APR.goldDisc;
          if (loyaltyTier === "Silver") return APR.silver;
          return APR.base;
        }
        if (loyaltyTier === "Platinum") return APR.platinum;
        if (loyaltyTier === "Gold") return APR.gold;
        if (loyaltyTier === "Silver") return APR.silver;
        return APR.base;
      }, [loanAmount, recommendedLoanAtTarget, totals.total, loyaltyTier]);

      const daysUntilRepay = useMemo(() => {
        const a = new Date(); const b = new Date(repayDate);
        const diffMs = Math.max(0, b.getTime() - a.getTime());
        return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      }, [repayDate]);

      const interestCalc = useMemo(() => {
        const P = loanAmount; const d = daysUntilRepay; const r = chosenAPR;
        const earlyDays = Math.max(0, APR.earlyRuleDays - d);
        const main = P * (Math.pow(1 + r / 365, d) - 1);
        const early = d < APR.earlyRuleDays ? P * (Math.pow(1 + APR.earlyAPR / 365, earlyDays) - 1) : 0;
        const total = main + early; return { main, early, total, repayTotal: P + total };
      }, [loanAmount, daysUntilRepay, chosenAPR]);

      const monthlyLoanCost = useMemo(() => loanAmount * (Math.pow(1 + chosenAPR / 365, 30) - 1), [loanAmount, chosenAPR]);

      const earnEligible = totals.total >= MIN_BALANCE_PERKS && params.earnOptIn;
      const earnMonthly = useMemo(() => {
        if (!earnEligible) return 0;
        const days = 30;
        return totals.withValue.reduce((acc, a) => {
          if (!params.earnOnCollateral && a.useAsCollateral) return acc;
          const apr = EARN_APR_TOP[(a.ticker||"").toUpperCase()] ?? 0;
          return acc + a.value * (Math.pow(1 + apr/365, days) - 1);
        }, 0);
      }, [earnEligible, params.earnOnCollateral, totals.withValue]);

      const netMonthly = useMemo(() => earnMonthly - monthlyLoanCost, [earnMonthly, monthlyLoanCost]);

      const timeline = useMemo(() => {
        const totalDays = Math.max(1, daysUntilRepay);
        const steps = Math.max(4, Math.min(12, Math.ceil(totalDays / 20)));
        const arr = [];
        for (let i = 0; i <= steps; i++) {
          const day = (totalDays / steps) * i;
          const interest = loanAmount * (Math.pow(1 + chosenAPR / 365, day) - 1);
          let earn = 0;
          if (earnEligible) {
            earn = totals.withValue.reduce((acc, asset) => {
              if (!params.earnOnCollateral && asset.useAsCollateral) return acc;
              const apr = EARN_APR_TOP[(asset.ticker || "").toUpperCase()] ?? 0;
              return acc + asset.value * (Math.pow(1 + apr / 365, day) - 1);
            }, 0);
          }
          const balance = Math.max(0, loanAmount + interest - earn);
          arr.push({ day, cost: interest, earn, balance });
        }
        return arr;
      }, [chosenAPR, daysUntilRepay, earnEligible, loanAmount, params.earnOnCollateral, totals.withValue]);

      const overallLTVIfBorrow = useMemo(() => (totals.totalCollateralValue > 0 ? loanAmount / totals.totalCollateralValue : 0), [loanAmount, totals.totalCollateralValue]);
      const ltvTone = overallLTVIfBorrow <= TARGET_LTV ? "ok" : (overallLTVIfBorrow <= marginCallLTV ? "warn" : "danger");

      const collateralBreakdown = useMemo(() => {
        const totalCollateral = totals.totalCollateralValue || 0;
        if (!(totalCollateral > 0)) return [];
        return totals.withValue
          .filter((asset) => asset.useAsCollateral && asset.value > 0)
          .map((asset) => {
            const ticker = (asset.ticker || "").toUpperCase();
            const policyLTV = LTV_BY_TICKER[ticker] ?? asset.ltv ?? 0;
            const maxBorrowForAsset = asset.value * policyLTV;
            const share = asset.value / totalCollateral;
            const allocatedLoan = loanAmount * share;
            const usageVsCap = maxBorrowForAsset > 0 ? allocatedLoan / maxBorrowForAsset : 0;
            let tone = "ok";
            if (usageVsCap > 0.85 || overallLTVIfBorrow >= autoRepayLTV) {
              tone = "danger";
            } else if (usageVsCap > 0.6 || overallLTVIfBorrow >= marginCallLTV) {
              tone = "warn";
            }
            return {
              id: asset.id,
              name: asset.name || ticker || `Activo ${asset.id}`,
              ticker,
              value: asset.value,
              share,
              policyLTV,
              policyPct: policyLTV * 100,
              maxBorrowForAsset,
              allocatedLoan,
              usageVsCap: Math.max(0, usageVsCap),
              tone,
            };
          })
          .sort((a, b) => b.value - a.value);
      }, [autoRepayLTV, loanAmount, marginCallLTV, overallLTVIfBorrow, totals.totalCollateralValue, totals.withValue]);

      const extraCollateralForTarget = useMemo(() => {
        const neededCollateral = loanAmount / TARGET_LTV;
        return Math.max(0, neededCollateral - totals.totalCollateralValue);
      }, [loanAmount, totals.totalCollateralValue]);

      const nexoReqs = useMemo(() => {
        const denom = params.loyaltyModel === "vsTotal" ? totals.total : totals.rest;
        const silverReq = 0.01 * denom; const goldReq = 0.05 * denom; const platReq = 0.10 * denom;
        const missingSilver = Math.max(0, silverReq - totals.totalNexo);
        const missingGold = Math.max(0, goldReq - totals.totalNexo);
        const missingPlat = Math.max(0, platReq - totals.totalNexo);
        return { silverReq, goldReq, platReq, missingSilver, missingGold, missingPlat, denom };
      }, [totals.total, totals.rest, totals.totalNexo, params.loyaltyModel]);

      const meetsLowCost = useMemo(() => {
        const withinTarget = loanAmount <= recommendedLoanAtTarget;
        const hasTier = ["Gold", "Platinum"].includes(loyaltyTier);
        return totals.total >= MIN_BALANCE_PERKS && withinTarget && hasTier;
      }, [loanAmount, recommendedLoanAtTarget, loyaltyTier, totals.total]);

      const handleAssetChange = (id, patch) => setAssets(prev => prev.map(a => (a.id === id ? { ...a, ...patch } : a)));

      const addRow = () => {
        const nextId = Math.max(0, ...assets.map(a => a.id)) + 1;
        setAssets(prev => ([...prev, { id: nextId, name: "Nuevo", ticker: "TKN", qty: 0, price: 0, priceAuto: true, useAsCollateral: false, ltv: LTV_BY_TICKER.TKN ?? 0.25 }]));
      };
      const removeRow = (id) => setAssets(prev => prev.filter(a => a.id !== id));

      return (
        <div className="min-h-screen w-full text-neutral-900">
          <div className="nx-gradient text-white">
            <div className="mx-auto max-w-7xl px-4 py-6">
              <header className="flex flex-wrap items-end justify-between gap-4">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">Tablero Nexo – Simulador de Préstamos</h1>
                  <p className="text-blue-100/90">Estilo Nexo, datos en vivo y cálculos de Earn (flexible) y crédito.</p>
                </div>
                <div className="flex items-center gap-3">
                  <label className="text-sm font-medium mr-1">Mostrar en ARS</label>
                  <input type="checkbox" checked={showArs} onChange={(e) => setShowArs(e.target.checked)} className="h-5 w-5" />
                </div>
              </header>
            </div>
          </div>

          <div className="mx-auto max-w-7xl px-4 py-6">
            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
              <KPI title="Balance total" value={fmt(totals.total * rate, currency)} variant="button" />
              <KPI title="Loyalty Tier" value={loyaltyTier} subtle={totals.total < MIN_BALANCE_PERKS ? "(balance < mínimo)" : undefined} variant="button" />
              <KPI title="APR crédito" value={`${(chosenAPR * 100).toFixed(2)}%`} subtle={meetsLowCost ? "Low-Cost activo" : undefined} variant="button" />
              <KPI title="Cap. Low-Cost (≤20% LTV)" value={fmt(capLowCost * rate, currency)} subtle="potencial" variant="button" />
              <KPI title="Tope por LTVs" value={fmt(totals.maxBorrow * rate, currency)} variant="button" />
              <KPI title="Préstamo recomendado (≤20%)" value={fmt(recommendedLoanAtTarget * rate, currency)} variant="button" />
              <KPI title="Interés hasta repago" value={fmt(interestCalc.total * rate, currency)} subtle={`${useMemo(()=>{const a=new Date(); const b=new Date(repayDate); return Math.ceil(Math.max(0,b-a)/86400000);},[repayDate])} días`} variant="button" />
              <KPI title="Total a devolver" value={fmt(interestCalc.repayTotal * rate, currency)} variant="button" />
              <KPI title="Earn mensual (hasta)" value={fmt(earnMonthly * rate, currency)} subtle={earnEligible?`Savings ≥ $${MIN_BALANCE_PERKS}`:"no elegible"} variant="button" />
              <KPI title="Neto mensual (Earn − crédito)" value={fmt(netMonthly * rate, currency)} tone={netMonthly>=0?"ok":"danger"} variant="button" />
            </section>

            <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
              <Card title="Préstamo & Repago">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <Field label={`Monto a pedir (${currency})`}>
                    <input type="number" className="w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-700 text-right" value={(loanAmount * rate).toString()} onChange={(e)=> setLoanAmount(Number(e.target.value) / rate)} min={0} />
                  </Field>
                  <Field label="Fecha de repago">
                    <input type="date" className="w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-700" value={repayDate} min={todayISO()} onChange={(e)=> setRepayDate(e.target.value)} />
                  </Field>
                </div>
                <div className="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                  <Pill label="LTV si pides esto" value={`${(overallLTVIfBorrow*100).toFixed(2)}%`} tone={ltvTone} />
                  <Pill label="≤20% LTV (fijo)" value={loanAmount <= recommendedLoanAtTarget ? "Sí" : "No"} tone={loanAmount <= recommendedLoanAtTarget ? "ok" : "warn"} />
                  <Pill label="¿Califica Low-Cost?" value={meetsLowCost ? "Sí" : "No"} tone={meetsLowCost ? "ok" : "warn"} />
                  <Pill label="Margen Low-Cost" value={fmt(lowCostHeadroom * rate, currency)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                </div>
              </Card>

              <Card title="Salud del préstamo">
                <LTVGauge value={overallLTVIfBorrow} target={TARGET_LTV} marginCall={marginCallLTV} autoRepay={autoRepayLTV} />
                <div className="mt-4 space-y-2">
                  <Line label="LTV actual" value={`${(overallLTVIfBorrow*100).toFixed(1)}%`} tone={ltvTone} />
                  <Line label="Objetivo Low-Cost" value={`${(TARGET_LTV*100).toFixed(0)}%`} muted />
                  <Line label="Margin call" value={`${(marginCallLTV*100).toFixed(0)}%`} muted />
                  <Line label="Auto-repay" value={`${(autoRepayLTV*100).toFixed(0)}%`} muted />
                  <Line label="Cap Low-Cost" value={fmt(capLowCost * rate, currency)} tone={lowCostHeadroom > 0 ? "ok" : "danger"} />
                </div>
              </Card>

              <Card title="Parámetros (solo entorno)">
                <div className="grid grid-cols-2 gap-3">
                  <NumberParam label="USD→ARS" value={params.usdToArs} onChange={(v)=> setParams({ ...params, usdToArs: v })} />

                  <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 flex flex-wrap items-center gap-3">
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.liveQuotes} onChange={(e)=> setParams({ ...params, liveQuotes: e.target.checked })} />
                      Precios en vivo (CoinGecko)
                    </label>
                    <div className="w-48">
                      <NumberParam label="Frecuencia (s)" value={params.refreshSec ?? 60} onChange={(v)=> setParams({ ...params, refreshSec: v })} />
                    </div>
                    <button onClick={fetchLivePricesNow} className="nx-btn text-sm">Actualizar ahora</button>
                    <span className="text-xs text-neutral-500">{lastPriceTs ? `Últ. actualización: ${new Date(lastPriceTs).toLocaleTimeString()}` : '— sin actualizar —'}</span>
                    {liveError && <span className="text-xs text-rose-600">Error: {liveError}</span>}
                  </div>

                  <div className="col-span-2 rounded-2xl border border-neutral-200 p-3 flex flex-wrap items-center gap-3">
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.earnOptIn} onChange={(e)=> setParams({ ...params, earnOptIn: e.target.checked })} />
                      Considerar intereses (Savings) y compounding
                    </label>
                    <label className="flex items-center gap-2 text-sm font-medium">
                      <input type="checkbox" className="h-5 w-5" checked={!!params.earnOnCollateral} onChange={(e)=> setParams({ ...params, earnOnCollateral: e.target.checked })} />
                      Incluir colateral en Earn
                    </label>
                    <span className="text-xs text-neutral-500">* Elegible si balance ≥ ${MIN_BALANCE_PERKS}.</span>
                  </div>

                  <div className="col-span-2 text-xs text-neutral-500">
                    * LTV, APR por tier y ≤20% LTV son políticas fijas de Nexo. Aquí solo ajustás entorno (cambio, frecuencia, toggles).
                  </div>
                </div>
              </Card>

              <Card title="Requisitos NEXO & Colateral">
                <div className="grid grid-cols-1 gap-3">
                  <Line label={`Requerido Silver (1% ${params.loyaltyModel === 'vsTotal' ? 'vs total' : 'vs resto'})`} value={fmt(nexoReqs.silverReq * rate, currency)} />
                  <Line label="Faltante Silver" value={fmt(nexoReqs.missingSilver * rate, currency)} muted={nexoReqs.missingSilver <= 0} />
                  <Line label={`Requerido Gold (5% ${params.loyaltyModel === 'vsTotal' ? 'vs total' : 'vs resto'})`} value={fmt(nexoReqs.goldReq * rate, currency)} />
                  <Line label="Faltante Gold" value={fmt(nexoReqs.missingGold * rate, currency)} muted={nexoReqs.missingGold <= 0} />
                  <Line label={`Requerido Platinum (10% ${params.loyaltyModel === 'vsTotal' ? 'vs total' : 'vs resto'})`} value={fmt(nexoReqs.platReq * rate, currency)} />
                  <Line label="Faltante Platinum" value={fmt(nexoReqs.missingPlat * rate, currency)} muted={nexoReqs.missingPlat <= 0} />
                  <div className="h-px bg-neutral-200 my-1" />
                  <Line label="Colateral extra para ≤20% (fijo)" value={fmt(extraCollateralForTarget * rate, currency)} tone={extraCollateralForTarget <= 0 ? "ok" : "warn"} />
                </div>
              </Card>
            </section>

            <section className="mb-8">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-xl font-semibold">Activos y colateral</h2>
                <div className="flex items-center gap-2">
                  <button onClick={addRow} className="nx-btn text-sm">Añadir activo</button>
                  <button onClick={() => { localStorage.removeItem("nexo_assets_v1"); setAssets(defaultAssets); }} className="nx-btn nx-btn-ghost text-sm">Reset</button>
                </div>
              </div>

              <div className="overflow-x-auto rounded-2xl nx-card bg-white">
                <table className="min-w-full text-sm">
                  <thead className="bg-neutral-900 text-white sticky top-0 z-10">
                    <tr>
                      <Th>Activo</Th>
                      <Th>Ticker</Th>
                      <Th>Cantidad</Th>
                      <Th>Precio (USD)</Th>
                      <Th>Auto</Th>
                      <Th>Valor</Th>
                      <Th>Colateral</Th>
                      <Th>LTV (fijo)</Th>
                      <Th>APR Earn (flex máx)</Th>
                      <Th></Th>
                    </tr>
                  </thead>
                  <tbody>
                    {totals.withValue.map((a) => (
                      <tr key={a.id} className="border-t border-neutral-100 even:bg-neutral-50 hover:bg-neutral-100/50 transition-colors">
                        <Td align="center">
                          <input value={a.name} onChange={(e) => handleAssetChange(a.id, { name: e.target.value })} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input value={a.ticker} onChange={(e) => { const newT = e.target.value.toUpperCase(); const newL = LTV_BY_TICKER[newT]; handleAssetChange(a.id, { ticker: newT, ltv: (newL ?? a.ltv) }); if (a.priceAuto !== false) { fetchPricesForTickers([newT]); } }} className="w-24 rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input type="number" min={0} step="any" value={a.qty} onChange={(e) => { const v = e.target.valueAsNumber; handleAssetChange(a.id, { qty: Number.isFinite(v) ? v : 0 }); }} placeholder="0.00" className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center" />
                        </Td>
                        <Td align="center">
                          <input type="number" min={0} step="any" value={a.price} onChange={(e) => { const v = e.target.valueAsNumber; handleAssetChange(a.id, { price: Number.isFinite(v) ? v : 0 }); }} placeholder="0.00" disabled={a.priceAuto !== false} className="w-full rounded-xl border border-neutral-300 px-2 py-1 text-center disabled:bg-neutral-50 disabled:text-neutral-400" />
                        </Td>
                        <Td align="center">
                          <input type="checkbox" checked={a.priceAuto !== false} onChange={(e) => { handleAssetChange(a.id, { priceAuto: e.target.checked }); if (e.target.checked) { fetchPricesForTickers([a.ticker]); } }} className="h-5 w-5" />
                        </Td>
                        <Td align="center" className="font-medium">{fmt(a.value * rate, currency)}</Td>
                        <Td align="center">
                          <input type="checkbox" title="Si está activo, este activo cuenta como colateral para LTV y Tope por LTVs" checked={a.useAsCollateral} onChange={(e) => handleAssetChange(a.id, { useAsCollateral: e.target.checked })} className="h-5 w-5" />
                        </Td>
                        <Td align="center" title="Fuente pública Nexo">
                          <span className="inline-block rounded-xl bg-neutral-100 px-3 py-1 font-semibold">{pct(LTV_BY_TICKER[(a.ticker||"").toUpperCase()] ?? a.ltv ?? 0)}</span>
                        </Td>
                        <Td align="center" title="Flexible Savings – tasa tope mostrada públicamente">
                          <span className="inline-block rounded-xl bg-blue-50 text-blue-700 px-3 py-1 font-semibold">{pct(EARN_APR_TOP[(a.ticker||"").toUpperCase()] ?? 0)}</span>
                        </Td>
                        <Td align="center">
                          <button onClick={() => removeRow(a.id)} className="nx-btn nx-btn-ghost nx-btn-sm">Borrar</button>
                        </Td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <section className="mb-10 grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
              <Card title="Proyección del préstamo">
                <TrendChart data={timeline} currency={currency} rate={rate} />
              </Card>

              <Card title="Breakdown de colateral & LTV">
                <CollateralBreakdownCard
                  breakdown={collateralBreakdown}
                  currency={currency}
                  rate={rate}
                  totalCollateral={totals.totalCollateralValue}
                  totalMaxBorrow={totals.maxBorrow}
                  overallLTV={overallLTVIfBorrow}
                  target={TARGET_LTV}
                  marginCall={marginCallLTV}
                  autoRepay={autoRepayLTV}
                  capLowCost={capLowCost}
                  lowCostHeadroom={lowCostHeadroom}
                />
              </Card>

              <Card title="Diagnóstico & Sugerencias">
                <ul className="list-disc pl-5 space-y-2 text-sm">
                  <li>
                    Tu ratio NEXO es <b>{(totals.ratioVsRest * 100).toFixed(2)}% vs resto</b> / <b>{(totals.ratioVsTotal * 100).toFixed(2)}% vs total</b>. Modelo activo: <b>{params.loyaltyModel === "vsTotal" ? "vs total" : "vs resto (oficial)"}</b>. Tier actual: <b>{loyaltyTier}</b>.
                    {totals.total < MIN_BALANCE_PERKS && (<span className="text-neutral-600"> (El balance total no supera el mínimo de perks).</span>)}
                  </li>
                  <li>Para alcanzar <b>Gold</b> faltan {fmt(nexoReqs.missingGold * rate, currency)}; para <b>Platinum</b> faltan {fmt(nexoReqs.missingPlat * rate, currency)}.</li>
                  <li>
                    Con tu colateral actual, el tope por LTVs es {fmt(totals.maxBorrow * rate, currency)}. El cap Low-Cost ({(TARGET_LTV * 100).toFixed(0)}%) te permite pedir hasta {fmt(capLowCost * rate, currency)} y aún quedan {fmt(lowCostHeadroom * rate, currency)} de margen.
                  </li>
                  <li>
                    Para pedir {fmt(loanAmount * rate, currency)} y mantener ≤{(TARGET_LTV * 100).toFixed(0)}% LTV se requieren {fmt(extraCollateralForTarget * rate, currency)} adicionales en colateral.
                  </li>
                  <li>
                    APR estimado: <b>{(chosenAPR * 100).toFixed(2)}%</b>. Interés hasta repago ({daysUntilRepay} días): {fmt(interestCalc.total * rate, currency)}.{interestCalc.early > 0 && <span> Incluye interés por "early rule".</span>}
                  </li>
                  <li>
                    Earn (flex) mensual estimado {earnEligible?"(tope)":"(no elegible)"}: <b>{fmt(earnMonthly * rate, currency)}</b>. Neto mensual: <b className={netMonthly>=0?"text-emerald-700":"text-rose-700"}>{fmt(netMonthly * rate, currency)}</b>.
                  </li>
                </ul>
              </Card>

              <Card title="Exportar / Plantilla">
                <p className="text-sm text-neutral-700 mb-3">Guardamos tus datos en <code>localStorage</code>. Podés exportar un JSON con todo o resetear la demo.</p>
                <div className="flex flex-wrap gap-3">
                  <button className="nx-btn text-sm" onClick={() => {
                    const blob = new Blob([ JSON.stringify({ assets, params }, null, 2) ], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url; a.download = `nexo_dashboard_${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
                  }}>Exportar JSON</button>

                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Restablecer parámetros por defecto?")) setParams(defaultParams); }}>Reset parámetros</button>
                  <button className="nx-btn nx-btn-ghost text-sm" onClick={() => { if (confirm("¿Restablecer activos por defecto?")) setAssets(defaultAssets); }}>Reset activos</button>
                </div>
                <div className="mt-4 text-xs text-neutral-500"><p>* Este simulador es orientativo. Verifica términos/tasas vigentes en Nexo.</p></div>
              </Card>
            </section>

            <footer className="text-xs text-neutral-500">© {new Date().getFullYear()} – Demo técnica. Estética tipo Nexo: fondo azul claro, tarjetas limpias, KPIs con estilo “botón”.</footer>
          </div>
        </div>
      );
    }

    // UI helpers (pocas funciones y tono visual)
    function KPI({ title, value, subtle, tone, variant }) {
      const toneCls = tone === 'ok' ? 'text-emerald-200' : tone === 'danger' ? 'text-rose-200' : '';
      const baseCls = variant === 'button' ? 'nx-kpi-btn' : 'bg-white nx-kpi';
      return (
        <div className={`relative overflow-hidden rounded-2xl p-4 shadow-sm transition-transform duration-200 ${baseCls} cursor-pointer`} role="button" aria-label={title}>
          <div className={`text-xs uppercase tracking-wide text-center ${variant==='button' ? 'text-white/80' : 'text-neutral-500'}`}>{title}</div>
          <div className={`mt-1 text-xl font-bold text-center ${toneCls}`}>{value}</div>
          {subtle && <div className={`text-xs mt-1 text-center ${variant==='button' ? 'text-white/70' : 'text-neutral-500'}`}>{subtle}</div>}
        </div>
      );
    }
    function Card({ title, children }) {
      return (
        <div className="rounded-2xl bg-white p-5 shadow-sm nx-card">
          <div className="mb-3 flex items-center justify-between"><h3 className="text-lg font-semibold">{title}</h3></div>
          {children}
        </div>
      );
    }
    function Field({ label, children }) {
      return (
        <label className="block text-sm">
          <div className="mb-1 text-neutral-700 font-medium">{label}</div>
          {children}
        </label>
      );
    }
    function NumberParam({ label, value, onChange, step = 1 }) {
      return (
        <Field label={label}>
          <input type="number" value={value} step={step} onChange={(e) => onChange(Number(e.target.value))} className="w-full rounded-2xl border border-neutral-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-700 text-right" />
        </Field>
      );
    }
    function Th({ children }) { return (<th className="px-3 py-2 text-center align-middle text-xs font-semibold">{children}</th>); }
    function Td({ children, align = "left" }) {
      const alignClass = align === "right" ? "text-right" : align === "center" ? "text-center" : "text-left";
      return (<td className={`px-3 py-2 align-middle ${alignClass}`}>{children}</td>);
    }
    function Pill({ label, value, tone = "neutral" }) {
      const tones = { ok: "bg-emerald-50 text-emerald-700 border-emerald-200", warn: "bg-amber-50 text-amber-700 border-amber-200", danger: "bg-rose-50 text-rose-700 border-rose-200", neutral: "bg-neutral-50 text-neutral-700 border-neutral-200" };
      return (
        <div className={`rounded-2xl border px-3 py-2 ${tones[tone]}`}>
          <div className="text-xs text-neutral-500">{label}</div>
          <div className="text-sm font-semibold">{value}</div>
        </div>
      );
    }
    function Line({ label, value, muted = false, tone }) {
      const color = tone === "ok" ? "text-emerald-700" : tone === "warn" ? "text-amber-700" : tone === "danger" ? "text-rose-700" : "";
      return (
        <div className="flex items-center justify-between gap-4">
          <span className={`text-sm ${muted ? "text-neutral-400" : "text-neutral-700"}`}>{label}</span>
          <span className={`text-sm font-medium ${color}`}>{value}</span>
        </div>
      );
    }

    function LTVGauge({ value, target, marginCall, autoRepay }) {
      const clamp = (v) => Math.max(0, Math.min(1, Number.isFinite(v) ? v : 0));
      const size = 220;
      const center = size / 2;
      const radius = center - 18;
      const viewHeight = center + 32;
      const angleFor = (pct) => Math.PI - clamp(pct) * Math.PI;
      const pointFor = (pct) => {
        const angle = angleFor(pct);
        return {
          x: center + radius * Math.cos(angle),
          y: center - radius * Math.sin(angle),
        };
      };
      const describeArc = (from, to) => {
        const start = pointFor(from);
        const end = pointFor(to);
        const largeArc = (to - from) > 0.5 ? 1 : 0;
        return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArc} 0 ${end.x} ${end.y}`;
      };
      const zones = [
        { label: 'Óptimo', max: target, color: '#22c55e', legend: `≤${Math.round(target * 100)}%` },
        { label: 'Estable', max: marginCall, color: '#facc15', legend: `≤${Math.round(marginCall * 100)}%` },
        { label: 'A riesgo', max: autoRepay, color: '#fb923c', legend: `≤${Math.round(autoRepay * 100)}%` },
        { label: 'Crítico', max: 1, color: '#f87171', legend: '> límite' },
      ];
      const pad = 0.01;
      const segments = zones.reduce((acc, zone) => {
        const from = acc.length ? acc[acc.length - 1].rawTo : 0;
        const capped = Math.min(zone.max, 1);
        if (capped <= from) return acc;
        const seg = {
          from: Math.max(0, from + (from === 0 ? 0 : pad)),
          to: Math.max(Math.min(1, capped - pad), from + 0.001),
          rawTo: capped,
          color: zone.color,
          label: zone.label,
          legend: zone.legend,
        };
        return [...acc, seg];
      }, []);
      const trackPath = describeArc(0, 1);
      const valuePct = clamp(value);
      const needle = pointFor(valuePct);
      const status = valuePct <= target
        ? 'Óptimo'
        : valuePct <= marginCall
          ? 'Estable'
          : valuePct <= autoRepay
            ? 'A riesgo'
            : 'Crítico';
      const statusColor = valuePct <= target
        ? 'text-emerald-500'
        : valuePct <= marginCall
          ? 'text-amber-500'
          : valuePct <= autoRepay
            ? 'text-orange-500'
            : 'text-rose-500';
      return (
        <div className="flex flex-col items-center">
          <svg viewBox={`0 0 ${size} ${viewHeight}`} className="w-full max-w-[300px]">
            <defs>
              <linearGradient id="gaugeTrack" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stopColor="rgba(148,163,184,0.25)" />
                <stop offset="100%" stopColor="rgba(148,163,184,0.05)" />
              </linearGradient>
            </defs>
            <path d={trackPath} stroke="url(#gaugeTrack)" strokeWidth="20" fill="none" strokeLinecap="round" />
            {segments.map((seg, idx) => (
              <path
                key={idx}
                d={describeArc(seg.from, seg.to)}
                stroke={seg.color}
                strokeWidth="20"
                fill="none"
                strokeLinecap="butt"
              />
            ))}
            <line x1={center} y1={center} x2={needle.x} y2={needle.y} stroke="#0f172a" strokeWidth="4" strokeLinecap="round" />
            <circle cx={center} cy={center} r="10" fill="#1d3abf" stroke="#f8fafc" strokeWidth="3" />
            <text x={center} y={center + 28} textAnchor="middle" className="fill-slate-500" style={{ fontWeight: 600, fontSize: '11px', letterSpacing: '0.1em', textTransform: 'uppercase' }}>Salud</text>
            <text x={center} y={center + 46} textAnchor="middle" className="fill-slate-600" style={{ fontWeight: 700, fontSize: '20px' }}>{`${(valuePct * 100).toFixed(1)}%`}</text>
            <text x={center} y={center + 66} textAnchor="middle" className={`fill-current ${statusColor}`} style={{ fontWeight: 700, fontSize: '13px' }}>{status}</text>
          </svg>
          <div className="mt-3 grid grid-cols-2 gap-3 text-[11px] font-semibold text-neutral-600">
            {segments.map((seg) => (
              <div key={seg.label} className="flex items-center gap-2">
                <span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: seg.color }} />
                <span>{seg.legend} {seg.label}</span>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function TrendChart({ data, currency, rate }) {
      if (!data || data.length < 2) {
        return <div className="text-sm text-neutral-500">Configura un monto y una fecha de repago para visualizar la trayectoria.</div>;
      }
      const maxVal = Math.max(...data.flatMap(d => [d.cost, d.earn, d.balance]));
      if (!(maxVal > 0)) {
        return <div className="text-sm text-neutral-500">Agrega colateral o préstamo para generar la proyección.</div>;
      }
      const width = 420;
      const height = 220;
      const paddingX = 36;
      const paddingY = 28;
      const step = data.length > 1 ? (width - paddingX * 2) / (data.length - 1) : 0;
      const baseY = height - paddingY;
      const scaleY = (value) => {
        if (!maxVal) return baseY;
        const ratio = value / maxVal;
        const usableHeight = height - paddingY * 1.6;
        return baseY - ratio * usableHeight;
      };
      const pathFor = (key) => data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point[key]);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPath = data.map((point, index) => {
        const x = paddingX + index * step;
        const y = scaleY(point.balance);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      const areaPathClosed = `${areaPath} L ${paddingX + step * (data.length - 1)} ${baseY} L ${paddingX} ${baseY} Z`;
      const tickIndexes = Array.from(new Set([0, Math.floor(data.length / 2), data.length - 1])).filter(i => i >= 0 && i < data.length);
      const ticks = tickIndexes.map((i) => ({ x: paddingX + i * step, label: `Día ${Math.round(data[i].day)}` }));
      const colors = { balance: '#8b5cf6', cost: '#60a5fa', earn: '#34d399' };
      const lastPoint = data[data.length - 1];
      return (
        <div>
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full">
            <defs>
              <linearGradient id="chartBg" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="rgba(15,23,42,0.08)" />
                <stop offset="100%" stopColor="rgba(15,23,42,0.02)" />
              </linearGradient>
              <linearGradient id="balanceArea" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#a855f7" stopOpacity="0.35" />
                <stop offset="100%" stopColor="#a855f7" stopOpacity="0.05" />
              </linearGradient>
            </defs>
            <rect x="0" y="0" width={width} height={height} fill="url(#chartBg)" opacity="1" rx="18" />
            <path d={`M ${paddingX} ${baseY} L ${paddingX + step * (data.length - 1)} ${baseY}`} stroke="rgba(148,163,184,0.35)" strokeWidth="1.5" strokeLinecap="round" />
            <path d={areaPathClosed} fill="url(#balanceArea)" opacity="0.6" />
            <path d={pathFor('balance')} stroke={colors.balance} strokeWidth="3" fill="none" strokeLinecap="round" />
            <path d={pathFor('cost')} stroke={colors.cost} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="4 4" />
            <path d={pathFor('earn')} stroke={colors.earn} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeDasharray="6 4" />
            {ticks.map((tick) => (
              <g key={tick.label} transform={`translate(${tick.x}, ${baseY + 14})`}>
                <circle cx="0" cy="0" r="2" fill="rgba(148,163,184,0.5)" />
                <text textAnchor="middle" dy="12" className="fill-slate-400" style={{ fontSize: '10px', letterSpacing: '0.04em' }}>{tick.label}</text>
              </g>
            ))}
            {data.map((point, index) => {
              const x = paddingX + index * step;
              return (
                <circle key={`dot-${index}`} cx={x} cy={scaleY(point.balance)} r="3.5" fill="#8b5cf6" stroke="#fff" strokeWidth="1.5" />
              );
            })}
          </svg>
          <div className="mt-3 flex flex-wrap gap-4 text-xs font-semibold text-neutral-500">
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.balance }} />Balance neto</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.cost }} />Costo (interés)</span>
            <span className="flex items-center gap-2"><span className="h-2 w-4 rounded-full" style={{ background: colors.earn }} />Earn estimado</span>
          </div>
          <div className="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3 text-sm">
            <div className="rounded-xl bg-blue-50/70 px-3 py-2">
              <div className="text-xs uppercase text-blue-600">Interés total</div>
              <div className="font-semibold text-blue-700">{fmt(lastPoint.cost * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-emerald-50/70 px-3 py-2">
              <div className="text-xs uppercase text-emerald-600">Earn acumulado</div>
              <div className="font-semibold text-emerald-700">{fmt(lastPoint.earn * rate, currency)}</div>
            </div>
            <div className="rounded-xl bg-violet-50/70 px-3 py-2">
              <div className="text-xs uppercase text-violet-600">Balance estimado</div>
              <div className="font-semibold text-violet-700">{fmt(lastPoint.balance * rate, currency)}</div>
            </div>
          </div>
        </div>
      );
    }

    function CollateralBreakdownCard({ breakdown, currency, rate, totalCollateral, totalMaxBorrow, overallLTV, target, marginCall, autoRepay, capLowCost, lowCostHeadroom }) {
      if (!breakdown || breakdown.length === 0) {
        return <div className="text-sm text-neutral-500">Activa al menos un activo como colateral y asigna un préstamo para visualizar la distribución.</div>;
      }
      const toneColors = { ok: '#34d399', warn: '#facc15', danger: '#fb7185' };
      const toneBadge = { ok: 'bg-emerald-50 text-emerald-700', warn: 'bg-amber-50 text-amber-700', danger: 'bg-rose-50 text-rose-700' };
      let accShare = 0;
      const segments = breakdown.map((item) => {
        const start = accShare;
        accShare += item.share;
        const end = Math.min(1, accShare);
        return { ...item, start, end };
      });
      const gradientStops = segments.map((seg) => `${toneColors[seg.tone]} ${(seg.start * 100).toFixed(2)}% ${(seg.end * 100).toFixed(2)}%`).join(', ');
      const covered = Math.min(1, accShare);
      const gradient = `conic-gradient(${gradientStops}${covered < 1 ? `, rgba(148,163,184,0.2) ${(covered * 100).toFixed(2)}% 100%` : ''})`;
      const overallTone = overallLTV <= target ? 'ok' : overallLTV <= marginCall ? 'warn' : 'danger';
      const overallLabel = overallTone === 'ok' ? 'Sano' : overallTone === 'warn' ? 'Observar' : 'En riesgo';
      const overallToneClass = overallTone === 'ok' ? 'text-emerald-600' : overallTone === 'warn' ? 'text-amber-600' : 'text-rose-600';
      return (
        <div className="flex flex-col gap-5">
          <div className="flex flex-wrap items-center justify-center gap-6">
            <div className="relative h-40 w-40 rounded-full shadow-inner" style={{ background: gradient }}>
              <div className="absolute inset-8 rounded-full bg-white shadow flex flex-col items-center justify-center text-center">
                <span className="text-[10px] font-semibold uppercase tracking-wide text-neutral-500">LTV actual</span>
                <span className="text-xl font-bold text-neutral-900">{(overallLTV * 100).toFixed(1)}%</span>
                <span className={`mt-1 text-xs font-semibold ${overallToneClass}`}>{overallLabel}</span>
              </div>
            </div>
            <div className="space-y-2 text-sm text-neutral-600">
              <div><span className="font-semibold text-neutral-800">Colateral</span>: {fmt(totalCollateral * rate, currency)}</div>
              <div><span className="font-semibold text-neutral-800">Tope por LTVs</span>: {fmt(totalMaxBorrow * rate, currency)}</div>
              <div><span className="font-semibold text-neutral-800">Cap Low-Cost</span>: {fmt(capLowCost * rate, currency)} ({lowCostHeadroom > 0 ? `${fmt(lowCostHeadroom * rate, currency)} libres` : 'sin margen'})</div>
              <div className="flex flex-wrap gap-3 text-xs text-neutral-500 pt-1">
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.ok }} />Sano ≤ {Math.round(target * 100)}%</span>
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.warn }} />Observar ≤ {Math.round(marginCall * 100)}%</span>
                <span className="flex items-center gap-1"><span className="h-2.5 w-3.5 rounded-full" style={{ backgroundColor: toneColors.danger }} />Riesgo ≥ {Math.round(autoRepay * 100)}%</span>
              </div>
            </div>
          </div>
          <div className="space-y-3">
            {breakdown.map((item) => {
              const usagePct = Math.max(0, Math.min(100, item.usageVsCap * 100));
              const badgeLabel = item.tone === 'ok' ? 'Sano' : item.tone === 'warn' ? 'Vigilar' : 'Crítico';
              return (
                <div key={item.id} className="rounded-2xl border border-neutral-200 p-3">
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className="text-sm font-semibold text-neutral-800">{item.name}</div>
                      <div className="text-xs text-neutral-500">{item.ticker || '—'} · Colateral {fmt(item.value * rate, currency)} ({(item.share * 100).toFixed(1)}%)</div>
                      <div className="text-xs text-neutral-500">LTV tope {item.policyPct.toFixed(0)}% · Cap {fmt(item.maxBorrowForAsset * rate, currency)}</div>
                    </div>
                    <span className={`rounded-full px-2 py-1 text-xs font-semibold ${toneBadge[item.tone]}`}>{badgeLabel}</span>
                  </div>
                  <div className="mt-3 h-2.5 w-full overflow-hidden rounded-full bg-neutral-200">
                    <div className="h-full" style={{ width: `${usagePct.toFixed(1)}%`, backgroundColor: toneColors[item.tone], transition: 'width .3s ease' }} />
                  </div>
                  <div className="mt-1 flex justify-between text-[11px] text-neutral-500">
                    <span>Uso: {fmt(item.allocatedLoan * rate, currency)}</span>
                    <span>Tope: {fmt(item.maxBorrowForAsset * rate, currency)}</span>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Tests mínimos (no tocar a menos que estén mal) + 2 nuevos
    function approxEq(a, b, eps = 1e-6) { return Math.abs(a - b) <= eps; }
    function runDevTests() {
      try {
        const assets1 = [{ qty: 1000, price: 1, ticker: 'NEXO', useAsCollateral: true, ltv: 0.15 }];
        const total1 = assets1[0].qty * assets1[0].price;
        const ratioVsRest1 = Number.POSITIVE_INFINITY; const params1 = { minBalanceUSD: 5000, loyaltyModel: 'vsRest' };
        const tier1 = (total1 < params1.minBalanceUSD) ? 'Sin perks' : (ratioVsRest1 >= 0.10 ? 'Platinum' : 'Base');
        console.assert(tier1 === 'Sin perks', 'Test1: debería ser Sin perks');

        const total2 = 6000; const ratioVsRest2 = Number.POSITIVE_INFINITY;
        const tier2 = (total2 < 5000) ? 'Sin perks' : (ratioVsRest2 >= 0.10 ? 'Platinum' : 'Base');
        console.assert(tier2 === 'Platinum', 'Test2: debería ser Platinum');

        const ratioVsTotal3 = 1.0; const tier3 = (6000 < 5000) ? 'Sin perks' : (ratioVsTotal3 >= 0.10 ? 'Platinum' : 'Base');
        console.assert(tier3 === 'Platinum', 'Test3: Platinum en vsTotal con 100% NEXO');

        const colateral = 10000; const target = 0.2; const recomendado = target * colateral; console.assert(approxEq(recomendado, 2000), 'Test4: préstamo recomendado 2000');

        const maxBorrow = 5000 * 0.5 + 2000 * 0.25; console.assert(approxEq(maxBorrow, 3000), 'Test5: maxBorrow=3000');

        const vBtc = 10000, ltvBtc = 0.5; const vUsdc = 5000, ltvUsdc = 0.5; const maxBorrowMix = vBtc * ltvBtc + vUsdc * ltvUsdc; console.assert(approxEq(maxBorrowMix, 7500), 'Test6: mix con LTV oficiales');

        console.assert(COINGECKO_IDS['BTC']==='bitcoin' && COINGECKO_IDS['NEXO']==='nexo', 'Test7: map tickers');

        const assets8 = [ { qty: 1, price: 10000, ltv: 0.5, useAsCollateral: true }, { qty: 1000, price: 1, ltv: 0.5, useAsCollateral: false }, ];
        const withValue8 = assets8.map(a=>({ ...a, value: a.qty*a.price }));
        const maxBorrow8 = withValue8.filter(a=>a.useAsCollateral).reduce((acc,a)=>acc + a.value*(a.ltv||0), 0);
        console.assert(approxEq(maxBorrow8, 5000), 'Test8: solo cuenta el colateral');

        const clamp = (v)=> Math.max(0, Math.min(1, v)); console.assert(clamp(-0.1)===0 && clamp(1.2)===1 && clamp(0.5)===0.5, 'Test9: clamp LTV');

        // Nuevos: LTV fijos mapeados
        console.assert(approxEq(LTV_BY_TICKER.BTC,0.5) && approxEq(LTV_BY_TICKER.USDC,0.5), 'Test10: LTV oficiales BTC/USDC');
        console.assert((EARN_APR_TOP.USDC ?? 0) >= 0.10, 'Test11: Earn USDC tope ≥10%');
        console.log('%cSanity tests OK', 'color:green');
      } catch (e) { console.error('Sanity tests failed', e); }
    }
    if (typeof window !== 'undefined') { try { runDevTests(); } catch (_) {} }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<NexoDashboard />);
  </script>
</body>
</html>
